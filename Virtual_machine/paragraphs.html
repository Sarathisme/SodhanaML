[<p>In computing, a <b>virtual machine</b> (<b>VM</b>) is an <a href="/wiki/Emulator" title="Emulator">emulation</a> of a computer system.  Virtual machines are based on <a class="mw-redirect" href="/wiki/Computer_architectures" title="Computer architectures">computer architectures</a> and provide functionality of a physical computer. Their implementations may involve specialized hardware, software, or a combination.\n</p>, <p>There are different kinds of virtual machines, each with different functions:\n</p>, <p>Some virtual machines, such as <a href="/wiki/QEMU" title="QEMU">QEMU</a>, are designed to also emulate different architectures and allow execution of software applications and operating systems written for another <a class="mw-redirect" href="/wiki/CPU" title="CPU">CPU</a> or architecture.  <a href="/wiki/Operating-system-level_virtualization" title="Operating-system-level virtualization">Operating-system-level virtualization</a> allows the resources of a computer to be partitioned via the <a class="mw-redirect" href="/wiki/Kernel_(computer_science)" title="Kernel (computer science)">kernel</a>\'s support for multiple isolated <a href="/wiki/User_space" title="User space">user space</a> instances, which are usually called <a class="mw-redirect" href="/wiki/Container_(virtualization)" title="Container (virtualization)">containers</a> and may look and feel like real machines to the <a href="/wiki/End_user" title="End user">end users</a>.\n</p>, <p>A "virtual machine" was originally defined by <a href="/wiki/Popek_and_Goldberg_virtualization_requirements" title="Popek and Goldberg virtualization requirements">Popek and Goldberg</a> as "an efficient, isolated duplicate of a real computer machine."<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> Current use includes virtual machines that have no direct correspondence to any real hardware.<sup class="reference" id="cite_ref-Smith_Nair_05_2-0"><a href="#cite_note-Smith_Nair_05-2">[2]</a></sup>\n</p>, <p>The physical, "real-world" hardware running the VM is generally referred to as the \'host\', and the virtual machine emulated on that machine is generally referred to as the \'guest\'. A host can emulate several guests, each of which can emulate different operating systems and hardware platforms. \n</p>, <p>The desire to run multiple operating systems was the initial motive for virtual machines, so as to allow time-sharing among several single-tasking operating systems. In some respects, a system virtual machine can be considered a generalization of the concept of <a href="/wiki/Virtual_memory" title="Virtual memory">virtual memory</a> that historically preceded it. IBM\'s <a href="/wiki/CP/CMS" title="CP/CMS">CP/CMS</a>, the first systems to allow <a href="/wiki/Full_virtualization" title="Full virtualization">full virtualization</a>, implemented <a class="mw-redirect" href="/wiki/Time_sharing" title="Time sharing">time sharing</a> by providing each user with a single-user operating system, the <a href="/wiki/Conversational_Monitor_System" title="Conversational Monitor System">Conversational Monitor System</a> (CMS). Unlike virtual memory, a system virtual machine entitled the user to write privileged instructions in their code. This approach had certain advantages, such as adding input/output devices not allowed by the standard system.<sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup>\n</p>, <p>As technology evolves virtual memory for purposes of virtualization, new systems of <a href="/wiki/Memory_overcommitment" title="Memory overcommitment">memory overcommitment</a> may be applied to manage memory sharing among multiple virtual machines on one computer operating system. It may be possible to share <i>memory pages</i> that have identical contents among multiple virtual machines that run on the same physical machine, what may result in mapping them to the same physical page by a technique termed <a href="/wiki/Kernel_same-page_merging" title="Kernel same-page merging">kernel same-page merging</a> (KSM). This is especially useful for read-only pages, such as those holding code segments, which is the case for multiple virtual machines running the same or similar software, software libraries, web servers, middleware components, etc. The guest operating systems do not need to be compliant with the host hardware, thus making it possible to run different operating systems on the same computer (e.g., <a href="/wiki/Microsoft_Windows" title="Microsoft Windows">Windows</a>, <a href="/wiki/Linux" title="Linux">Linux</a>, or prior versions of an operating system) to support future software.<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup>\n</p>, <p>The use of virtual machines to support separate guest operating systems is popular in regard to <a href="/wiki/Embedded_system" title="Embedded system">embedded systems</a>. A typical use would be to run a <a href="/wiki/Real-time_operating_system" title="Real-time operating system">real-time operating system</a> simultaneously with a preferred complex operating system, such as Linux or Windows. Another use would be for novel and unproven software still in the developmental stage, so it runs inside a <a href="/wiki/Sandbox_(software_development)" title="Sandbox (software development)">sandbox</a>. Virtual machines have other advantages for operating system development and may include improved debugging access and faster reboots.<sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup>\n</p>, <p>Multiple VMs running their own guest operating system are frequently engaged for server consolidation.<sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup>\n</p>, <p>A process VM, sometimes called an <i>application virtual machine</i>, or <i>Managed Runtime Environment</i> (MRE), runs as a normal application inside a host OS and supports a single process. It is created when that process is started and destroyed when it exits. Its purpose is to provide a <a class="mw-redirect" href="/wiki/System_platform" title="System platform">platform</a>-independent programming environment that abstracts away details of the underlying hardware or operating system and allows a program to execute in the same way on any platform.\n</p>, <p>A process VM provides a high-level abstraction –  that of a <a href="/wiki/High-level_programming_language" title="High-level programming language">high-level programming language</a> (compared to the low-level ISA abstraction of the system VM). Process VMs are implemented using an <a href="/wiki/Interpreter_(computing)" title="Interpreter (computing)">interpreter</a>; performance comparable to compiled programming languages can be achieved by the use of <a href="/wiki/Just-in-time_compilation" title="Just-in-time compilation">just-in-time compilation</a>.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (November 2015)">citation needed</span></a></i>]</sup>\n</p>, <p>This type of VM has become popular with the <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java programming language</a>, which is implemented using the <a href="/wiki/Java_virtual_machine" title="Java virtual machine">Java virtual machine</a>. Other examples include the <a href="/wiki/Parrot_virtual_machine" title="Parrot virtual machine">Parrot virtual machine</a> and the <a href="/wiki/.NET_Framework" title=".NET Framework">.NET Framework</a>, which runs on a VM called the <a href="/wiki/Common_Language_Runtime" title="Common Language Runtime">Common Language Runtime</a>. All of them can serve as an <a href="/wiki/Abstraction_layer" title="Abstraction layer">abstraction layer</a> for any computer language.\n</p>, <p>A special case of process VMs are systems that abstract over the communication mechanisms of a (potentially heterogeneous) <a href="/wiki/Computer_cluster" title="Computer cluster">computer cluster</a>. Such a VM does not consist of a single process, but one process per physical machine in the cluster. They are designed to ease the task of programming concurrent applications by letting the programmer focus on algorithms rather than the communication mechanisms provided by the interconnect and the OS. They do not hide the fact that communication takes place, and as such do not attempt to present the cluster as a single machine.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (March 2013)">citation needed</span></a></i>]</sup>\n</p>, <p>Unlike other process VMs, these systems do not provide a specific programming language, but are embedded in an existing language; typically such a system provides bindings for several languages (e.g., <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> and <a href="/wiki/Fortran" title="Fortran">Fortran</a>).<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (March 2013)">citation needed</span></a></i>]</sup> Examples are <a href="/wiki/Parallel_Virtual_Machine" title="Parallel Virtual Machine">Parallel Virtual Machine</a> (PVM) and <a href="/wiki/Message_Passing_Interface" title="Message Passing Interface">Message Passing Interface</a> (MPI). They are not strictly virtual machines because the applications running on top still have access to all OS services and are therefore not confined to the system model.\n</p>, <p>Both system virtual machines and process virtual machines date to the 1960s and continue to be areas of active development.\n</p>, <p><i><b>System virtual machines</b></i> grew out of <a href="/wiki/Time-sharing" title="Time-sharing">time-sharing</a>, as notably implemented in the <a href="/wiki/Compatible_Time-Sharing_System" title="Compatible Time-Sharing System">Compatible Time-Sharing System</a> (CTSS). Time-sharing allowed multiple users to use a computer <a href="/wiki/Concurrent_computing" title="Concurrent computing">concurrently</a>: each program appeared to have full access to the machine, but only one program was executed at the time, with the system switching between programs in time slices, saving and restoring state each time. This evolved into virtual machines, notably via IBM\'s research systems: the <a href="/wiki/IBM_M44/44X" title="IBM M44/44X">M44/44X</a>, which used <a class="mw-redirect" href="/wiki/Partial_virtualization" title="Partial virtualization">partial virtualization</a>, and the <a href="/wiki/IBM_CP-40" title="IBM CP-40">CP-40</a> and <a href="/wiki/SIMMON" title="SIMMON">SIMMON</a>, which used <a href="/wiki/Full_virtualization" title="Full virtualization">full virtualization</a>, and were early examples of <a href="/wiki/Hypervisor" title="Hypervisor">hypervisors</a>. The first widely available virtual machine architecture was the <a href="/wiki/CP-67" title="CP-67">CP-67</a>/CMS (see <a href="/wiki/History_of_CP/CMS" title="History of CP/CMS">History of CP/CMS</a> for details). An important distinction was between using multiple virtual machines on one host system for time-sharing, as in M44/44X and CP-40, and using one virtual machine on a host system for prototyping, as in SIMMON. <a href="/wiki/Emulator" title="Emulator">Emulators</a>, with hardware emulation of earlier systems for compatibility, date back to the <a href="/wiki/IBM_System/360" title="IBM System/360">IBM System/360</a> in 1963,<sup class="reference" id="cite_ref-7"><a href="#cite_note-7">[7]</a></sup><sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup> while the software emulation (then-called "simulation") predates it.\n</p>, <p><i><b>Process virtual machines</b></i> arose originally as abstract platforms for an <a class="mw-redirect" href="/wiki/Intermediate_language" title="Intermediate language">intermediate language</a> used as the <a href="/wiki/Intermediate_representation" title="Intermediate representation">intermediate representation</a> of a program by a <a href="/wiki/Compiler" title="Compiler">compiler</a>; early examples date to around 1966. An early 1966 example was the <a class="mw-redirect" href="/wiki/O-code_machine" title="O-code machine">O-code machine</a>, a virtual machine that executes <a href="/wiki/O-code" title="O-code">O-code</a> (object code) emitted by the <a href="/wiki/Compiler#Front_end" title="Compiler">front end</a> of the <a href="/wiki/BCPL" title="BCPL">BCPL</a> compiler. This abstraction allowed the compiler to be easily ported to a new architecture by implementing a new <a href="/wiki/Compiler#Back_end" title="Compiler">back end</a> that took the existing O-code and compiled it to machine code for the underlying physical machine. The <a href="/wiki/Euler_(programming_language)" title="Euler (programming language)">Euler</a> language used a similar design, with the intermediate language named <i>P</i> (portable).<sup class="reference" id="cite_ref-9"><a href="#cite_note-9">[9]</a></sup> This was popularized around 1970 by <a href="/wiki/Pascal_(programming_language)" title="Pascal (programming language)">Pascal</a>, notably in the <a class="mw-redirect" href="/wiki/Pascal-P" title="Pascal-P">Pascal-P</a> system (1973) and <a class="mw-redirect" href="/wiki/Pascal-S" title="Pascal-S">Pascal-S</a> compiler (1975), in which it was termed <a href="/wiki/P-code_machine" title="P-code machine">p-code</a> and the resulting machine as a <a href="/wiki/P-code_machine" title="P-code machine">p-code machine</a>. This has been influential, and virtual machines in this sense have been often generally called p-code machines. In addition to being an intermediate language, Pascal p-code was also executed directly by an interpreter implementing the virtual machine, notably in <a href="/wiki/UCSD_Pascal" title="UCSD Pascal">UCSD Pascal</a> (1978); this influenced later interpreters, notably the <a href="/wiki/Java_virtual_machine" title="Java virtual machine">Java virtual machine</a> (JVM). Another early example was <a class="mw-redirect" href="/wiki/SNOBOL4" title="SNOBOL4">SNOBOL4</a> (1967), which was written in the SNOBOL Implementation Language (SIL), an assembly language for a virtual machine, which was then targeted to physical machines by transpiling to their native assembler via a <a class="mw-redirect" href="/wiki/Macro_assembler" title="Macro assembler">macro assembler</a>.<sup class="reference" id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup> Macros have since fallen out of favor, however, so this approach has been less influential. Process virtual machines were a popular approach to implementing early microcomputer software, including <a href="/wiki/Tiny_BASIC" title="Tiny BASIC">Tiny BASIC</a> and adventure games, from one-off implementations such as <a href="/wiki/Pyramid_2000" title="Pyramid 2000">Pyramid 2000</a> to a general-purpose engine like <a href="/wiki/Infocom" title="Infocom">Infocom</a>\'s <a href="/wiki/Z-machine" title="Z-machine">z-machine</a>, which <a href="/wiki/Graham_Nelson" title="Graham Nelson">Graham Nelson</a> argues is "possibly the most portable virtual machine ever created".<sup class="reference" id="cite_ref-inform-interpreters_11-0"><a href="#cite_note-inform-interpreters-11">[11]</a></sup>\n</p>, <p>Significant advances occurred in the implementation of <a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>-80,<sup class="reference" id="cite_ref-12"><a href="#cite_note-12">[12]</a></sup>\nparticularly the Deutsch/Schiffmann implementation<sup class="reference" id="cite_ref-13"><a href="#cite_note-13">[13]</a></sup>\nwhich pushed <a href="/wiki/Just-in-time_compilation" title="Just-in-time compilation">just-in-time (JIT) compilation</a> forward as an implementation approach that uses process virtual machine.<sup class="reference" id="cite_ref-14"><a href="#cite_note-14">[14]</a></sup>\nLater notable Smalltalk VMs were <a href="/wiki/VisualWorks" title="VisualWorks">VisualWorks</a>, the <a class="mw-redirect" href="/wiki/Squeak_Virtual_Machine" title="Squeak Virtual Machine">Squeak Virtual Machine</a>,<sup class="reference" id="cite_ref-15"><a href="#cite_note-15">[15]</a></sup>\nand <a href="/wiki/Strongtalk" title="Strongtalk">Strongtalk</a>.<sup class="reference" id="cite_ref-16"><a href="#cite_note-16">[16]</a></sup>\nA related language that produced a lot of virtual machine innovation was the <a href="/wiki/Self_(programming_language)" title="Self (programming language)">Self</a> programming language,<sup class="reference" id="cite_ref-17"><a href="#cite_note-17">[17]</a></sup>\nwhich pioneered <a href="/wiki/Adaptive_optimization" title="Adaptive optimization">adaptive optimization</a><sup class="reference" id="cite_ref-18"><a href="#cite_note-18">[18]</a></sup>\nand <a href="/wiki/Tracing_garbage_collection#Generational_GC_(ephemeral_GC)" title="Tracing garbage collection">generational garbage collection</a>. These techniques proved commercially successful in 1999 in the <a href="/wiki/HotSpot" title="HotSpot">HotSpot</a> Java virtual machine.<sup class="reference" id="cite_ref-19"><a href="#cite_note-19">[19]</a></sup>\nOther innovations include having a register-based virtual machine, to better match the underlying hardware, rather than a stack-based virtual machine, which is a closer match for the programming language; in 1995, this was pioneered by the <a class="mw-redirect" href="/wiki/Dis_virtual_machine" title="Dis virtual machine">Dis virtual machine</a> for the <a href="/wiki/Limbo_(programming_language)" title="Limbo (programming language)">Limbo</a> language.\n</p>, <p>In full virtualization, the virtual machine simulates enough hardware to allow an unmodified "guest" OS (one designed for the same <a class="mw-redirect" href="/wiki/Instruction_set" title="Instruction set">instruction set</a>) to be run in isolation. This approach was pioneered in 1966 with the IBM <a class="mw-redirect" href="/wiki/CP-40" title="CP-40">CP-40</a> and <a href="/wiki/CP-67" title="CP-67">CP-67</a>, predecessors of the <a class="mw-redirect" href="/wiki/VM_(Operating_system)" title="VM (Operating system)">VM</a> family.\n</p>, <p>Examples outside the mainframe field include <a href="/wiki/Parallels_Workstation" title="Parallels Workstation">Parallels Workstation</a>, <a href="/wiki/Parallels_Desktop_for_Mac" title="Parallels Desktop for Mac">Parallels Desktop for Mac</a>, <a href="/wiki/VirtualBox" title="VirtualBox">VirtualBox</a>, <a href="/wiki/Virtual_Iron" title="Virtual Iron">Virtual Iron</a>, <a class="mw-redirect" href="/wiki/Oracle_VM" title="Oracle VM">Oracle VM</a>, <a class="mw-redirect" href="/wiki/Microsoft_Virtual_PC" title="Microsoft Virtual PC">Virtual PC</a>, <a href="/wiki/Microsoft_Virtual_Server" title="Microsoft Virtual Server">Virtual Server</a>, <a href="/wiki/Hyper-V" title="Hyper-V">Hyper-V</a>, <a href="/wiki/VMware_Workstation" title="VMware Workstation">VMware Workstation</a>, <a href="/wiki/VMware_Server" title="VMware Server">VMware Server</a> (discontinued, formerly called GSX Server), <a href="/wiki/VMware_ESXi" title="VMware ESXi">VMware ESXi</a>, <a href="/wiki/QEMU" title="QEMU">QEMU</a>, <a href="/wiki/Adaptive_Domain_Environment_for_Operating_Systems" title="Adaptive Domain Environment for Operating Systems">Adeos</a>, Mac-on-Linux, Win4BSD, <a href="/wiki/Win4Lin" title="Win4Lin">Win4Lin Pro</a>, and <a href="/wiki/Egenera" title="Egenera">Egenera</a> vBlade  technology.\n</p>, <p>In hardware-assisted virtualization, the hardware provides architectural support that facilitates building a virtual machine monitor and allows guest OSes to be run in isolation.<sup class="reference" id="cite_ref-20"><a href="#cite_note-20">[20]</a></sup> Hardware-assisted virtualization was first introduced on the IBM System/370 in 1972,<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (July 2018)">citation needed</span></a></i>]</sup> for use with <a href="/wiki/VM_(operating_system)" title="VM (operating system)">VM/370</a>, the first virtual machine operating system offered by IBM as an official product.\n</p>, <p>In 2005 and 2006, <a href="/wiki/Intel" title="Intel">Intel</a> and <a href="/wiki/Advanced_Micro_Devices" title="Advanced Micro Devices">AMD</a> provided additional hardware to support virtualization. Sun Microsystems (now <a href="/wiki/Oracle_Corporation" title="Oracle Corporation">Oracle Corporation</a>) added similar features in their <a href="/wiki/SPARC_T3" title="SPARC T3">UltraSPARC T-Series</a> processors in 2005.  Examples of virtualization platforms adapted to such hardware include <a href="/wiki/Kernel-based_Virtual_Machine" title="Kernel-based Virtual Machine">KVM</a>, <a href="/wiki/VMware_Workstation" title="VMware Workstation">VMware Workstation</a>, <a href="/wiki/VMware_Fusion" title="VMware Fusion">VMware Fusion</a>, <a href="/wiki/Hyper-V" title="Hyper-V">Hyper-V</a>, <a href="/wiki/Windows_Virtual_PC" title="Windows Virtual PC">Windows Virtual PC</a>, <a href="/wiki/Xen" title="Xen">Xen</a>, <a href="/wiki/Parallels_Desktop_for_Mac" title="Parallels Desktop for Mac">Parallels Desktop for Mac</a>, <a href="/wiki/Oracle_VM_Server_for_SPARC" title="Oracle VM Server for SPARC">Oracle VM Server for SPARC</a>, <a href="/wiki/VirtualBox" title="VirtualBox">VirtualBox</a> and <a href="/wiki/Parallels_Workstation" title="Parallels Workstation">Parallels Workstation</a>.\n</p>, <p>In 2006, first-generation 32- and 64-bit x86 hardware support was found to rarely offer performance advantages over software virtualization.<sup class="reference" id="cite_ref-21"><a href="#cite_note-21">[21]</a></sup>\n</p>, <p>In operating-system-level virtualization, a physical server is virtualized at the operating system level, enabling multiple isolated and secure virtualized servers to run on a single physical server.  The "guest" operating system environments share the same running instance of the operating system as the host system.  Thus, the same <a class="mw-redirect" href="/wiki/Operating_system_kernel" title="Operating system kernel">operating system kernel</a> is also used to implement the "guest" environments, and applications running in a given "guest" environment view it as a stand-alone system. The pioneer implementation was <a href="/wiki/FreeBSD_jail" title="FreeBSD jail">FreeBSD jails</a>; other examples include <a href="/wiki/Docker_(software)" title="Docker (software)">Docker</a>, <a href="/wiki/Solaris_Containers" title="Solaris Containers">Solaris Containers</a>, <a href="/wiki/OpenVZ" title="OpenVZ">OpenVZ</a>, <a href="/wiki/Linux-VServer" title="Linux-VServer">Linux-VServer</a>, <a href="/wiki/LXC" title="LXC">LXC</a>, AIX <a href="/wiki/Workload_Partitions" title="Workload Partitions">Workload Partitions</a>, Parallels Virtuozzo Containers, and <a href="/wiki/ICore_Virtual_Accounts" title="ICore Virtual Accounts">iCore Virtual Accounts</a>.\n</p>]