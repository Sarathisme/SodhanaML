[<p>In the context of <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a>, <b>software quality</b> refers to two related but distinct notions that exist wherever <a href="/wiki/Quality_(business)" title="Quality (business)">quality</a> is defined in a business context:\n</p>, <p>Many aspects of structural quality can be evaluated only <a class="mw-redirect" href="/wiki/Static_testing" title="Static testing">statically</a> through the analysis of the software inner structure, its source code, at the unit level, the technology level and the system level, which is in effect how its architecture adheres to sound principles of <a href="/wiki/Software_architecture" title="Software architecture">software architecture</a> outlined in a paper on the topic by OMG.<sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup> But some structural qualities, such as <a href="/wiki/Usability" title="Usability">usability</a>, can be <a href="/wiki/Usability_testing#Methods" title="Usability testing">assessed</a> only <a href="/wiki/Dynamic_testing" title="Dynamic testing">dynamically</a> (users or others acting in their behalf interact with the software or, at least, some prototype or partial implementation; even the interaction with a mock version made in cardboard represents a dynamic test because such version can be considered a prototype). Other aspects, such as reliability, might involve not only the software but also the underlying hardware, therefore, it can be assessed both statically and dynamically (<a href="/wiki/Stress_testing_(software)" title="Stress testing (software)">stress test</a>).\n</p>, <p>Functional quality is typically assessed dynamically but it is also possible to use static tests (such as <a href="/wiki/Software_review" title="Software review">software reviews</a>).\n</p>, <p>Historically, the structure, classification and terminology of attributes and metrics applicable to <a href="/wiki/Software_quality_management" title="Software quality management">software quality management</a> have been derived or extracted from the <a class="mw-redirect" href="/wiki/ISO_9126" title="ISO 9126">ISO 9126-3</a> and the subsequent ISO 25000:2005<sup class="reference" id="cite_ref-iso25000_3-0"><a href="#cite_note-iso25000-3">[3]</a></sup> quality model, also known as SQuaRE.<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup> Based on these models, the <a href="/wiki/CISQ" title="CISQ">Consortium for IT Software Quality</a> (CISQ) has defined five major desirable structural characteristics needed for a piece of software to provide <a href="/wiki/Business_value" title="Business value">business value</a>: Reliability, Efficiency, Security, Maintainability and (adequate) Size.\n</p>, <p>Software quality measurement quantifies to what extent a software program or system rates along each of these five dimensions. An aggregated measure of software quality can be computed through a qualitative or a quantitative scoring scheme or a mix of both and then a weighting system reflecting the priorities. This view of software quality being positioned on a linear continuum is supplemented by the analysis of "critical programming errors" that under specific circumstances can lead to catastrophic outages or performance degradations that make a given system unsuitable for use regardless of rating based on aggregated measurements. Such programming errors found at the system level represent up to 90% of production issues, whilst at the unit-level, even if far more numerous, programming errors account for less than 10% of production issues. As a consequence, code quality without the context of the whole system, as <a href="/wiki/W._Edwards_Deming" title="W. Edwards Deming">W. Edwards Deming</a> described it, has limited value.\n</p>, <p>To view, explore, analyze, and communicate software quality measurements, concepts and techniques of <a href="/wiki/Information_visualization" title="Information visualization">information visualization</a> provide visual, interactive means useful, in particular, if several software quality measures have to be related to each other or to components of a software or system. For example, <a href="/wiki/Software_map" title="Software map">software maps</a> represent a specialized approach that "can express and combine information about software development, software quality, and system dynamics".<sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup>\n</p>, <p>"A science is as mature as its measurement tools," (Louis Pasteur in <a href="#CITEREFEbertDumke">Ebert &amp; Dumke</a>, p.Â 91). Measuring software quality is motivated by at least two reasons:\n</p>, <p>However, the distinction between measuring and improving software quality in an embedded system (with emphasis on risk management) and software quality in business software (with emphasis on cost and maintainability management) is becoming somewhat irrelevant. Embedded systems now often include a user interface and their designers are as much concerned with issues affecting usability and user productivity as their counterparts who focus on business applications. The latter are in turn looking at ERP or CRM system as a corporate nervous system whose uptime and performance are vital to the well-being of the enterprise. This convergence is most visible in mobile computing: a user who accesses an ERP application on their <a href="/wiki/Smartphone" title="Smartphone">smartphone</a> is depending on the quality of software across all types of software layers.\n</p>, <p>Both types of software now use multi-layered technology stacks and complex architecture so software quality analysis and measurement have to be managed in a comprehensive and consistent manner, decoupled from the software\'s ultimate purpose or use. In both cases, engineers and management need to be able to make rational decisions based on measurement and fact-based analysis in adherence to the precept <i><a href="/wiki/W._Edwards_Deming#Quotations_and_concepts" title="W. Edwards Deming">"In God (we) trust. All others bring data"</a>.</i> ((mis-)attributed to <a href="/wiki/W._Edwards_Deming" title="W. Edwards Deming">W. Edwards Deming</a> and others).\n</p>, <p>There are many different definitions of quality. For some it is the "capability of a software product to conform to requirements." (ISO/IEC 9001,<sup class="reference" id="cite_ref-ISO9001_10-0"><a href="#cite_note-ISO9001-10">[10]</a></sup> commented by<sup class="reference" id="cite_ref-ISO24765_11-0"><a href="#cite_note-ISO24765-11">[11]</a></sup>) while for others it can be synonymous with "customer value" (Highsmith, 2002) or even defect level.\n</p>, <p>The first definition of quality History remembers is from Shewhart in the beginning of 20th century: <i>There are two common aspects of quality: one of them has to do with the consideration of the quality of a thing as an objective reality independent of the existence of man. The other has to do with what we think, feel or sense as a result of the objective reality. In other words, there is a subjective side of quality.</i> (Shewhart<sup class="reference" id="cite_ref-Shewhart1931_12-0"><a href="#cite_note-Shewhart1931-12">[12]</a></sup>)\n</p>, <p>Kitchenham and Pfleeger,<sup class="reference" id="cite_ref-Kitchenham1996_13-0"><a href="#cite_note-Kitchenham1996-13">[13]</a></sup> further reporting the teachings of David Garvin,<sup class="reference" id="cite_ref-Garvin1988_14-0"><a href="#cite_note-Garvin1988-14">[14]</a></sup> identify five different perspectives on quality:\n</p>, <p>The problem inherent in attempts to define the quality of a product, almost any product, were stated by the master Walter A. Shewhart. The difficulty in defining quality is to translate future needs of the user into measurable characteristics, so that a product can be designed and turned out to give satisfaction at a price that the user will pay. This is not easy, and as soon as one feels fairly successful in the endeavor, he finds that the needs of the consumer have changed, competitors have moved in, etc.<sup class="reference" id="cite_ref-Deming1988_16-0"><a href="#cite_note-Deming1988-16">[16]</a></sup></p>, <p>Quality is a customer determination, not an engineer\'s determination, not a marketing determination, nor a general management determination. It is based on the customer\'s actual experience with the product or service, measured against his or her requirements -- stated or unstated, conscious or merely sensed, technically operational or entirely subjective -- and always representing a moving target in a competitive market.<sup class="reference" id="cite_ref-Feigenbaum_17-0"><a href="#cite_note-Feigenbaum-17">[17]</a></sup>\n</p>, <p>The word quality has multiple meanings. Two of these meanings dominate the use of the word: 1. Quality consists of those product features which meet the need of customers and thereby provide product satisfaction. 2. Quality consists of freedom from deficiencies. Nevertheless, in a handbook such as this it is convenient to standardize on a short definition of the word quality as "fitness for use".<sup class="reference" id="cite_ref-Juran1988_18-0"><a href="#cite_note-Juran1988-18">[18]</a></sup>\n</p>, <p>Even though "quality is a perceptual, conditional and somewhat subjective attribute and may be understood differently by different people" (as noted in the article on <a href="/wiki/Quality_(business)" title="Quality (business)">quality in business</a>), software structural quality characteristics have been clearly defined by the Consortium for IT Software Quality (CISQ). Under the guidance of <a class="mw-redirect" href="/wiki/Dr_Bill_Curtis" title="Dr Bill Curtis">Bill Curtis</a>, co-author of the <a href="/wiki/Capability_Maturity_Model" title="Capability Maturity Model">Capability Maturity Model</a> framework and CISQ\'s first Director; and <a href="/wiki/Capers_Jones" title="Capers Jones">Capers Jones</a>, CISQ\'s Distinguished Advisor, CISQ has defined five major desirable characteristics of a piece of software needed to provide <a href="/wiki/Business_value" title="Business value">business value</a>.<sup class="reference" id="cite_ref-19"><a href="#cite_note-19">[19]</a></sup> In the <a class="mw-redirect" href="/wiki/House_of_Quality" title="House of Quality">House of Quality</a> model, these are "Whats" that need to be achieved:\n</p>, <p>Software functional quality is defined as conformance to explicitly stated functional requirements, identified for example using <a class="mw-redirect" href="/wiki/Voice_of_the_Customer" title="Voice of the Customer">Voice of the Customer</a> analysis (part of the <a href="/wiki/Design_for_Six_Sigma" title="Design for Six Sigma">Design for Six Sigma</a> toolkit and/or documented through <a class="mw-redirect" href="/wiki/Use_cases" title="Use cases">use cases</a>) and the level of satisfaction experienced by end-users. The latter is referred as to as <a href="/wiki/Usability" title="Usability">usability</a> and is concerned with how intuitive and responsive the <a href="/wiki/User_interface" title="User interface">user interface</a> is, how easily simple and complex operations can be performed, and how useful <a class="mw-redirect" href="/wiki/Error_messages" title="Error messages">error messages</a> are. Typically, software testing practices and tools ensure that a piece of software behaves in compliance with the original design, planned user experience and desired <a href="/wiki/Software_testability" title="Software testability">testability</a>, i.e. a piece of software\'s disposition to support acceptance criteria.\n</p>, <p>The dual structural/functional dimension of software quality is consistent with the model proposed in <a href="/wiki/Steve_McConnell" title="Steve McConnell">Steve McConnell</a>\'s <a href="/wiki/Code_Complete" title="Code Complete">Code Complete</a> which divides software characteristics into two pieces: internal and external quality characteristics. External quality characteristics are those parts of a product that face its users, where internal quality characteristics are those that do not.<sup class="reference" id="cite_ref-21"><a href="#cite_note-21">[21]</a></sup>\n</p>, <p>One of the challenges in defining quality is that "everyone feels they understand it"<sup class="reference" id="cite_ref-22"><a href="#cite_note-22">[22]</a></sup> and other <a href="/wiki/Quality_(business)#Notable_definitions" title="Quality (business)">definitions of software quality</a> could be based on extending the various descriptions of the concept of quality used in business.\n</p>, <p>Dr. <a href="/wiki/Tom_DeMarco" title="Tom DeMarco">Tom DeMarco</a> has proposed that "a product\'s quality is a function of how much it changes the world for the better."<sup class="reference" id="cite_ref-23"><a href="#cite_note-23">[23]</a></sup> This can be interpreted as meaning that functional quality and user satisfaction are more important than structural quality in determining software quality.\n</p>, <p>Another definition, coined by <a href="/wiki/Gerald_Weinberg" title="Gerald Weinberg">Gerald Weinberg</a> in Quality Software Management: Systems Thinking, is "Quality is value to some person." <sup class="reference" id="cite_ref-24"><a href="#cite_note-24">[24]</a></sup><sup class="reference" id="cite_ref-25"><a href="#cite_note-25">[25]</a></sup> This definition stresses that quality is inherently subjective\xe2\x80\x94different people will experience the quality of the same software differently. One strength of this definition is the questions it invites software teams to consider, such as "Who are the people we want to value our software?" and "What will be valuable to them?".\n</p>, <p><span id="SoftwareQualityMeasurement"></span>\n</p>, <p>Although the concepts presented in this section are applicable to both structural and functional software quality, measurement of the latter is essentially performed through testing [see main article: <a href="/wiki/Software_testing" title="Software testing">Software testing</a>].\n</p>, <p>Software quality measurement is about quantifying to what extent a system or software possesses desirable characteristics. This can be performed through qualitative or quantitative means or a mix of both. In both cases, for each desirable characteristic, there are a set of measurable attributes the existence of which in a piece of software or system tend to be correlated and associated with this characteristic. For example, an attribute associated with portability is the number of target-dependent statements in a program. More precisely, using the <a class="mw-redirect" href="/wiki/Quality_Function_Deployment" title="Quality Function Deployment">Quality Function Deployment</a> approach, these measurable attributes are the "hows" that need to be enforced to enable the "whats" in the Software Quality definition above.\n</p>, <p>The structure, classification and terminology of attributes and metrics applicable to software quality management have been derived or extracted from the <a class="mw-redirect" href="/wiki/ISO_9126" title="ISO 9126">ISO 9126-3</a> and the subsequent ISO/IEC 25000:2005 quality model. The main focus is on internal structural quality. Subcategories have been created to handle specific areas like business application architecture and technical characteristics such as data access and manipulation or the notion of transactions.\n</p>, <p>The dependence tree between software quality characteristics and their measurable attributes is represented in the diagram on the right, where each of the 5 characteristics that matter for the user (right) or owner of the business system depends on measurable attributes (left):\n</p>, <p>Correlations between programming errors and production defects unveil that basic code errors account for 92% of the total errors in the source code. These numerous code-level issues eventually count for only 10% of the defects in production. Bad software engineering practices at the architecture levels account for only 8% of total defects, but consume over half the effort spent on fixing problems, and lead to 90% of the serious reliability, security, and efficiency issues in production.<sup class="reference" id="cite_ref-26"><a href="#cite_note-26">[26]</a></sup>\n</p>, <p>Many of the existing software measures count structural elements of the application that result from parsing the source code for such individual instructions (Park, 1992),<sup class="reference" id="cite_ref-27"><a href="#cite_note-27">[27]</a></sup> tokens (Halstead, 1977),<sup class="reference" id="cite_ref-28"><a href="#cite_note-28">[28]</a></sup> control structures (McCabe, 1976), and objects (Chidamber &amp; Kemerer, 1994).<sup class="reference" id="cite_ref-29"><a href="#cite_note-29">[29]</a></sup>\n</p>, <p>Software quality measurement is about quantifying to what extent a system or software rates along these dimensions. The analysis can be performed using a qualitative or quantitative approach or a mix of both to provide an aggregate view [using for example weighted average(s) that reflect relative importance between the factors being measured].\n</p>, <p>This view of software quality on a linear continuum has to be supplemented by the identification of discrete <a href="#CriticalProgrammingErrors">Critical Programming Errors</a>. These vulnerabilities may not fail a test case, but they are the result of bad practices that under specific circumstances can lead to catastrophic outages, performance degradations, security breaches, corrupted data, and myriad other problems (Nygard, 2007)<sup class="reference" id="cite_ref-30"><a href="#cite_note-30">[30]</a></sup> that make a given system de facto unsuitable for use regardless of its rating based on aggregated measurements. A well-known example of vulnerability is the <a href="/wiki/Common_Weakness_Enumeration" title="Common Weakness Enumeration">Common Weakness Enumeration</a>,<sup class="reference" id="cite_ref-31"><a href="#cite_note-31">[31]</a></sup> a repository of vulnerabilities in the source code that make applications exposed to security breaches.\n</p>, <p>The measurement of critical application characteristics involves measuring structural attributes of the application\'s architecture, coding, and in-line documentation, as displayed in the picture above. Thus, each characteristic is affected by attributes at numerous levels of abstraction in the application and all of which must be included calculating the characteristic\'s measure if it is to be a valuable predictor of quality outcomes that affect the business. The layered approach to calculating characteristic measures displayed in the figure above was first proposed by Boehm and his colleagues at TRW (Boehm, 1978)<sup class="reference" id="cite_ref-32"><a href="#cite_note-32">[32]</a></sup> and is the approach taken in the ISO 9126 and 25000 series standards. These attributes can be measured from the parsed results of a static analysis of the application source code. Even dynamic characteristics of applications such as reliability and performance efficiency have their causal roots in the static structure of the application.\n</p>, <p>Structural quality analysis and measurement is performed through the analysis of the <a href="/wiki/Source_code" title="Source code">source code</a>, the <a href="/wiki/Software_architecture" title="Software architecture">architecture</a>, <a href="/wiki/Software_framework" title="Software framework">software framework</a>, <a href="/wiki/Database_schema" title="Database schema">database schema</a> in relationship to principles and standards that together define the conceptual and logical architecture of a system. This is distinct from the basic, local, component-level code analysis typically performed by <a class="mw-redirect" href="/wiki/Development_tool" title="Development tool">development tools</a> which are mostly concerned with implementation considerations and are crucial during <a href="/wiki/Debugging" title="Debugging">debugging</a> and <a href="/wiki/Software_testing" title="Software testing">testing</a> activities.\n</p>, <p>The root causes of poor reliability are found in a combination of non-compliance with good architectural and coding practices. This non-compliance can be detected by measuring the static quality attributes of an application. Assessing the static attributes underlying an application\'s reliability provides an estimate of the level of business risk and the likelihood of potential application failures and defects the application will experience when placed in operation.\n</p>, <p>Assessing reliability requires checks of at least the following software engineering best practices and technical attributes:\n</p>, <p>Depending on the application architecture and the third-party components used (such as external libraries or frameworks), custom checks should be defined along the lines drawn by the above list of best practices to ensure a better assessment of the reliability of the delivered software.\n</p>, <p>As with Reliability, the causes of performance inefficiency are often found in violations of good architectural and coding practice which can be detected by measuring the static quality attributes of an application. These static attributes predict potential operational performance bottlenecks and future scalability problems, especially for applications requiring high execution speed for handling complex algorithms or huge volumes of data.\n</p>, <p>Assessing performance efficiency requires checking at least the following software engineering best practices and technical attributes:\n</p>, <p>Most security vulnerabilities result from poor coding and architectural practices such as SQL injection or cross-site scripting. These are well documented in lists maintained by CWE,<sup class="reference" id="cite_ref-33"><a href="#cite_note-33">[33]</a></sup> and the SEI/Computer Emergency Center <a href="/wiki/CERT_Coordination_Center" title="CERT Coordination Center">(CERT)</a> at Carnegie Mellon University.\n</p>, <p>Assessing security requires at least checking the following software engineering best practices and technical attributes:\n</p>, <p>Maintainability includes concepts of modularity, understandability, changeability, testability, reusability, and transferability from one development team to another. These do not take the form of critical issues at the code level. Rather, poor maintainability is typically the result of thousands of minor violations with best practices in documentation, complexity avoidance strategy, and basic programming practices that make the difference between clean and easy-to-read code vs. unorganized and difficult-to-read code.<sup class="reference" id="cite_ref-35"><a href="#cite_note-35">[35]</a></sup>\n</p>, <p>Assessing maintainability requires checking the following software engineering best practices and technical attributes:\n</p>, <p>Maintainability is closely related to Ward Cunningham\'s concept of <a href="/wiki/Technical_debt" title="Technical debt">technical debt</a>, which is an expression of the costs resulting of a lack of maintainability.\nReasons for why maintainability is low can be classified as reckless vs. prudent and deliberate vs. inadvertent,<sup class="reference" id="cite_ref-36"><a href="#cite_note-36">[36]</a></sup> and often have their origin in developers\' inability, lack of time and goals, their carelessness and discrepancies in the creation cost of and benefits from documentation and, in particular, maintainable <a href="/wiki/Source_code" title="Source code">source code</a>.<sup class="reference" id="cite_ref-37"><a href="#cite_note-37">[37]</a></sup>\n</p>, <p>Measuring software size requires that the whole source code be correctly gathered, including database structure scripts, data manipulation source code, component headers, configuration files etc. There are essentially two types of software sizes to be measured, the technical size (footprint) and the functional size:\n</p>, <p>The function point analysis sizing standard is supported by the International Function Point Users Group (IFPUG). It can be applied early in the software development life-cycle and it is not dependent on lines of code like the somewhat inaccurate Backfiring method. The method is technology agnostic and can be used for comparative analysis across organizations and across industries.\n</p>, <p>Since the inception of Function Point Analysis, several variations have evolved and the family of functional sizing techniques has broadened to include such sizing measures as COSMIC, NESMA, Use Case Points, FP Lite, Early and Quick FPs, and most recently Story Points. However, Function Points has a history of statistical accuracy, and has been used as a common unit of work measurement in numerous application development management (ADM) or outsourcing engagements, serving as the "currency" by which services are delivered and performance is measured.\n</p>, <p>One common limitation to the Function Point methodology is that it is a manual process and therefore it can be labor-intensive and costly in large scale initiatives such as application development or outsourcing engagements. This negative aspect of applying the methodology may be what motivated industry IT leaders to form the Consortium for IT Software Quality focused on introducing a computable metrics standard for automating the measuring of software size while the IFPUG keep promoting a manual approach as most of its activity rely on FP counters certifications.\n</p>, <p>CISQ announced the availability of its first metric standard, Automated Function Points,to the CISQ membership, in CISQ Technical. These recommendations have been developed in OMG\'s Request for Comment format and submitted to OMG\'s process for standardization.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="A link to the AFP document is not appropriate but a third-party link discussing the information here is. (December 2013)">citation needed</span></a></i>]</sup>\n</p>, <p><span id="CriticalProgrammingErrors"></span>  \nCritical Programming Errors are specific architectural and/or coding bad practices that result in the highest, immediate or long term, business disruption risk.\n</p>, <p>These are quite often technology-related and depend heavily on the context, business objectives and risks. Some may consider respect for naming conventions while others \xe2\x80\x93 those preparing the ground for a knowledge transfer for example \xe2\x80\x93 will consider it as absolutely critical.\n</p>, <p>Critical Programming Errors can also be classified per CISQ Characteristics. Basic example below: \n</p>, <p>Newer proposals for quality models such as <a href="/wiki/Squale" title="Squale">Squale</a> and Quamoco<sup class="reference" id="cite_ref-38"><a href="#cite_note-38">[38]</a></sup> propagate a direct integration of the definition of quality attributes and measurement. By breaking down quality attributes or even defining additional layers, the complex, abstract quality attributes (such as reliability or maintainability) become more manageable and measurable. Those quality models have been applied in industrial contexts but have not received widespread adoption.\n</p>, <p><b>Notes</b>\n</p>, <p><b>Bibliography</b>\n</p>]