[<p><b>Cross-validation</b>, sometimes called <b>rotation estimation</b>,<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup><sup class="reference" id="cite_ref-Kohavi95_2-0"><a href="#cite_note-Kohavi95-2">[2]</a></sup><sup class="reference" id="cite_ref-Devijver82_3-0"><a href="#cite_note-Devijver82-3">[3]</a></sup> or <b>out-of-sample testing</b> is any of various similar <a class="mw-redirect" href="/wiki/Model_validation" title="Model validation">model validation</a> techniques for assessing how the results of a <a href="/wiki/Statistics" title="Statistics">statistical</a> analysis will generalize to an independent data set. It is mainly used in settings where the goal is prediction, and one wants to estimate how <a class="mw-redirect" href="/wiki/Accuracy" title="Accuracy">accurately</a> a <a href="/wiki/Predictive_modelling" title="Predictive modelling">predictive model</a> will perform in practice.  In a prediction problem, a model is usually given a dataset of <i>known data</i> on which training is run (<i>training dataset</i>), and a dataset of <i>unknown data</i> (or <i>first seen</i> data) against which the model is tested (called the <a class="mw-redirect" href="/wiki/Validation_set" title="Validation set">validation dataset</a> or <i>testing set</i>).<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup>,<sup class="reference" id="cite_ref-Newbie_question:_Confused_about_train,_validation_and_test_data!_5-0"><a href="#cite_note-Newbie_question:_Confused_about_train,_validation_and_test_data!-5">[5]</a></sup> The goal of cross-validation is to test the model\xe2\x80\x99s ability to predict new data that was not used in estimating it, in order to flag problems like <a href="/wiki/Overfitting" title="Overfitting">overfitting</a> or <a href="/wiki/Selection_bias" title="Selection bias">selection bias</a><sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup> and to give an insight on how the model will generalize to an independent dataset (i.e., an unknown dataset, for instance from a real problem).\n</p>, <p>One round of cross-validation involves <a href="/wiki/Partition_of_a_set" title="Partition of a set">partitioning</a> a <a class="mw-redirect" href="/wiki/Statistical_sample" title="Statistical sample">sample</a> of <a href="/wiki/Data" title="Data">data</a> into <a href="/wiki/Complement_(set_theory)" title="Complement (set theory)">complementary</a> subsets, performing the analysis on one subset (called the <i>training set</i>), and validating the analysis on the other subset (called the <i>validation set</i> or <i>testing set</i>). To reduce <a href="/wiki/Variance" title="Variance">variability</a>, in most methods multiple rounds of cross-validation are performed using different partitions, and the validation results are combined (e.g. averaged) over the rounds to give an estimate of the model\xe2\x80\x99s predictive performance.\n</p>, <p>In summary, cross-validation combines (averages) measures of fitness in prediction to derive a more accurate estimate of model prediction performance.<sup class="reference" id="cite_ref-:0_7-0"><a href="#cite_note-:0-7">[7]</a></sup>\n</p>, <p>Suppose we have a <a href="/wiki/Statistical_model" title="Statistical model">model</a> with one or more unknown <a class="mw-redirect" href="/wiki/Parameters" title="Parameters">parameters</a>, and a data set to which the model can be fit (the training data set).  The fitting process <a class="mw-redirect" href="/wiki/Optimization_(mathematics)" title="Optimization (mathematics)">optimizes</a> the model parameters to make the model fit the training data as well as possible.  If we then take an <a href="/wiki/Independence_(probability_theory)" title="Independence (probability theory)">independent</a> sample of validation data from the same <a href="/wiki/Statistical_population" title="Statistical population">population</a> as the training data, it will generally turn out that the model does not fit the validation data as well as it fits the training data. The size of this difference is likely to be large especially when the size of the training data set is small, or when the number of parameters in the model is large.  Cross-validation is a way to estimate the size of this effect.\n</p>, <p>In linear regression we have <a href="/wiki/Real_number" title="Real number">real</a> <i>response values</i> <i>y</i><sub>1</sub>, ..., <i>y<sub>n</sub></i>, and <i>n</i> <i>p</i>-dimensional <a href="/wiki/Euclidean_vector" title="Euclidean vector">vector</a> <i>covariates</i> <i><b>x</b></i><sub>1</sub>, ..., <i><b>x</b></i><sub><i>n</i></sub>.  The components of the vector <i><b>x</b></i><sub><i>i</i></sub> are denoted <i>x</i><sub><i>i</i>1</sub>, ..., <i>x</i><sub><i>ip</i></sub>. If we use <a href="/wiki/Least_squares" title="Least squares">least squares</a> to fit a function in the form of a <a href="/wiki/Hyperplane" title="Hyperplane">hyperplane</a> <i>y</i> = <i>a</i> + <i><b>\xce\xb2</b></i><sup>T</sup><i><b>x</b></i> to the data (<i><b>x</b></i><sub><i>i</i></sub>, <i>y</i><sub><i>i</i></sub>)<sub> 1 \xe2\x89\xa4 <i>i</i> \xe2\x89\xa4 <i>n</i></sub>, we could then assess the fit using the <a href="/wiki/Mean_squared_error" title="Mean squared error">mean squared error</a> (MSE). The MSE for given estimated parameter values <i>a</i> and <i><b>\xce\xb2</b></i> on the training set (<i><b>x</b></i><sub><i>i</i></sub>, <i>y</i><sub><i>i</i></sub>)<sub> 1 \xe2\x89\xa4 <i>i</i> \xe2\x89\xa4 <i>n</i></sub> is\n</p>, <p>If the model is correctly specified, it can be shown under mild assumptions that the <a href="/wiki/Expected_value" title="Expected value">expected value</a> of the MSE for the training set is (<i>n</i> − <i>p</i> − 1)/(<i>n</i> + <i>p</i> + 1) &lt; 1 times the expected value of the MSE for the validation set<sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup> (the expected value is taken over the distribution of training sets).  Thus if we fit the model and compute the MSE on the training set, we will get an optimistically <a href="/wiki/Bias_(statistics)" title="Bias (statistics)">biased</a> assessment of how well the model will fit an independent data set.  This biased estimate is called the <i>in-sample</i> estimate of the fit, whereas the cross-validation estimate is an <i>out-of-sample</i> estimate.\n</p>, <p>Since in linear regression it is possible to directly compute the factor (<i>n</i> − <i>p</i> − 1)/(<i>n</i> + <i>p</i> + 1) by which the training MSE underestimates the validation MSE under the assumption that the model specification is valid, cross-validation can be used for checking whether the model has been <a href="/wiki/Overfitting" title="Overfitting">overfitted</a>, in which case the MSE in the validation set will substantially exceed its anticipated value. (Cross-validation in the context of linear regression is also useful in that it can be used to select an optimally regularized cost function).\nIn most other regression procedures (e.g. <a href="/wiki/Logistic_regression" title="Logistic regression">logistic regression</a>), there is no simple formula to compute the expected out-of-sample fit. Cross-validation is, thus, a generally applicable way to predict the performance of a model on unavailable data using numerical computation in place of theoretical analysis.\n</p>, <p>Two types of cross-validation can be distinguished, exhaustive and non-exhaustive cross-validation.\n</p>, <p>Exhaustive cross-validation methods are cross-validation methods which learn and test on all possible ways to divide the original sample into a training and a validation set.\n</p>, <p>Leave-<i>p</i>-out cross-validation (<b>LpO CV</b>) involves using <i>p</i> observations as the validation set and the remaining observations as the training set. This is repeated on all ways to cut the original sample on a validation set of <i>p</i> observations and a training set.\n</p>, <p>LpO cross-validation requires training and validating the model <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\\displaystyle C_{p}^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">\n  <semantics>\n    <mrow class="MJX-TeXAtom-ORD">\n      <mstyle displaystyle="true" scriptlevel="0">\n        <msubsup>\n          <mi>C</mi>\n          <mrow class="MJX-TeXAtom-ORD">\n            <mi>p</mi>\n          </mrow>\n          <mrow class="MJX-TeXAtom-ORD">\n            <mi>n</mi>\n          </mrow>\n        </msubsup>\n      </mstyle>\n    </mrow>\n    <annotation encoding="application/x-tex">{\\displaystyle C_{p}^{n}}</annotation>\n  </semantics>\n</math></span><img alt="{\\displaystyle C_{p}^{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/77125025d2d258df1c861216566983f1ed9814e1" style="vertical-align: -1.005ex; width:3.016ex; height:2.843ex;"/></span> times, where <i>n</i> is the number of observations in the original sample, and where <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\\displaystyle C_{p}^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">\n  <semantics>\n    <mrow class="MJX-TeXAtom-ORD">\n      <mstyle displaystyle="true" scriptlevel="0">\n        <msubsup>\n          <mi>C</mi>\n          <mrow class="MJX-TeXAtom-ORD">\n            <mi>p</mi>\n          </mrow>\n          <mrow class="MJX-TeXAtom-ORD">\n            <mi>n</mi>\n          </mrow>\n        </msubsup>\n      </mstyle>\n    </mrow>\n    <annotation encoding="application/x-tex">{\\displaystyle C_{p}^{n}}</annotation>\n  </semantics>\n</math></span><img alt="{\\displaystyle C_{p}^{n}}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/77125025d2d258df1c861216566983f1ed9814e1" style="vertical-align: -1.005ex; width:3.016ex; height:2.843ex;"/></span> is the <a href="/wiki/Binomial_coefficient" title="Binomial coefficient">binomial coefficient</a>.  For <i>p</i> &gt; 1 and for even moderately large <i>n</i>, LpO CV can become computationally infeasible.  For example, with <i>n</i> = 100 and <i>p</i> = 30 = 30 percent of 100 (as suggested above), <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\\displaystyle C_{30}^{100}\\approx 3\\times 10^{25}.}" xmlns="http://www.w3.org/1998/Math/MathML">\n  <semantics>\n    <mrow class="MJX-TeXAtom-ORD">\n      <mstyle displaystyle="true" scriptlevel="0">\n        <msubsup>\n          <mi>C</mi>\n          <mrow class="MJX-TeXAtom-ORD">\n            <mn>30</mn>\n          </mrow>\n          <mrow class="MJX-TeXAtom-ORD">\n            <mn>100</mn>\n          </mrow>\n        </msubsup>\n        <mo>≈<!-- \xe2\x89\x88 --></mo>\n        <mn>3</mn>\n        <mo>×<!-- \xc3\x97 --></mo>\n        <msup>\n          <mn>10</mn>\n          <mrow class="MJX-TeXAtom-ORD">\n            <mn>25</mn>\n          </mrow>\n        </msup>\n        <mo>.</mo>\n      </mstyle>\n    </mrow>\n    <annotation encoding="application/x-tex">{\\displaystyle C_{30}^{100}\\approx 3\\times 10^{25}.}</annotation>\n  </semantics>\n</math></span><img alt="{\\displaystyle C_{30}^{100}\\approx 3\\times 10^{25}.}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b94b52dce6d4b60369946a78774e79116988a748" style="vertical-align: -1.005ex; width:16.445ex; height:3.343ex;"/></span>\n</p>, <p>Leave-<i>one</i>-out cross-validation (<b>LOOCV</b>) is a particular case of leave-<i>p</i>-out cross-validation with <i>p</i> = 1.\n</p>, <p>The process looks similar to <a href="/wiki/Jackknife_resampling" title="Jackknife resampling">jackknife</a>; however, with cross-validation one computes a statistic on the left-out sample(s), while with jackknifing one computes a statistic from the kept samples only.\n</p>, <p>LOO cross-validation requires less computation time than LpO cross-validation because there are only <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\\displaystyle C_{1}^{n}=n}" xmlns="http://www.w3.org/1998/Math/MathML">\n  <semantics>\n    <mrow class="MJX-TeXAtom-ORD">\n      <mstyle displaystyle="true" scriptlevel="0">\n        <msubsup>\n          <mi>C</mi>\n          <mrow class="MJX-TeXAtom-ORD">\n            <mn>1</mn>\n          </mrow>\n          <mrow class="MJX-TeXAtom-ORD">\n            <mi>n</mi>\n          </mrow>\n        </msubsup>\n        <mo>=</mo>\n        <mi>n</mi>\n      </mstyle>\n    </mrow>\n    <annotation encoding="application/x-tex">{\\displaystyle C_{1}^{n}=n}</annotation>\n  </semantics>\n</math></span><img alt="{\\displaystyle C_{1}^{n}=n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/eceda2e8e978775705cc938bc05c1e7588dede11" style="vertical-align: -1.005ex; width:7.509ex; height:2.843ex;"/></span> passes rather than <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\\displaystyle C_{k}^{n}}" xmlns="http://www.w3.org/1998/Math/MathML">\n  <semantics>\n    <mrow class="MJX-TeXAtom-ORD">\n      <mstyle displaystyle="true" scriptlevel="0">\n        <msubsup>\n          <mi>C</mi>\n          <mrow class="MJX-TeXAtom-ORD">\n            <mi>k</mi>\n          </mrow>\n          <mrow class="MJX-TeXAtom-ORD">\n            <mi>n</mi>\n          </mrow>\n        </msubsup>\n      </mstyle>\n    </mrow>\n    <annotation encoding="application/x-tex">{\\displaystyle C_{k}^{n}}</annotation>\n  </semantics>\n</math></span><img alt="C_{k}^{n}" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fee549e664007a80759a5ce8e696d54f4fd996d1" style="vertical-align: -1.005ex; width:3.016ex; height:2.843ex;"/></span>. However, <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\\displaystyle n}" xmlns="http://www.w3.org/1998/Math/MathML">\n  <semantics>\n    <mrow class="MJX-TeXAtom-ORD">\n      <mstyle displaystyle="true" scriptlevel="0">\n        <mi>n</mi>\n      </mstyle>\n    </mrow>\n    <annotation encoding="application/x-tex">{\\displaystyle n}</annotation>\n  </semantics>\n</math></span><img alt="n" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" style="vertical-align: -0.338ex; width:1.395ex; height:1.676ex;"/></span> passes may still require quite a large computation time, in which case other approaches such as k-fold cross validation may be more appropriate.\n</p>, <p><b>Pseudo-Code-Algorithm:</b>\n</p>, <p><b>Input:</b>\n</p>, <p>x, {vector of length N with x-values of data points}\n</p>, <p>y, {vector of length N with y-values of data points}\n</p>, <p><b>Output:</b>\n</p>, <p>err, {estimate for the prediction error}\n</p>, <p><b>Steps:</b>\n</p>, <p>err \xe2\x86\x90 0\n</p>, <p>for i \xe2\x86\x90 1, . . . , N do\n</p>, <p>// define the cross-validation subsets\n</p>, <p>x_in \xe2\x86\x90 (x[1], . . . , x[i \xe2\x88\x92 1], x[i + 1], . . . , x[N])\n</p>, <p>y_in \xe2\x86\x90 (y[1], . . . , y[i \xe2\x88\x92 1], y[i + 1], . . . , y[N]\n</p>, <p>x_out \xe2\x86\x90 x[i]\n</p>, <p>y_out \xe2\x86\x90 interpolate(x_in, y_in, x_out, y_out)\n</p>, <p>err \xe2\x86\x90 err + (y[i] \xe2\x88\x92 y_out)^2\n</p>, <p>end for\n</p>, <p>err \xe2\x86\x90 err/N\n</p>, <p>Non-exhaustive cross validation methods do not compute all ways of splitting the original sample. Those methods are approximations of leave-<i>p</i>-out cross-validation.\n</p>, <p>In <i>k</i>-fold cross-validation, the original sample is randomly partitioned into <i>k</i> equal sized subsamples.\nOf the <i>k</i> subsamples, a single subsample is retained as the validation data for testing the model, and the remaining <i>k</i> \xe2\x88\x92 1 subsamples are used as training data. The cross-validation process is then repeated <i>k</i> times, with each of the <i>k</i> subsamples used exactly once as the validation data.  The <i>k</i> results can then be averaged to produce a single estimation. The advantage of this method over repeated random sub-sampling  (see below) is that all observations are used for both training and validation, and each observation is used for validation exactly once. 10-fold cross-validation is commonly used,<sup class="reference" id="cite_ref-McLachlan_9-0"><a href="#cite_note-McLachlan-9">[9]</a></sup> but in general <i>k</i> remains an unfixed parameter.\n</p>, <p>For example, setting <i>k</i> = <i>2</i> results in 2-fold cross-validation. In 2-fold cross-validation, we randomly shuffle the dataset into two sets <i>d</i><sub>0</sub> and <i>d</i><sub>1</sub>, so that both sets are equal size (this is usually implemented by shuffling the data array and then splitting it in two). We then train on <i>d</i><sub>0</sub> and validate on <i>d</i><sub>1</sub>, followed by training on <i>d</i><sub>1</sub> and validating on <i>d</i><sub>0</sub>.\n</p>, <p>When <i>k</i> = <i>n</i> (the number of observations), the <i>k</i>-fold cross-validation is exactly the leave-one-out cross-validation.\n</p>, <p>In <i>stratified</i> <i>k</i>-fold cross-validation, the folds are selected so that the mean response value is approximately equal in all the folds.  In the case of binary classification, this means that each fold contains roughly the same proportions of the two types of class labels.\n</p>, <p>In the holdout method, we randomly assign data points to two sets <i>d</i><sub>0</sub> and <i>d</i><sub>1</sub>, usually called the training set and the test set, respectively. The size of each of the sets is arbitrary although typically the test set is smaller than the training set. We then train (build a model) on <i>d</i><sub>0</sub> and test (evaluate its performance) on <i>d</i><sub>1</sub>.\n</p>, <p>In typical cross-validation, results of multiple runs of model-testing are averaged together; in contrast, the holdout method, in isolation, involves a single run. It should be used with caution because without such averaging of multiple runs, one may achieve highly misleading results.  One\'s indicator of predictive accuracy (F*), as noted below, will tend to be unstable since it will not be smoothed out by multiple iterations.  Similarly, indicators of the specific role played by various predictor variables (e.g., values of regression coefficients) will tend to be unstable.  \n</p>, <p>While the holdout method can be framed as "the simplest kind of cross-validation",<sup class="reference" id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup> many sources instead classify holdout as a type of simple validation, rather than a simple or degenerate form of cross-validation.<sup class="reference" id="cite_ref-Kohavi95_2-1"><a href="#cite_note-Kohavi95-2">[2]</a></sup><sup class="reference" id="cite_ref-11"><a href="#cite_note-11">[11]</a></sup>\n</p>, <p>This method, also known as Monte Carlo cross-validation,<sup class="reference" id="cite_ref-mccv_12-0"><a href="#cite_note-mccv-12">[12]</a></sup> randomly splits the dataset into training and validation data. For each such split, the model is fit to the training data, and predictive accuracy is assessed using the validation data. The results are then averaged over the splits. The advantage of this method (over <i>k</i>-fold cross validation) is that the proportion of the training/validation split is not dependent on the number of iterations (folds). The disadvantage of this method is that some observations may never be selected in the validation subsample, whereas others may be selected more than once. In other words, validation subsets may overlap.  This method also exhibits <a href="/wiki/Monte_Carlo_method" title="Monte Carlo method">Monte Carlo</a> variation, meaning that the results will vary if the analysis is repeated with different random splits.\n</p>, <p>As the number of random splits approaches infinity, the result of repeated random sub-sampling validation tends towards that of leave-p-out cross-validation.\n</p>, <p>In a stratified variant of this approach, the random samples are generated in such a way that the mean response value (i.e. the dependent variable in the regression) is equal in the training and testing sets. This is particularly useful if the responses are <a class="mw-redirect" href="/wiki/Dichotomous" title="Dichotomous">dichotomous</a> with an unbalanced representation of the two response values in the data.\n</p>, <p>The goal of cross-validation is to estimate the expected level of fit of a model to a data set that is independent of the data that were used to train the model.  It can be used to estimate any quantitative measure of fit that is appropriate for the data and model.  For example, for <a href="/wiki/Binary_classification" title="Binary classification">binary classification</a> problems, each case in the validation set is either predicted correctly or incorrectly.  In this situation the misclassification error rate can be used to summarize the fit, although other measures like <a class="mw-redirect" href="/wiki/Positive_predictive_value" title="Positive predictive value">positive predictive value</a> could also be used.  When the value being predicted is continuously distributed, the <a href="/wiki/Mean_squared_error" title="Mean squared error">mean squared error</a>, <a class="mw-redirect" href="/wiki/Root_mean_squared_error" title="Root mean squared error">root mean squared error</a> or <a href="/wiki/Median_absolute_deviation" title="Median absolute deviation">median absolute deviation</a> could be used to summarize the errors.\n</p>, <p>Suppose we choose a measure of fit <i>F</i>, and use cross-validation to produce an estimate <i>F<sup>*</sup></i> of the expected fit <i>EF</i> of a model to an independent data set drawn from the same population as the training data. If we imagine sampling multiple independent training sets following the same distribution, the resulting values for <i>F<sup>*</sup></i> will vary. The statistical properties of <i>F<sup>*</sup></i> result from this variation.\n</p>, <p>The cross-validation estimator <i>F<sup>*</sup></i> is very nearly unbiased for <i>EF</i> <sup class="reference" id="cite_ref-13"><a href="#cite_note-13">[13]</a></sup><sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (October 2016)">citation needed</span></a></i>]</sup>. The reason that it is slightly biased is that the training set in cross-validation is slightly smaller than the actual data set (e.g. for LOOCV the training set size is <i>n</i> − 1 when there are <i>n</i> observed cases). In nearly all situations, the effect of this bias will be conservative in that the estimated fit will be slightly biased in the direction suggesting a poorer fit. In practice, this bias is rarely a concern.\n</p>, <p>The variance of <i>F<sup>*</sup></i> can be large.<sup class="reference" id="cite_ref-Efron97_14-0"><a href="#cite_note-Efron97-14">[14]</a></sup><sup class="reference" id="cite_ref-Stone77_15-0"><a href="#cite_note-Stone77-15">[15]</a></sup> For this reason, if two statistical procedures are compared based on the results of cross-validation, it is important to note that the procedure with the better estimated performance may not actually be the better of the two procedures (i.e. it may not have the better value of <i>EF</i>).  Some progress has been made on constructing confidence intervals around cross-validation estimates,<sup class="reference" id="cite_ref-Efron97_14-1"><a href="#cite_note-Efron97-14">[14]</a></sup> but this is considered a difficult problem.\n</p>, <p>Most forms of cross-validation are straightforward to implement as long as an implementation of the prediction method being studied is available.  In particular, the prediction method can be a "black box" \xe2\x80\x93 there is no need to have access to the internals of its implementation.  If the prediction method is expensive to train, cross-validation can be very slow since the training must be carried out repeatedly.  In some cases such as <a href="/wiki/Least_squares" title="Least squares">least squares</a> and <a href="/wiki/Kernel_regression" title="Kernel regression">kernel regression</a>, cross-validation can be sped up significantly by pre-computing certain values that are needed repeatedly in the training, or by using fast "updating rules" such as the <a href="/wiki/Sherman%E2%80%93Morrison_formula" title="Sherman\xe2\x80\x93Morrison formula">Sherman\xe2\x80\x93Morrison formula</a>.  However one must be careful to preserve the "total blinding" of the validation set from the training procedure, otherwise bias may result.  An extreme example of accelerating cross-validation occurs in <a href="/wiki/Linear_regression" title="Linear regression">linear regression</a>, where the results of cross-validation have a <a href="/wiki/Closed-form_expression" title="Closed-form expression">closed-form expression</a> known as the <i>prediction residual error sum of squares</i> (<a href="/wiki/PRESS_statistic" title="PRESS statistic">PRESS</a>).\n</p>, <p>Cross-validation only yields meaningful results if the validation set and training set are drawn from the same population and only if human biases are controlled.\n</p>, <p>In many applications of predictive modeling, the structure of the system being studied evolves over time (i.e. it is "non-stationary").  Both of these can introduce systematic differences between the training and validation sets.  For example, if a model for <a href="/wiki/Stock_market_prediction" title="Stock market prediction">predicting stock values</a> is trained on data for a certain five-year period, it is unrealistic to treat the subsequent five-year period as a draw from the same population.  As another example, suppose a model is developed to predict an individual\'s risk for being <a href="/wiki/Medical_diagnosis" title="Medical diagnosis">diagnosed</a> with a particular disease within the next year.  If the model is trained using data from a study involving only a specific population group (e.g. young people or males), but is then applied to the general population, the cross-validation results from the training set could differ greatly from the actual predictive performance.\n</p>, <p>In many applications, models also may be incorrectly specified and vary as a function of modeler biases and/or arbitrary choices. When this occurs, there may be an illusion that the system changes in external samples, whereas the reason is that the model has missed a critical predictor and/or included a confounded predictor.   New evidence is that cross-validation by itself is not very predictive of external validity, whereas a form of experimental validation known as swap sampling that does control for human bias can be much more predictive of external validity.<sup class="reference" id="cite_ref-16"><a href="#cite_note-16">[16]</a></sup>  As defined by this large MAQC-II study across 30,000 models, swap sampling incorporates cross-validation in the sense that predictions are tested across independent training and validation samples. Yet, models are also developed across these independent samples and by modelers who are blinded to one another.  When there is a mismatch in these models developed across these swapped training and validation samples as happens quite frequently, MAQC-II shows that this will be much more predictive of poor external predictive validity than traditional cross-validation.\n</p>, <p>The reason for the success of the swapped sampling is a built-in control for human biases in model building.  In addition to placing too much faith in predictions that may vary across modelers and lead to poor external validity due to these confounding modeler effects, these are some other ways that cross-validation can be misused:\n</p>, <p>Since the order of the data is important, cross-validation might be problematic for time-series models. A more appropriate approach might be to use <a href="/wiki/Forward_chaining" title="Forward chaining">forward chaining</a>.\n</p>, <p>Cross-validation can be used to compare the performances of different predictive modeling procedures.  For example, suppose we are interested in <a href="/wiki/Optical_character_recognition" title="Optical character recognition">optical character recognition</a>, and we are considering using either <a class="mw-redirect" href="/wiki/Support_vector_machines" title="Support vector machines">support vector machines</a> (SVM) or <a class="mw-redirect" href="/wiki/K_nearest_neighbors" title="K nearest neighbors"><i>k</i>-nearest neighbors</a> (KNN) to predict the true character from an image of a handwritten character.  Using cross-validation, we could objectively compare these two methods in terms of their respective fractions of misclassified characters.  If we simply compared the methods based on their in-sample error rates, the KNN method would likely appear to perform better, since it is more flexible and hence more prone to <a href="/wiki/Overfitting" title="Overfitting">overfitting</a><sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="Under which conditions (August 2017)">citation needed</span></a></i>]</sup> compared to the SVM method.\n</p>, <p>Cross-validation can also be used in <a href="/wiki/Feature_selection" title="Feature selection"><i>variable selection</i></a>.<sup class="reference" id="cite_ref-Picard84_19-0"><a href="#cite_note-Picard84-19">[19]</a></sup> Suppose we are using the <a href="/wiki/Gene_expression" title="Gene expression">expression</a> levels of 20 <a class="mw-redirect" href="/wiki/Proteins" title="Proteins">proteins</a> to predict whether a <a href="/wiki/Cancer" title="Cancer">cancer</a> patient will respond to a <a href="/wiki/Drug" title="Drug">drug</a>. A practical goal would be to determine which subset of the 20 features should be used to produce the best predictive model. For most modeling procedures, if we compare feature subsets using the in-sample error rates, the best performance will occur when all 20 features are used. However under cross-validation, the model with the best fit will generally include only a subset of the features that are deemed truly informative.\n</p>, <p>A recent development in medical statistics is its use in meta-analysis. It forms the basis of the validation statistic, Vn which is used to test the statistical validity of meta-analysis summary estimates.<sup class="reference" id="cite_ref-20"><a href="#cite_note-20">[20]</a></sup>  It has also been used in a more conventional sense in meta-analysis to estimate the likely prediction error of meta-analysis results.<sup class="reference" id="cite_ref-21"><a href="#cite_note-21">[21]</a></sup>\n</p>]