[<p><b>Software construction</b> is a <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a> discipline. It is the detailed creation of working meaningful <a href="/wiki/Software" title="Software">software</a> through a combination of <a href="#Coding">coding</a>, <a href="/wiki/Software_verification" title="Software verification">verification</a>, <a href="/wiki/Unit_testing" title="Unit testing">unit testing</a>, <a href="/wiki/Integration_testing" title="Integration testing">integration testing</a>, and <a href="/wiki/Debugging" title="Debugging">debugging</a>. It is linked to all the other <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a> disciplines, most strongly to <a href="/wiki/Software_design" title="Software design">software design</a> and <a href="/wiki/Software_testing" title="Software testing">software testing</a>.<sup class="reference" id="cite_ref-SWEBOK_1-0"><a href="#cite_note-SWEBOK-1">[1]</a></sup>\n</p>, <p>The need to reduce complexity is mainly driven by limited ability of most people to hold complex structures and information in their working memories.  Reduced <a href="/wiki/Programming_complexity" title="Programming complexity">complexity</a> is achieved through emphasizing the creation of <a href="/wiki/Source_code" title="Source code">code</a> that is simple and readable rather than clever. Minimizing <a href="/wiki/Programming_complexity" title="Programming complexity">complexity</a> is accomplished through making use of <a href="#Standards_in_construction">standards</a>, and through numerous specific techniques in <a href="#Coding">coding</a>. It is also supported by the <a href="#Construction_quality">construction-focused quality</a> techniques.<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-3_2-0"><a href="#cite_note-FOOTNOTESWEBOK20143-3-2">[2]</a></sup>\n</p>, <p>Anticipating change helps software engineers build extensible software, which means they can enhance a software product without disrupting the underlying structure.<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-3_2-1"><a href="#cite_note-FOOTNOTESWEBOK20143-3-2">[2]</a></sup>  \nResearch over 25 years showed that the cost of rework can be 10 to 100 times (5 to 10 times for smaller projects) more expensive than getting the requirements right the first time.  Given that 25% of the requirements change during development on average project, the need to reduce the cost of rework elucidates the need for anticipating change. <sup class="reference" id="cite_ref-FOOTNOTEMcConnell2004Chapter_3_3-0"><a href="#cite_note-FOOTNOTEMcConnell2004Chapter_3-3">[3]</a></sup>\n</p>, <p>Constructing for <a href="/wiki/Software_verification" title="Software verification">verification</a> means building <a href="/wiki/Software" title="Software">software</a> in such a way that faults can be ferreted out readily by the <a class="mw-redirect" href="/wiki/Software_engineers" title="Software engineers">software engineers</a> writing the <a href="/wiki/Software" title="Software">software</a>, as well as during independent <a href="/wiki/Software_testing" title="Software testing">testing</a> and operational activities. Specific techniques that support constructing for <a href="/wiki/Software_verification" title="Software verification">verification</a> include following coding standards to support <a class="mw-redirect" href="/wiki/Code_reviews" title="Code reviews">code reviews</a>, <a href="/wiki/Unit_testing" title="Unit testing">unit testing</a>, organizing <a href="/wiki/Source_code" title="Source code">code</a> to support <a class="mw-redirect" href="/wiki/Automated_testing" title="Automated testing">automated testing</a>, and restricted use of complex or hard-to-<a class="mw-redirect" href="/wiki/Understand" title="Understand">understand</a> <a href="/wiki/Programming_language" title="Programming language">language</a> structures, among others.<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-3_2-2"><a href="#cite_note-FOOTNOTESWEBOK20143-3-2">[2]</a></sup>\n</p>, <p>Systematic reuse can enable significant software productivity, quality, and cost improvements.  Reuse has two closely related facets:<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-3_2-3"><a href="#cite_note-FOOTNOTESWEBOK20143-3-2">[2]</a></sup>\n</p>, <p>Standards, whether external (created by international organizations) or internal (created at the corporate level), that directly affect construction issues include:<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-3_2-4"><a href="#cite_note-FOOTNOTESWEBOK20143-3-2">[2]</a></sup>\n</p>, <p>Numerous <a class="mw-redirect" href="/wiki/Software_engineering_process#Software_development_models" title="Software engineering process">models</a> have been created to develop <a href="/wiki/Software" title="Software">software</a>, some of which emphasize construction more than others. Some <a class="mw-redirect" href="/wiki/Software_engineering_process#Software_development_models" title="Software engineering process">models</a> are more linear from the construction point of view, such as the <a href="/wiki/Waterfall_model" title="Waterfall model">Waterfall</a> and staged-delivery life cycle models. These <a class="mw-redirect" href="/wiki/Software_engineering_process#Software_development_models" title="Software engineering process">models</a> treat construction as an activity which occurs only after significant prerequisite work has been completed\xe2\x80\x94including detailed <a class="mw-redirect" href="/wiki/Software_Requirements" title="Software Requirements">requirements</a> work, extensive <a class="mw-redirect" href="/wiki/Software_Design" title="Software Design">design</a> work, and detailed <a class="mw-redirect" href="/wiki/Software_engineering_process#Planning" title="Software engineering process">planning</a>. Other models are more <a href="/wiki/Iterative_and_incremental_development" title="Iterative and incremental development">iterative</a>, such as <a href="/wiki/Software_prototyping#Evolutionary_prototyping" title="Software prototyping">evolutionary prototyping</a>, <a class="mw-redirect" href="/wiki/Extreme_Programming" title="Extreme Programming">Extreme Programming</a>, and <a class="mw-redirect" href="/wiki/Scrum_(development)" title="Scrum (development)">Scrum</a>. These approaches tend to treat construction as an activity that occurs concurrently with other <a href="/wiki/Software_development" title="Software development">software development</a> activities, including <a class="mw-redirect" href="/wiki/Software_Requirements" title="Software Requirements">requirements</a>, <a class="mw-redirect" href="/wiki/Software_Design" title="Software Design">design</a>, and <a class="mw-redirect" href="/wiki/Software_engineering_process#Planning" title="Software engineering process">planning</a>, or overlaps them.<sup class="reference" id="cite_ref-SWEBOK_1-1"><a href="#cite_note-SWEBOK-1">[1]</a></sup>\n</p>, <p>The choice of construction <a class="mw-redirect" href="/wiki/Software_development_methodology" title="Software development methodology">method</a> is a key aspect of the construction planning activity. The choice of construction <a class="mw-redirect" href="/wiki/Software_development_methodology" title="Software development methodology">method</a> affects the extent to which construction prerequisites (e.g. <a href="/wiki/Requirements_analysis" title="Requirements analysis">Requirements analysis</a>, <a href="/wiki/Software_design" title="Software design">Software design</a>, .. etc) are performed, the order in which they are performed, and the degree to which they are expected to be completed before construction work begins. Construction planning also defines the order in which <a href="/wiki/Component-based_software_engineering#Definition_and_characteristics_of_components" title="Component-based software engineering">components</a> are created and integrated, the <a href="/wiki/Software_quality_management" title="Software quality management">software quality management</a> processes, the allocation of task assignments to specific <a class="mw-redirect" href="/wiki/Software_engineers" title="Software engineers">software engineers</a>, and the other tasks, according to the chosen <a class="mw-redirect" href="/wiki/Software_development_methodology" title="Software development methodology">method</a>.<sup class="reference" id="cite_ref-SWEBOK_1-2"><a href="#cite_note-SWEBOK-1">[1]</a></sup>\n</p>, <p>Numerous construction activities and artifacts can be measured, including code developed, code modified, code reused, code destroyed, code complexity, code inspection statistics, fault-fix and fault-find rates, effort, and scheduling. These measurements can be useful for purposes of managing construction, ensuring quality during construction, improving the construction process, as well as for other reasons.<sup class="reference" id="cite_ref-SWEBOK_1-3"><a href="#cite_note-SWEBOK-1">[1]</a></sup>\n</p>, <p>Software construction is driven by many practical considerations:\n</p>, <p>In order to account for the unanticipated gaps in the <a href="/wiki/Software_design" title="Software design">software design</a>, during software construction some design modifications must be made on a smaller or larger scale to flesh out details of the <a href="/wiki/Software_design" title="Software design">software design</a>.<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-5_4-0"><a href="#cite_note-FOOTNOTESWEBOK20143-5-4">[4]</a></sup>\n</p>, <p>Low <a href="/wiki/Fan-out_(software)" title="Fan-out (software)">Fan-out</a> is one of the design characteristics found to be beneficial by researchers. Information hiding proved to be a useful design technique in large programs that made them easier to modify by a factor of 4. <sup class="reference" id="cite_ref-FOOTNOTEMcConnell2004Chapter_5_5-0"><a href="#cite_note-FOOTNOTEMcConnell2004Chapter_5-5">[5]</a></sup>\n</p>, <p>Construction languages include all forms of communication by which a human can specify an executable problem solution to a computer. They include configuration languages, toolkit languages, and <a class="mw-redirect" href="/wiki/Programming_languages" title="Programming languages">programming languages</a>:<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-5_-_3-6_6-0"><a href="#cite_note-FOOTNOTESWEBOK20143-5_-_3-6-6">[6]</a></sup>\n</p>, <p>Programmers working in a language they have used for three years or more are about 30 percent more productive than programmers with equivalent experience who are new to a language.  High-level languages such as C++, Java, Smalltalk, and Visual Basic yield 5 to 15 times better productivity, reliability, simplicity, and comprehensibility than low-level languages such as assembly and C.  Equivalent code has been shown to need fewer lines to be implemented in high level languages than in lower level languages.<sup class="reference" id="cite_ref-FOOTNOTEMcConnell2004Chapter_4_7-0"><a href="#cite_note-FOOTNOTEMcConnell2004Chapter_4-7">[7]</a></sup>\n</p>, <p>The following considerations apply to the software construction coding activity:<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-6_8-0"><a href="#cite_note-FOOTNOTESWEBOK20143-6-8">[8]</a></sup>\n</p>, <p>The purpose of construction testing is to reduce the gap between the time at which faults are inserted into the code and the time those faults are detected. In some cases, construction testing is performed after code has been written. In <a class="mw-redirect" href="/wiki/Test-first_programming" title="Test-first programming">test-first programming</a>, test cases are created before code is written. Construction involves two forms of testing, which are often performed by the <a href="/wiki/Software_engineer" title="Software engineer">software engineer</a> who wrote the <a href="/wiki/Source_code" title="Source code">code</a>:<sup class="reference" id="cite_ref-SWEBOK_1-4"><a href="#cite_note-SWEBOK-1">[1]</a></sup>\n</p>, <p>Implementing <a class="mw-redirect" href="/wiki/Software_reuse" title="Software reuse">software reuse</a> entails more than creating and using <a href="/wiki/Library_(computing)" title="Library (computing)">libraries</a> of assets. It requires formalizing the practice of <a class="mw-redirect" href="/wiki/Software_reuse" title="Software reuse">reuse</a> by integrating reuse processes and activities into the <a class="mw-redirect" href="/wiki/Software_life_cycle" title="Software life cycle">software life cycle</a>. The tasks related to reuse in software construction during <a href="#Coding">coding</a> and <a href="#Construction_testing">testing</a> are:<sup class="reference" id="cite_ref-SWEBOK_1-5"><a href="#cite_note-SWEBOK-1">[1]</a></sup>\n</p>, <p>The primary techniques used to ensure the quality of <a href="/wiki/Source_code" title="Source code">code</a> as it is constructed include:<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-7_15-0"><a href="#cite_note-FOOTNOTESWEBOK20143-7-15">[15]</a></sup>\n</p>, <p>Studies have shown that a combination of these techniques need to be used to achieve high defect detection rate.  Other studies showed that different people tend to find different defects.  One study found that the <a class="mw-redirect" href="/wiki/Extreme_Programming" title="Extreme Programming">Extreme Programming</a> practices of <a href="/wiki/Pair_programming" title="Pair programming">pair programming</a>, <a href="/wiki/Informal_Methods_(Validation_and_Verification)#Desk_checking" title="Informal Methods (Validation and Verification)">desk checking</a>, <a href="/wiki/Unit_testing" title="Unit testing">unit testing</a>, <a href="/wiki/Integration_testing" title="Integration testing">integration testing</a>, and <a href="/wiki/Regression_testing" title="Regression testing">regression testing</a> can achieve a 90% defect detection rate.<sup class="reference" id="cite_ref-FOOTNOTEMcConnell2004Chapter_20_16-3"><a href="#cite_note-FOOTNOTEMcConnell2004Chapter_20-16">[16]</a></sup>  An experiment involving experienced programmers found that on average they were able to find 5 errors (9 at best) out of 15 errors by testing.<sup class="reference" id="cite_ref-FOOTNOTEMcConnell2004Chapter_22_18-0"><a href="#cite_note-FOOTNOTEMcConnell2004Chapter_22-18">[18]</a></sup>\n</p>, <p>80% of the errors tend to be concentrated in 20% of the project\'s classes and routines. 50% of the errors are found in 5% of the project\'s classes.  IBM was able to reduce the customer reported defects by a factor of ten to one and to reduce their maintenance budget by 45% in its IMS system by repairing or rewriting only 31 out of 425 classes.  Around 20% of a project\'s routines contribute to 80% of the development costs.  A classic study by IBM found that few error-prone routines of OS/360 were the most expensive entities. They had around 50 defects per 1000 lines of code and fixing them costs 10 times what it took to develop the whole system.<sup class="reference" id="cite_ref-FOOTNOTEMcConnell2004Chapter_22_18-1"><a href="#cite_note-FOOTNOTEMcConnell2004Chapter_22-18">[18]</a></sup>\n</p>, <p>A key activity during construction is the integration of separately constructed <a href="/wiki/Subroutine" title="Subroutine">routines</a>, <a href="/wiki/Class_(computer_programming)" title="Class (computer programming)">classes</a>, <a href="/wiki/Component-based_software_engineering#Definition_and_characteristics_of_components" title="Component-based software engineering">components</a>, and subsystems. In addition, a particular <a href="/wiki/Software_system" title="Software system">software system</a> may need to be integrated with other software or hardware systems. Concerns related to construction integration include planning the sequence in which <a href="/wiki/Component-based_software_engineering#Definition_and_characteristics_of_components" title="Component-based software engineering">components</a> will be integrated, creating scaffolding to support interim <a href="/wiki/Software_versioning" title="Software versioning">versions</a> of the <a href="/wiki/Software" title="Software">software</a>, determining the degree of <a href="#Construction_testing">testing</a> and <a href="#Construction_quality">quality</a> work performed on <a href="/wiki/Component-based_software_engineering#Definition_and_characteristics_of_components" title="Component-based software engineering">components</a> before they are integrated, and determining points in the project at which interim <a href="/wiki/Software_versioning" title="Software versioning">versions</a> of the <a href="/wiki/Software" title="Software">software</a> are tested.<sup class="reference" id="cite_ref-SWEBOK_1-6"><a href="#cite_note-SWEBOK-1">[1]</a></sup>\n</p>, <p>Object-oriented languages support a series of runtime mechanisms that increase the flexibility and adaptability of the programs like <a class="mw-redirect" href="/wiki/Abstraction_(software_engineering)#Data_abstraction" title="Abstraction (software engineering)">data abstraction</a>, <a href="/wiki/Encapsulation_(computer_programming)" title="Encapsulation (computer programming)">encapsulation</a>, <a href="/wiki/Modular_programming" title="Modular programming">modularity</a>, <a href="/wiki/Inheritance_(object-oriented_programming)" title="Inheritance (object-oriented programming)">inheritance</a>, <a href="/wiki/Polymorphism_(computer_science)" title="Polymorphism (computer science)">polymorphism</a>, and <a href="/wiki/Reflection_(computer_programming)" title="Reflection (computer programming)">reflection</a>.<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-8_19-0"><a href="#cite_note-FOOTNOTESWEBOK20143-8-19">[19]</a></sup><sup class="reference" id="cite_ref-FOOTNOTEThayer2013140_-_141_20-0"><a href="#cite_note-FOOTNOTEThayer2013140_-_141-20">[20]</a></sup>\n</p>, <p>Data abstraction is the process by which data and programs are defined with a representation similar in form to its meaning, while hiding away the implementation details.<sup class="reference" id="cite_ref-FOOTNOTEThayer2013140_21-0"><a href="#cite_note-FOOTNOTEThayer2013140-21">[21]</a></sup> Academic research showed that data abstraction makes programs about 30% easier to understand than functional programs.<sup class="reference" id="cite_ref-FOOTNOTEMcConnell2004Chapter_6_10-2"><a href="#cite_note-FOOTNOTEMcConnell2004Chapter_6-10">[10]</a></sup>\n</p>, <p><a href="/wiki/Assertion_(software_development)" title="Assertion (software development)">Assertions</a> are executable predicates which are placed in a program that allow runtime checks of the program.<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-8_19-1"><a href="#cite_note-FOOTNOTESWEBOK20143-8-19">[19]</a></sup> <a href="/wiki/Design_by_contract" title="Design by contract">Design by contract</a> is a development approach in which preconditions and postconditions are included for each routine.  <a href="/wiki/Defensive_programming" title="Defensive programming">Defensive programming</a> is the protection a routine from being broken by invalid inputs.<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-9_22-0"><a href="#cite_note-FOOTNOTESWEBOK20143-9-22">[22]</a></sup>\n</p>, <p>Error handling refers to the programming practice of anticipating and coding for error conditions that may arise when the program runs.  <a href="/wiki/Exception_handling" title="Exception handling">Exception handling</a> is a programming language construct or hardware mechanism designed to handle the occurrence of exceptions, special conditions that change the normal flow of program execution.<sup class="reference" id="cite_ref-FOOTNOTEThayer2013142_23-0"><a href="#cite_note-FOOTNOTEThayer2013142-23">[23]</a></sup> <a href="/wiki/Fault_tolerance" title="Fault tolerance">Fault tolerance</a> is a collection of techniques that increase software reliability by detecting errors and then recovering from them if possible or containing their effects if recovery is not possible.<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-9_22-1"><a href="#cite_note-FOOTNOTESWEBOK20143-9-22">[22]</a></sup>\n</p>, <p>State-based programming is a programming technology using finite state machines to describe program behaviors.<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-9_22-2"><a href="#cite_note-FOOTNOTESWEBOK20143-9-22">[22]</a></sup>  A table-driven method is a schema that uses tables to look up information rather than using logic statements (such as if and case).<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-10_24-0"><a href="#cite_note-FOOTNOTESWEBOK20143-10-24">[24]</a></sup>\n</p>, <p>Runtime configuration is a technique that binds variable values and program settings when the program is running, usually by updating and reading configuration files in a just-in-time mode.  <a href="/wiki/Internationalization_and_localization" title="Internationalization and localization">Internationalization</a> is the technical activity of preparing a program, usually interactive software, to support multiple locales.  The corresponding activity, <a href="/wiki/Internationalization_and_localization" title="Internationalization and localization">localization</a>, is the activity of modifying a program to support a specific local language.<sup class="reference" id="cite_ref-FOOTNOTESWEBOK20143-10_24-1"><a href="#cite_note-FOOTNOTESWEBOK20143-10-24">[24]</a></sup>\n</p>]