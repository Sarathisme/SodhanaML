[<p><b>Parallel computing</b> is a type of <a href="/wiki/Computing" title="Computing">computation</a> in which many calculations or the execution of <a href="/wiki/Process_(computing)" title="Process (computing)">processes</a> are carried out simultaneously.<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> Large problems can often be divided into smaller ones, which can then be solved at the same time. There are several different forms of parallel computing: <a href="/wiki/Bit-level_parallelism" title="Bit-level parallelism">bit-level</a>, <a href="/wiki/Instruction-level_parallelism" title="Instruction-level parallelism">instruction-level</a>, <a href="/wiki/Data_parallelism" title="Data parallelism">data</a>, and <a href="/wiki/Task_parallelism" title="Task parallelism">task parallelism</a>. Parallelism has long been employed in <a class="mw-redirect" href="/wiki/High-performance_computing" title="High-performance computing">high-performance computing</a>, but it\'s gaining broader interest due to the physical constraints preventing <a href="/wiki/Frequency_scaling" title="Frequency scaling">frequency scaling</a>.<sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup> As power consumption (and consequently heat generation) by computers has become a concern in recent years,<sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup> parallel computing has become the dominant paradigm in <a href="/wiki/Computer_architecture" title="Computer architecture">computer architecture</a>, mainly in the form of <a href="/wiki/Multi-core_processor" title="Multi-core processor">multi-core processors</a>.<sup class="reference" id="cite_ref-View-Power_4-0"><a href="#cite_note-View-Power-4">[4]</a></sup>\n</p>, <p>Parallel computing is closely related to <a href="/wiki/Concurrent_computing" title="Concurrent computing">concurrent computing</a>\xe2\x80\x94they are frequently used together, and often conflated, though the two are distinct: it is possible to have parallelism without concurrency (such as <a href="/wiki/Bit-level_parallelism" title="Bit-level parallelism">bit-level parallelism</a>), and concurrency without parallelism (such as multitasking by <a href="/wiki/Time-sharing" title="Time-sharing">time-sharing</a> on a single-core CPU).<sup class="reference" id="cite_ref-waza_5-0"><a href="#cite_note-waza-5">[5]</a></sup><sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup> In parallel computing, a computational task is typically broken down into several, often many, very similar subtasks that can be processed independently and whose results are combined afterwards, upon completion. In contrast, in concurrent computing, the various processes often do not address related tasks; when they do, as is typical in <a href="/wiki/Distributed_computing" title="Distributed computing">distributed computing</a>, the separate tasks may have a varied nature and often require some <a href="/wiki/Inter-process_communication" title="Inter-process communication">inter-process communication</a> during execution.\n</p>, <p>Parallel computers can be roughly classified according to the level at which the hardware supports parallelism, with <a class="mw-redirect" href="/wiki/Multi-core" title="Multi-core">multi-core</a> and <a href="/wiki/Symmetric_multiprocessing" title="Symmetric multiprocessing">multi-processor</a> computers having multiple <a class="mw-redirect" href="/wiki/Processing_element" title="Processing element">processing elements</a> within a single machine, while <a href="/wiki/Computer_cluster" title="Computer cluster">clusters</a>, <a class="mw-redirect" href="/wiki/Massively_parallel_(computing)" title="Massively parallel (computing)">MPPs</a>, and <a href="/wiki/Grid_computing" title="Grid computing">grids</a> use multiple computers to work on the same task. Specialized parallel computer architectures are sometimes used alongside traditional processors, for accelerating specific tasks.\n</p>, <p>In some cases parallelism is transparent to the programmer, such as in bit-level or instruction-level parallelism, but explicitly <a href="/wiki/Parallel_algorithm" title="Parallel algorithm">parallel algorithms</a>, particularly those that use concurrency, are more difficult to write than sequential ones,<sup class="reference" id="cite_ref-7"><a href="#cite_note-7">[7]</a></sup> because concurrency introduces several new classes of potential <a href="/wiki/Software_bug" title="Software bug">software bugs</a>, of which <a href="/wiki/Race_condition" title="Race condition">race conditions</a> are the most common. <a class="mw-redirect" href="/wiki/Computer_networking" title="Computer networking">Communication</a> and <a href="/wiki/Synchronization_(computer_science)" title="Synchronization (computer science)">synchronization</a> between the different subtasks are typically some of the greatest obstacles to getting good parallel program performance.\n</p>, <p>A theoretical <a class="mw-redirect" href="/wiki/Upper_bound" title="Upper bound">upper bound</a> on the <a href="/wiki/Speedup" title="Speedup">speed-up</a> of a single program as a result of parallelization is given by <a href="/wiki/Amdahl%27s_law" title="Amdahl's law">Amdahl\'s law</a>.\n</p>, <p>Traditionally, <a class="mw-redirect" href="/wiki/Computer_software" title="Computer software">computer software</a> has been written for <a class="mw-redirect" href="/wiki/Serial_computation" title="Serial computation">serial computation</a>. To solve a problem, an <a href="/wiki/Algorithm" title="Algorithm">algorithm</a> is constructed and implemented as a serial stream of instructions. These instructions are executed on a <a href="/wiki/Central_processing_unit" title="Central processing unit">central processing unit</a> on one computer. Only one instruction may execute at a time\xe2\x80\x94after that instruction is finished, the next one is executed.<sup class="reference" id="cite_ref-llnltut_8-0"><a href="#cite_note-llnltut-8">[8]</a></sup>\n</p>, <p>Parallel computing, on the other hand, uses multiple processing elements simultaneously to solve a problem. This is accomplished by breaking the problem into independent parts so that each processing element can execute its part of the algorithm simultaneously with the others. The processing elements can be diverse and include resources such as a single computer with multiple processors, several networked computers, specialized hardware, or any combination of the above.<sup class="reference" id="cite_ref-llnltut_8-1"><a href="#cite_note-llnltut-8">[8]</a></sup> Historically parallel computing was used for scientific computing and the simulation of scientific problems, particularly in the natural and engineering sciences, such as <a href="/wiki/Meteorology" title="Meteorology">meteorology</a>. This led to the design of parallel hardware and software, as well as <a class="mw-redirect" href="/wiki/High_performance_computing" title="High performance computing">high performance computing</a>.<sup class="reference" id="cite_ref-9"><a href="#cite_note-9">[9]</a></sup>\n</p>, <p><a href="/wiki/Frequency_scaling" title="Frequency scaling">Frequency scaling</a> was the dominant reason for improvements in <a href="/wiki/Computer_performance" title="Computer performance">computer performance</a> from the mid-1980s until 2004. The <a href="/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">runtime</a> of a program is equal to the number of instructions multiplied by the average time per instruction. Maintaining everything else constant, increasing the clock frequency decreases the average time it takes to execute an instruction. An increase in frequency thus decreases runtime for all <a class="mw-redirect" href="/wiki/CPU_bound" title="CPU bound">compute-bound</a> programs.<sup class="reference" id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup> However, power consumption <i>P</i> by a chip is given by the equation <i>P</i> = <i>C</i> \xc3\x97 <i>V</i> <sup>2</sup> \xc3\x97 <i>F</i>, where <i>C</i> is the <a href="/wiki/Capacitance" title="Capacitance">capacitance</a> being switched per clock cycle (proportional to the number of transistors whose inputs change), <i>V</i> is <a href="/wiki/Voltage" title="Voltage">voltage</a>, and <i>F</i> is the processor frequency (cycles per second).<sup class="reference" id="cite_ref-11"><a href="#cite_note-11">[11]</a></sup> Increases in frequency increase the amount of power used in a processor. Increasing processor power consumption led ultimately to <a href="/wiki/Intel" title="Intel">Intel</a>\'s May 8, 2004 cancellation of its <a href="/wiki/Tejas_and_Jayhawk" title="Tejas and Jayhawk">Tejas and Jayhawk</a> processors, which is generally cited as the end of frequency scaling as the dominant computer architecture paradigm.<sup class="reference" id="cite_ref-12"><a href="#cite_note-12">[12]</a></sup>\n</p>, <p>To deal with the problem of power consumption and overheating the major <a href="/wiki/Central_processing_unit" title="Central processing unit">central processing unit</a> (CPU or processor) manufacturers started to produce power efficient processors with multiple cores. The core is the computing unit of the processor and in multi-core processors each core is independent and can access the same memory concurrently. <a href="/wiki/Multi-core_processor" title="Multi-core processor">Multi-core processors</a> have brought parallel computing to <a class="mw-redirect" href="/wiki/Desktop_computers" title="Desktop computers">desktop computers</a>. Thus parallelisation of serial programmes has become a mainstream programming task. In 2012 quad-core processors became standard for <a class="mw-redirect" href="/wiki/Desktop_computers" title="Desktop computers">desktop computers</a>, while <a href="/wiki/Server_(computing)" title="Server (computing)">servers</a> have 10 and 12 core processors. From <a href="/wiki/Moore%27s_law" title="Moore's law">Moore\'s law</a> it can be predicted that the number of cores per processor will double every 18\xe2\x80\x9324 months. This could mean that after 2020 a typical processor will have dozens or hundreds of cores.<sup class="reference" id="cite_ref-13"><a href="#cite_note-13">[13]</a></sup>\n</p>, <p>An <a href="/wiki/Operating_system" title="Operating system">operating system</a> can ensure that different tasks and user programmes are run in parallel on the available cores. However, for a serial software programme to take full advantage of the multi-core architecture the programmer needs to restructure and parallelise the code. A speed-up of application software runtime will no longer be achieved through frequency scaling, instead programmers will need to parallelise their software code to take advantage of the increasing computing power of multicore architectures.<sup class="reference" id="cite_ref-14"><a href="#cite_note-14">[14]</a></sup>\n</p>, <p>Optimally, the <a href="/wiki/Speedup" title="Speedup">speedup</a> from parallelization would be linear\xe2\x80\x94doubling the number of processing elements should halve the runtime, and doubling it a second time should again halve the runtime. However, very few parallel algorithms achieve optimal speedup. Most of them have a near-linear speedup for small numbers of processing elements, which flattens out into a constant value for large numbers of processing elements.\n</p>, <p>The potential speedup of an algorithm on a parallel computing platform is given by <a href="/wiki/Amdahl%27s_law" title="Amdahl's law">Amdahl\'s law</a><sup class="reference" id="cite_ref-15"><a href="#cite_note-15">[15]</a></sup>\n</p>, <p>where\n</p>, <p>Since <span class="nowrap"><i>S</i><sub>latency</sub> &lt; 1/(1 - <i>p</i>)</span>, it shows that a small part of the program which cannot be parallelized will limit the overall speedup available from parallelization. A program solving a large mathematical or engineering problem will typically consist of several parallelizable parts and several non-parallelizable (serial) parts. If the non-parallelizable part of a program accounts for 10% of the runtime (<i>p</i> = 0.9), we can get no more than a 10 times speedup, regardless of how many processors are added. This puts an upper limit on the usefulness of adding more parallel execution units. "When a task cannot be partitioned because of sequential constraints, the application of more effort has no effect on the schedule. The bearing of a child takes nine months, no matter how many women are assigned."<sup class="reference" id="cite_ref-16"><a href="#cite_note-16">[16]</a></sup>\n</p>, <p>Amdahl\'s law only applies to cases where the problem size is fixed. In practice, as more computing resources become available, they tend to get used on larger problems (larger datasets), and the time spent in the parallelizable part often grows much faster than the inherently serial work.<sup class="reference" id="cite_ref-17"><a href="#cite_note-17">[17]</a></sup> In this case, <a href="/wiki/Gustafson%27s_law" title="Gustafson's law">Gustafson\'s law</a> gives a less pessimistic and more realistic assessment of parallel performance:<sup class="reference" id="cite_ref-18"><a href="#cite_note-18">[18]</a></sup>\n</p>, <p>Both Amdahl\'s law and Gustafson\'s law assume that the running time of the serial part of the program is independent of the number of processors. Amdahl\'s law assumes that the entire problem is of fixed size so that the total amount of work to be done in parallel is also <i>independent of the number of processors</i>, whereas Gustafson\'s law assumes that the total amount of work to be done in parallel <i>varies linearly with the number of processors</i>.\n</p>, <p>Understanding <a href="/wiki/Data_dependency" title="Data dependency">data dependencies</a> is fundamental in implementing <a href="/wiki/Parallel_algorithm" title="Parallel algorithm">parallel algorithms</a>. No program can run more quickly than the longest chain of dependent calculations (known as the <a href="/wiki/Critical_path_method" title="Critical path method">critical path</a>), since calculations that depend upon prior calculations in the chain must be executed in order. However, most algorithms do not consist of just a long chain of dependent calculations; there are usually opportunities to execute independent calculations in parallel.\n</p>, <p>Let <i>P</i><sub><i>i</i></sub> and <i>P</i><sub><i>j</i></sub> be two program segments. Bernstein\'s conditions<sup class="reference" id="cite_ref-19"><a href="#cite_note-19">[19]</a></sup> describe when the two are independent and can be executed in parallel. For <i>P</i><sub><i>i</i></sub>, let <i>I</i><sub><i>i</i></sub> be all of the input variables and <i>O</i><sub><i>i</i></sub> the output variables, and likewise for <i>P</i><sub><i>j</i></sub>. <i>P</i><sub><i>i</i></sub> and <i>P</i><sub><i>j</i></sub> are independent if they satisfy\n</p>, <p>Violation of the first condition introduces a flow dependency, corresponding to the first segment producing a result used by the second segment. The second condition represents an anti-dependency, when the second segment produces a variable needed by the first segment. The third and final condition represents an output dependency: when two segments write to the same location, the result comes from the logically last executed segment.<sup class="reference" id="cite_ref-20"><a href="#cite_note-20">[20]</a></sup>\n</p>, <p>Consider the following functions, which demonstrate several kinds of dependencies:\n</p>, <p>In this example, instruction 3 cannot be executed before (or even in parallel with) instruction 2, because instruction 3 uses a result from instruction 2. It violates condition 1, and thus introduces a flow dependency.\n</p>, <p>In this example, there are no dependencies between the instructions, so they can all be run in parallel.\n</p>, <p>Bernstein\'s conditions do not allow memory to be shared between different processes. For that, some means of enforcing an ordering between accesses is necessary, such as <a href="/wiki/Semaphore_(programming)" title="Semaphore (programming)">semaphores</a>, <a href="/wiki/Barrier_(computer_science)" title="Barrier (computer science)">barriers</a> or some other <a href="/wiki/Synchronization_(computer_science)" title="Synchronization (computer science)">synchronization method</a>.\n</p>, <p>Subtasks in a parallel program are often called <a href="/wiki/Thread_(computing)" title="Thread (computing)">threads</a>. Some parallel computer architectures use smaller, lightweight versions of threads known as <a href="/wiki/Fiber_(computer_science)" title="Fiber (computer science)">fibers</a>, while others use bigger versions known as <a href="/wiki/Process_(computing)" title="Process (computing)">processes</a>. However, "threads" is generally accepted as a generic term for subtasks.<sup class="reference" id="cite_ref-21"><a href="#cite_note-21">[21]</a></sup> Threads will often need <a href="/wiki/Synchronization_(computer_science)" title="Synchronization (computer science)">synchronized</a> access to an <a href="/wiki/Object_(computer_science)" title="Object (computer science)">object</a> or other <a href="/wiki/Resource_management_(computing)" title="Resource management (computing)">resource</a>, for example when they must update a <a class="mw-redirect" href="/wiki/Variable_(programming)" title="Variable (programming)">variable</a> that is shared between them. Without synchronization, the instructions between the two threads may be interleaved in any order. For example, consider the following program:\n</p>, <p>If instruction 1B is executed between 1A and 3A, or if instruction 1A is executed between 1B and 3B, the program will produce incorrect data. This is known as a <a href="/wiki/Race_condition" title="Race condition">race condition</a>. The programmer must use a <a href="/wiki/Lock_(computer_science)" title="Lock (computer science)">lock</a> to provide <a href="/wiki/Mutual_exclusion" title="Mutual exclusion">mutual exclusion</a>. A lock is a programming language construct that allows one thread to take control of a variable and prevent other threads from reading or writing it, until that variable is unlocked. The thread holding the lock is free to execute its <a href="/wiki/Critical_section" title="Critical section">critical section</a> (the section of a program that requires exclusive access to some variable), and to unlock the data when it is finished. Therefore, to guarantee correct program execution, the above program can be rewritten to use locks:\n</p>, <p>One thread will successfully lock variable V, while the other thread will be <a href="/wiki/Software_lockout" title="Software lockout">locked out</a>\xe2\x80\x94unable to proceed until V is unlocked again. This guarantees correct execution of the program. Locks may be necessary to ensure correct program execution when threads must serialize access to resources, but their use can greatly slow a program and may affect its <a href="/wiki/Software_quality#Reliability" title="Software quality">reliability</a>.<sup class="reference" id="cite_ref-22"><a href="#cite_note-22">[22]</a></sup>\n</p>, <p>Locking multiple variables using <a class="mw-redirect" href="/wiki/Atomic_operation" title="Atomic operation">non-atomic</a> locks introduces the possibility of program <a href="/wiki/Deadlock" title="Deadlock">deadlock</a>. An <a class="mw-redirect" href="/wiki/Atomic_lock" title="Atomic lock">atomic lock</a> locks multiple variables all at once. If it cannot lock all of them, it does not lock any of them. If two threads each need to lock the same two variables using non-atomic locks, it is possible that one thread will lock one of them and the second thread will lock the second variable. In such a case, neither thread can complete, and deadlock results.<sup class="reference" id="cite_ref-23"><a href="#cite_note-23">[23]</a></sup>\n</p>, <p>Many parallel programs require that their subtasks <a href="/wiki/Synchronization_(computer_science)" title="Synchronization (computer science)">act in synchrony</a>. This requires the use of a <a href="/wiki/Barrier_(computer_science)" title="Barrier (computer science)">barrier</a>. Barriers are typically implemented using a lock or a <a href="/wiki/Semaphore_(programming)" title="Semaphore (programming)">semaphore</a>.<sup class="reference" id="cite_ref-24"><a href="#cite_note-24">[24]</a></sup> One class of algorithms, known as <a class="mw-redirect" href="/wiki/Lock-free_and_wait-free_algorithms" title="Lock-free and wait-free algorithms">lock-free and wait-free algorithms</a>, altogether avoids the use of locks and barriers. However, this approach is generally difficult to implement and requires correctly designed data structures.<sup class="reference" id="cite_ref-25"><a href="#cite_note-25">[25]</a></sup>\n</p>, <p>Not all parallelization results in speed-up. Generally, as a task is split up into more and more threads, those threads spend an ever-increasing portion of their time communicating with each other or waiting on each other for access to resources.<sup class="reference" id="cite_ref-26"><a href="#cite_note-26">[26]</a></sup><sup class="reference" id="cite_ref-27"><a href="#cite_note-27">[27]</a></sup> Once the overhead from resource contention or communication dominates the time spent on other computation, further parallelization (that is, splitting the workload over even more threads) increases rather than decreases the amount of time required to finish. This problem, known as <a href="/wiki/Parallel_slowdown" title="Parallel slowdown">parallel slowdown</a>,<sup class="reference" id="cite_ref-28"><a href="#cite_note-28">[28]</a></sup> can be improved in some cases by software analysis and redesign.<sup class="reference" id="cite_ref-29"><a href="#cite_note-29">[29]</a></sup>\n</p>, <p>Applications are often classified according to how often their subtasks need to synchronize or communicate with each other. An application exhibits fine-grained parallelism if its subtasks must communicate many times per second; it exhibits coarse-grained parallelism if they do not communicate many times per second, and it exhibits <a href="/wiki/Embarrassingly_parallel" title="Embarrassingly parallel">embarrassing parallelism</a> if they rarely or never have to communicate. Embarrassingly parallel applications are considered the easiest to parallelize.\n</p>, <p>Parallel programming languages and parallel computers must have a <a href="/wiki/Consistency_model" title="Consistency model">consistency model</a> (also known as a memory model). The consistency model defines rules for how operations on <a href="/wiki/Computer_data_storage" title="Computer data storage">computer memory</a> occur and how results are produced.\n</p>, <p>One of the first consistency models was <a href="/wiki/Leslie_Lamport" title="Leslie Lamport">Leslie Lamport</a>\'s <a href="/wiki/Sequential_consistency" title="Sequential consistency">sequential consistency</a> model. Sequential consistency is the property of a parallel program that its parallel execution produces the same results as a sequential program. Specifically, a program is sequentially consistent if "the results of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program".<sup class="reference" id="cite_ref-30"><a href="#cite_note-30">[30]</a></sup>\n</p>, <p><a href="/wiki/Software_transactional_memory" title="Software transactional memory">Software transactional memory</a> is a common type of consistency model. Software transactional memory borrows from <a class="mw-redirect" href="/wiki/Database_management_system" title="Database management system">database theory</a> the concept of <a href="/wiki/Atomic_commit" title="Atomic commit">atomic transactions</a> and applies them to memory accesses.\n</p>, <p>Mathematically, these models can be represented in several ways. Introduced in 1962, <a href="/wiki/Petri_net" title="Petri net">Petri nets</a> were an early attempt to codify the rules of consistency models. Dataflow theory later built upon these, and <a href="/wiki/Dataflow_architecture" title="Dataflow architecture">Dataflow architectures</a> were created to physically implement the ideas of dataflow theory. Beginning in the late 1970s, <a class="mw-redirect" href="/wiki/Process_calculi" title="Process calculi">process calculi</a> such as <a class="mw-redirect" href="/wiki/Calculus_of_Communicating_Systems" title="Calculus of Communicating Systems">Calculus of Communicating Systems</a> and <a class="mw-redirect" href="/wiki/Communicating_Sequential_Processes" title="Communicating Sequential Processes">Communicating Sequential Processes</a> were developed to permit algebraic reasoning about systems composed of interacting components. More recent additions to the process calculus family, such as the <a class="mw-redirect" href="/wiki/Pi_calculus" title="Pi calculus">\xcf\x80-calculus</a>, have added the capability for reasoning about dynamic topologies. Logics such as Lamport\'s <a href="/wiki/Temporal_logic_of_actions" title="Temporal logic of actions">TLA+</a>, and mathematical models such as <a href="/wiki/Trace_theory" title="Trace theory">traces</a> and <a href="/wiki/Actor_model_theory" title="Actor model theory">Actor event diagrams</a>, have also been developed to describe the behavior of concurrent systems.\n</p>, <p><a href="/wiki/Michael_J._Flynn" title="Michael J. Flynn">Michael J. Flynn</a> created one of the earliest classification systems for parallel (and sequential) computers and programs, now known as <a href="/wiki/Flynn%27s_taxonomy" title="Flynn's taxonomy">Flynn\'s taxonomy</a>. Flynn classified programs and computers by whether they were operating using a single set or multiple sets of instructions, and whether or not those instructions were using a single set or multiple sets of data.\n</p>, <p>The single-instruction-single-data (SISD) classification is equivalent to an entirely sequential program. The single-instruction-multiple-data (SIMD) classification is analogous to doing the same operation repeatedly over a large data set. This is commonly done in <a href="/wiki/Signal_processing" title="Signal processing">signal processing</a> applications. Multiple-instruction-single-data (MISD) is a rarely used classification. While computer architectures to deal with this were devised (such as <a href="/wiki/Systolic_array" title="Systolic array">systolic arrays</a>), few applications that fit this class materialized. Multiple-instruction-multiple-data (MIMD) programs are by far the most common type of parallel programs.\n</p>, <p>According to <a class="mw-redirect" href="/wiki/David_A._Patterson_(scientist)" title="David A. Patterson (scientist)">David A. Patterson</a> and <a href="/wiki/John_L._Hennessy" title="John L. Hennessy">John L. Hennessy</a>, "Some machines are hybrids of these categories, of course, but this classic model has survived because it is simple, easy to understand, and gives a good first approximation. It is also\xe2\x80\x94perhaps because of its understandability\xe2\x80\x94the most widely used scheme."<sup class="reference" id="cite_ref-31"><a href="#cite_note-31">[31]</a></sup>\n</p>, <p>From the advent of <a class="mw-redirect" href="/wiki/Very-large-scale_integration" title="Very-large-scale integration">very-large-scale integration</a> (VLSI) computer-chip fabrication technology in the 1970s until about 1986, speed-up in computer architecture was driven by doubling <a class="mw-redirect" href="/wiki/Word_(data_type)" title="Word (data type)">computer word size</a>\xe2\x80\x94the amount of information the processor can manipulate per cycle.<sup class="reference" id="cite_ref-32"><a href="#cite_note-32">[32]</a></sup> Increasing the word size reduces the number of instructions the processor must execute to perform an operation on variables whose sizes are greater than the length of the word. For example, where an <a href="/wiki/8-bit" title="8-bit">8-bit</a> processor must add two <a href="/wiki/16-bit" title="16-bit">16-bit</a> <a href="/wiki/Integer" title="Integer">integers</a>, the processor must first add the 8 lower-order bits from each integer using the standard addition instruction, then add the 8 higher-order bits using an add-with-carry instruction and the <a class="mw-redirect" href="/wiki/Carry_bit" title="Carry bit">carry bit</a> from the lower order addition; thus, an 8-bit processor requires two instructions to complete a single operation, where a 16-bit processor would be able to complete the operation with a single instruction.\n</p>, <p>Historically, <a href="/wiki/4-bit" title="4-bit">4-bit</a> microprocessors were replaced with 8-bit, then 16-bit, then 32-bit microprocessors. This trend generally came to an end with the introduction of 32-bit processors, which has been a standard in general-purpose computing for two decades. Not until the early 2000s, with the advent of <a href="/wiki/X86-64" title="X86-64">x86-64</a> architectures, did <a class="mw-redirect" href="/wiki/64-bit" title="64-bit">64-bit</a> processors become commonplace.\n</p>, <p>A computer program is, in essence, a stream of instructions executed by a processor. Without instruction-level parallelism, a processor can only issue less than one <a href="/wiki/Instructions_per_cycle" title="Instructions per cycle">instruction per clock cycle</a> (<span class="nowrap">IPC &lt; 1</span>). These processors are known as <i>subscalar</i> processors. These instructions can be <a href="/wiki/Out-of-order_execution" title="Out-of-order execution">re-ordered</a> and combined into groups which are then executed in parallel without changing the result of the program. This is known as instruction-level parallelism. Advances in instruction-level parallelism dominated computer architecture from the mid-1980s until the mid-1990s.<sup class="reference" id="cite_ref-33"><a href="#cite_note-33">[33]</a></sup>\n</p>, <p>All modern processors have multi-stage <a href="/wiki/Instruction_pipelining" title="Instruction pipelining">instruction pipelines</a>. Each stage in the pipeline corresponds to a different action the processor performs on that instruction in that stage; a processor with an <i>N</i>-stage pipeline can have up to <i>N</i> different instructions at different stages of completion and thus can issue one instruction per clock cycle (<span class="nowrap">IPC = 1</span>). These processors are known as <i>scalar</i> processors. The canonical example of a pipelined processor is a <a class="mw-redirect" href="/wiki/Reduced_Instruction_Set_Computer" title="Reduced Instruction Set Computer">RISC</a> processor, with five stages: instruction fetch (IF), instruction decode (ID), execute (EX), memory access (MEM), and register write back (WB). The <a href="/wiki/Pentium_4" title="Pentium 4">Pentium 4</a> processor had a 35-stage pipeline.<sup class="reference" id="cite_ref-34"><a href="#cite_note-34">[34]</a></sup>\n</p>, <p>Most modern processors also have multiple <a href="/wiki/Execution_unit" title="Execution unit">execution units</a>. They usually combine this feature with pipelining and thus can issue more than one instruction per clock cycle (<span class="nowrap">IPC &gt; 1</span>). These processors are known as <i><a class="mw-redirect" href="/wiki/Superscalar" title="Superscalar">superscalar</a></i> processors. Instructions can be grouped together only if there is no <a href="/wiki/Data_dependency" title="Data dependency">data dependency</a> between them. <a href="/wiki/Scoreboarding" title="Scoreboarding">Scoreboarding</a> and the <a href="/wiki/Tomasulo_algorithm" title="Tomasulo algorithm">Tomasulo algorithm</a> (which is similar to scoreboarding but makes use of <a href="/wiki/Register_renaming" title="Register renaming">register renaming</a>) are two of the most common techniques for implementing out-of-order execution and instruction-level parallelism.\n</p>, <p>Task parallelisms is the characteristic of a parallel program that "entirely different calculations can be performed on either the same or different sets of data".<sup class="reference" id="cite_ref-Culler124_35-0"><a href="#cite_note-Culler124-35">[35]</a></sup> This contrasts with data parallelism, where the same calculation is performed on the same or different sets of data. Task parallelism involves the decomposition of a task into sub-tasks and then allocating each sub-task to a processor for execution. The processors would then execute these sub-tasks concurrently and often cooperatively. Task parallelism does not usually scale with the size of a problem.<sup class="reference" id="cite_ref-Culler125_36-0"><a href="#cite_note-Culler125-36">[36]</a></sup>\n</p>, <p>Main memory in a parallel computer is either <a class="mw-redirect" href="/wiki/Shared_memory_(interprocess_communication)" title="Shared memory (interprocess communication)">shared memory</a> (shared between all processing elements in a single <a href="/wiki/Address_space" title="Address space">address space</a>), or <a href="/wiki/Distributed_memory" title="Distributed memory">distributed memory</a> (in which each processing element has its own local address space).<sup class="reference" id="cite_ref-PH713_37-0"><a href="#cite_note-PH713-37">[37]</a></sup> Distributed memory refers to the fact that the memory is logically distributed, but often implies that it is physically distributed as well. <a href="/wiki/Distributed_shared_memory" title="Distributed shared memory">Distributed shared memory</a> and <a href="/wiki/Memory_virtualization" title="Memory virtualization">memory virtualization</a> combine the two approaches, where the processing element has its own local memory and access to the memory on non-local processors. Accesses to local memory are typically faster than accesses to non-local memory.\n</p>, <p>Computer architectures in which each element of main memory can be accessed with equal <a href="/wiki/Memory_latency" title="Memory latency">latency</a> and <a href="/wiki/Bandwidth_(computing)" title="Bandwidth (computing)">bandwidth</a> are known as <a href="/wiki/Uniform_memory_access" title="Uniform memory access">uniform memory access</a> (UMA) systems. Typically, that can be achieved only by a <a class="mw-redirect" href="/wiki/Shared_memory_(interprocess_communication)" title="Shared memory (interprocess communication)">shared memory</a> system, in which the memory is not physically distributed. A system that does not have this property is known as a <a href="/wiki/Non-uniform_memory_access" title="Non-uniform memory access">non-uniform memory access</a> (NUMA) architecture. Distributed memory systems have non-uniform memory access.\n</p>, <p>Computer systems make use of <a href="/wiki/CPU_cache" title="CPU cache">caches</a>\xe2\x80\x94small and fast memories located close to the processor which store temporary copies of memory values (nearby in both the physical and logical sense). Parallel computer systems have difficulties with caches that may store the same value in more than one location, with the possibility of incorrect program execution. These computers require a <a class="mw-redirect" href="/wiki/Cache_coherency" title="Cache coherency">cache coherency</a> system, which keeps track of cached values and strategically purges them, thus ensuring correct program execution. <a class="mw-redirect" href="/wiki/Bus_sniffing" title="Bus sniffing">Bus snooping</a> is one of the most common methods for keeping track of which values are being accessed (and thus should be purged). Designing large, high-performance cache coherence systems is a very difficult problem in computer architecture. As a result, shared memory computer architectures do not scale as well as distributed memory systems do.<sup class="reference" id="cite_ref-PH713_37-1"><a href="#cite_note-PH713-37">[37]</a></sup>\n</p>, <p>Processor\xe2\x80\x93processor and processor\xe2\x80\x93memory communication can be implemented in hardware in several ways, including via shared (either multiported or <a href="/wiki/Multiplexing" title="Multiplexing">multiplexed</a>) memory, a <a href="/wiki/Crossbar_switch" title="Crossbar switch">crossbar switch</a>, a shared <a href="/wiki/Bus_(computing)" title="Bus (computing)">bus</a> or an interconnect network of a myriad of <a href="/wiki/Network_topology" title="Network topology">topologies</a> including <a href="/wiki/Star_network" title="Star network">star</a>, <a href="/wiki/Ring_network" title="Ring network">ring</a>, <a href="/wiki/Tree_(graph_theory)" title="Tree (graph theory)">tree</a>, <a href="/wiki/Hypercube_graph" title="Hypercube graph">hypercube</a>, fat hypercube (a hypercube with more than one processor at a node), or <a href="/wiki/Mesh_networking" title="Mesh networking">n-dimensional mesh</a>.\n</p>, <p>Parallel computers based on interconnected networks need to have some kind of <a href="/wiki/Routing" title="Routing">routing</a> to enable the passing of messages between nodes that are not directly connected. The medium used for communication between the processors is likely to be hierarchical in large multiprocessor machines.\n</p>, <p>Parallel computers can be roughly classified according to the level at which the hardware supports parallelism. This classification is broadly analogous to the distance between basic computing nodes. These are not mutually exclusive; for example, clusters of symmetric multiprocessors are relatively common.\n</p>, <p>A multi-core processor is a processor that includes multiple <a href="/wiki/Central_processing_unit" title="Central processing unit">processing units</a> (called "cores") on the same chip. This processor differs from a <a class="mw-redirect" href="/wiki/Superscalar" title="Superscalar">superscalar</a> processor, which includes multiple <a href="/wiki/Execution_unit" title="Execution unit">execution units</a> and can issue multiple instructions per clock cycle from one instruction stream (thread); in contrast, a multi-core processor can issue multiple instructions per clock cycle from multiple instruction streams. <a href="/wiki/IBM" title="IBM">IBM</a>\'s <a href="/wiki/Cell_(microprocessor)" title="Cell (microprocessor)">Cell microprocessor</a>, designed for use in the <a href="/wiki/Sony" title="Sony">Sony</a> <a href="/wiki/PlayStation_3" title="PlayStation 3">PlayStation 3</a>, is a prominent multi-core processor. Each core in a multi-core processor can potentially be superscalar as well\xe2\x80\x94that is, on every clock cycle, each core can issue multiple instructions from one thread.\n</p>, <p><a href="/wiki/Instruction_pipelining" title="Instruction pipelining">Instruction pipelining</a> (of which Intel\'s <a class="mw-redirect" href="/wiki/Hyper-Threading" title="Hyper-Threading">Hyper-Threading</a> is the best known) was an early form of pseudo-multi-coreism. A processor capable of concurrent multithreading includes multiple execution units in the same processing unit\xe2\x80\x94that is it has a superscalar architecture\xe2\x80\x94and can issue multiple instructions per clock cycle from <i>multiple</i> threads. <a href="/wiki/Temporal_multithreading" title="Temporal multithreading">Temporal multithreading</a> on the other hand includes a single execution unit in the same processing unit and can issue one instruction at a time from <i>multiple</i> threads.\n</p>, <p>A symmetric multiprocessor (SMP) is a computer system with multiple identical processors that share memory and connect via a bus.<sup class="reference" id="cite_ref-HP549_38-0"><a href="#cite_note-HP549-38">[38]</a></sup> <a href="/wiki/Bus_contention" title="Bus contention">Bus contention</a> prevents bus architectures from scaling. As a result, SMPs generally do not comprise more than 32 processors.<sup class="reference" id="cite_ref-39"><a href="#cite_note-39">[39]</a></sup> Because of the small size of the processors and the significant reduction in the requirements for bus bandwidth achieved by large caches, such symmetric multiprocessors are extremely cost-effective, provided that a sufficient amount of memory bandwidth exists.<sup class="reference" id="cite_ref-HP549_38-1"><a href="#cite_note-HP549-38">[38]</a></sup>\n</p>, <p>A distributed computer (also known as a distributed memory multiprocessor) is a distributed memory computer system in which the processing elements are connected by a network. Distributed computers are highly scalable. The terms "<a href="/wiki/Concurrent_computing" title="Concurrent computing">concurrent computing</a>", "parallel computing", and "distributed computing" have a lot of overlap, and no clear distinction exists between them.<sup class="reference" id="cite_ref-40"><a href="#cite_note-40">[40]</a></sup> The same system may be characterized both as "parallel" and "distributed"; the processors in a typical distributed system run concurrently in parallel.<sup class="reference" id="cite_ref-41"><a href="#cite_note-41">[41]</a></sup>\n</p>, <p>A cluster is a group of loosely coupled computers that work together closely, so that in some respects they can be regarded as a single computer.<sup class="reference" id="cite_ref-42"><a href="#cite_note-42">[42]</a></sup> Clusters are composed of multiple standalone machines connected by a network. While machines in a cluster do not have to be symmetric, <a href="/wiki/Load_balancing_(computing)" title="Load balancing (computing)">load balancing</a> is more difficult if they are not. The most common type of cluster is the <a class="mw-redirect" href="/wiki/Beowulf_(computing)" title="Beowulf (computing)">Beowulf cluster</a>, which is a cluster implemented on multiple identical <a href="/wiki/Commercial_off-the-shelf" title="Commercial off-the-shelf">commercial off-the-shelf</a> computers connected with a <a class="mw-redirect" href="/wiki/TCP/IP" title="TCP/IP">TCP/IP</a> <a href="/wiki/Ethernet" title="Ethernet">Ethernet</a> <a href="/wiki/Local_area_network" title="Local area network">local area network</a>.<sup class="reference" id="cite_ref-43"><a href="#cite_note-43">[43]</a></sup> Beowulf technology was originally developed by <a href="/wiki/Thomas_Sterling_(computing)" title="Thomas Sterling (computing)">Thomas Sterling</a> and <a href="/wiki/Donald_Becker" title="Donald Becker">Donald Becker</a>. 87% of all <a href="/wiki/TOP500" title="TOP500">Top500</a> supercomputers are clusters.<sup class="reference" id="cite_ref-44"><a href="#cite_note-44">[44]</a></sup> The remaining are Massively Parallel Processors, explained below.\n</p>, <p>Because grid computing systems (described below) can easily handle embarrassingly parallel problems, modern clusters are typically designed to handle more difficult problems\xe2\x80\x94problems that require nodes to share intermediate results with each other more often. This requires a high bandwidth and, more importantly, a low-<a href="/wiki/Latency_(engineering)" title="Latency (engineering)">latency</a> interconnection network. Many historic and current supercomputers use customized high-performance network hardware specifically designed for cluster computing, such as the Cray Gemini network.<sup class="reference" id="cite_ref-45"><a href="#cite_note-45">[45]</a></sup> As of 2014, most current supercomputers use some off-the-shelf standard network hardware, often <a href="/wiki/Myrinet" title="Myrinet">Myrinet</a>, <a href="/wiki/InfiniBand" title="InfiniBand">InfiniBand</a>, or <a href="/wiki/Gigabit_Ethernet" title="Gigabit Ethernet">Gigabit Ethernet</a>.\n</p>, <p>A massively parallel processor (MPP) is a single computer with many networked processors. MPPs have many of the same characteristics as clusters, but MPPs have specialized interconnect networks (whereas clusters use commodity hardware for networking). MPPs also tend to be larger than clusters, typically having "far more" than 100 processors.<sup class="reference" id="cite_ref-46"><a href="#cite_note-46">[46]</a></sup> In an MPP, "each CPU contains its own memory and copy of the operating system and application. Each subsystem communicates with the others via a high-speed interconnect."<sup class="reference" id="cite_ref-47"><a href="#cite_note-47">[47]</a></sup>\n</p>, <p><a href="/wiki/IBM" title="IBM">IBM</a>\'s <a href="/wiki/Blue_Gene" title="Blue Gene">Blue Gene/L</a>, the fifth fastest <a href="/wiki/Supercomputer" title="Supercomputer">supercomputer</a> in the world according to the June 2009 <a href="/wiki/TOP500" title="TOP500">TOP500</a> ranking, is an MPP.\n</p>, <p>Grid computing is the most distributed form of parallel computing. It makes use of computers communicating over the <a href="/wiki/Internet" title="Internet">Internet</a> to work on a given problem. Because of the low bandwidth and extremely high latency available on the Internet, distributed computing typically deals only with <a href="/wiki/Embarrassingly_parallel" title="Embarrassingly parallel">embarrassingly parallel</a> problems. <a href="/wiki/List_of_distributed_computing_projects" title="List of distributed computing projects">Many distributed computing applications</a> have been created, of which <a href="/wiki/SETI@home" title="SETI@home">SETI@home</a> and <a href="/wiki/Folding@home" title="Folding@home">Folding@home</a> are the best-known examples.<sup class="reference" id="cite_ref-48"><a href="#cite_note-48">[48]</a></sup>\n</p>, <p>Most grid computing applications use <a href="/wiki/Middleware" title="Middleware">middleware</a> (software that sits between the operating system and the application to manage network resources and standardize the software interface). The most common distributed computing middleware is the <a href="/wiki/Berkeley_Open_Infrastructure_for_Network_Computing" title="Berkeley Open Infrastructure for Network Computing">Berkeley Open Infrastructure for Network Computing</a> (BOINC). Often, distributed computing software makes use of "spare cycles", performing computations at times when a computer is idling.\n</p>, <p>Within parallel computing, there are specialized parallel devices that remain niche areas of interest. While not <a class="mw-redirect" href="/wiki/Domain-specific_programming_language" title="Domain-specific programming language">domain-specific</a>, they tend to be applicable to only a few classes of parallel problems.\n</p>, <p><a href="/wiki/Reconfigurable_computing" title="Reconfigurable computing">Reconfigurable computing</a> is the use of a <a href="/wiki/Field-programmable_gate_array" title="Field-programmable gate array">field-programmable gate array</a> (FPGA) as a co-processor to a general-purpose computer. An FPGA is, in essence, a computer chip that can rewire itself for a given task.\n</p>, <p>FPGAs can be programmed with <a href="/wiki/Hardware_description_language" title="Hardware description language">hardware description languages</a> such as <a href="/wiki/VHDL" title="VHDL">VHDL</a> or <a href="/wiki/Verilog" title="Verilog">Verilog</a>. However, programming in these languages can be tedious. Several vendors have created <a href="/wiki/C_to_HDL" title="C to HDL">C to HDL</a> languages that attempt to emulate the syntax and semantics of the <a class="mw-redirect" href="/wiki/C_programming_language" title="C programming language">C programming language</a>, with which most programmers are familiar. The best known C to HDL languages are <a href="/wiki/Mitrionics" title="Mitrionics">Mitrion-C</a>, <a href="/wiki/Impulse_C" title="Impulse C">Impulse C</a>, <a class="new" href="/w/index.php?title=DIME-C&amp;action=edit&amp;redlink=1" title="DIME-C (page does not exist)">DIME-C</a>, and <a href="/wiki/Handel-C" title="Handel-C">Handel-C</a>. Specific subsets of <a href="/wiki/SystemC" title="SystemC">SystemC</a> based on C++ can also be used for this purpose.\n</p>, <p>AMD\'s decision to open its <a href="/wiki/HyperTransport" title="HyperTransport">HyperTransport</a> technology to third-party vendors has become the enabling technology for high-performance reconfigurable computing.<sup class="reference" id="cite_ref-DAmour_49-0"><a href="#cite_note-DAmour-49">[49]</a></sup> According to Michael R. D\'Amour, Chief Operating Officer of <a class="new" href="/w/index.php?title=DRC_Computer_Corporation&amp;action=edit&amp;redlink=1" title="DRC Computer Corporation (page does not exist)">DRC Computer Corporation</a>, "when we first walked into AMD, they called us \'the <a href="/wiki/CPU_socket" title="CPU socket">socket</a> stealers.\' Now they call us their partners."<sup class="reference" id="cite_ref-DAmour_49-1"><a href="#cite_note-DAmour-49">[49]</a></sup>\n</p>, <p>General-purpose computing on <a href="/wiki/Graphics_processing_unit" title="Graphics processing unit">graphics processing units</a> (GPGPU) is a fairly recent trend in computer engineering research. GPUs are co-processors that have been heavily optimized for <a href="/wiki/Computer_graphics" title="Computer graphics">computer graphics</a> processing.<sup class="reference" id="cite_ref-50"><a href="#cite_note-50">[50]</a></sup> Computer graphics processing is a field dominated by data parallel operations\xe2\x80\x94particularly <a href="/wiki/Linear_algebra" title="Linear algebra">linear algebra</a> <a href="/wiki/Matrix_(mathematics)" title="Matrix (mathematics)">matrix</a> operations.\n</p>, <p>In the early days, GPGPU programs used the normal graphics APIs for executing programs. However, several new programming languages and platforms have been built to do general purpose computation on GPUs with both <a href="/wiki/Nvidia" title="Nvidia">Nvidia</a> and <a class="mw-redirect" href="/wiki/AMD" title="AMD">AMD</a> releasing programming environments with <a href="/wiki/CUDA" title="CUDA">CUDA</a> and <a href="/wiki/AMD_FireStream#Software_Development_Kit" title="AMD FireStream">Stream SDK</a> respectively. Other GPU programming languages include <a href="/wiki/BrookGPU" title="BrookGPU">BrookGPU</a>, <a href="/wiki/PeakStream" title="PeakStream">PeakStream</a>, and <a href="/wiki/RapidMind" title="RapidMind">RapidMind</a>. Nvidia has also released specific products for computation in their <a href="/wiki/Nvidia_Tesla" title="Nvidia Tesla">Tesla series</a>. The technology consortium Khronos Group has released the <a href="/wiki/OpenCL" title="OpenCL">OpenCL</a> specification, which is a framework for writing programs that execute across platforms consisting of CPUs and GPUs. <a class="mw-redirect" href="/wiki/AMD" title="AMD">AMD</a>, <a href="/wiki/Apple_Inc." title="Apple Inc.">Apple</a>, <a href="/wiki/Intel" title="Intel">Intel</a>, <a href="/wiki/Nvidia" title="Nvidia">Nvidia</a> and others are supporting <a href="/wiki/OpenCL" title="OpenCL">OpenCL</a>.\n</p>, <p>Several <a href="/wiki/Application-specific_integrated_circuit" title="Application-specific integrated circuit">application-specific integrated circuit</a> (ASIC) approaches have been devised for dealing with parallel applications.<sup class="reference" id="cite_ref-51"><a href="#cite_note-51">[51]</a></sup><sup class="reference" id="cite_ref-52"><a href="#cite_note-52">[52]</a></sup><sup class="reference" id="cite_ref-53"><a href="#cite_note-53">[53]</a></sup>\n</p>, <p>Because an ASIC is (by definition) specific to a given application, it can be fully optimized for that application. As a result, for a given application, an ASIC tends to outperform a general-purpose computer. However, ASICs are created by <a href="/wiki/Photolithography" title="Photolithography">UV photolithography</a>. This process requires a mask set, which can be extremely expensive. A mask set can cost over a million US dollars.<sup class="reference" id="cite_ref-54"><a href="#cite_note-54">[54]</a></sup> (The smaller the transistors required for the chip, the more expensive the mask will be.) Meanwhile, performance increases in general-purpose computing over time (as described by <a href="/wiki/Moore%27s_law" title="Moore's law">Moore\'s law</a>) tend to wipe out these gains in only one or two chip generations.<sup class="reference" id="cite_ref-DAmour_49-2"><a href="#cite_note-DAmour-49">[49]</a></sup> High initial cost, and the tendency to be overtaken by Moore\'s-law-driven general-purpose computing, has rendered ASICs unfeasible for most parallel computing applications. However, some have been built. One example is the PFLOPS <a href="/wiki/RIKEN_MDGRAPE-3" title="RIKEN MDGRAPE-3">RIKEN MDGRAPE-3</a> machine which uses custom ASICs for <a href="/wiki/Molecular_dynamics" title="Molecular dynamics">molecular dynamics</a> simulation.\n</p>, <p>A vector processor is a CPU or computer system that can execute the same instruction on large sets of data. Vector processors have high-level operations that work on linear arrays of numbers or vectors. An example vector operation is <i>A</i> = <i>B</i> \xc3\x97 <i>C</i>, where <i>A</i>, <i>B</i>, and <i>C</i> are each 64-element vectors of 64-bit <a class="mw-redirect" href="/wiki/Floating-point" title="Floating-point">floating-point</a> numbers.<sup class="reference" id="cite_ref-PH751_55-0"><a href="#cite_note-PH751-55">[55]</a></sup> They are closely related to Flynn\'s SIMD classification.<sup class="reference" id="cite_ref-PH751_55-1"><a href="#cite_note-PH751-55">[55]</a></sup>\n</p>, <p><a href="/wiki/Cray" title="Cray">Cray</a> computers became famous for their vector-processing computers in the 1970s and 1980s. However, vector processors\xe2\x80\x94both as CPUs and as full computer systems\xe2\x80\x94have generally disappeared. Modern <a class="mw-redirect" href="/wiki/Instruction_set" title="Instruction set">processor instruction sets</a> do include some vector processing instructions, such as with <a href="/wiki/Freescale_Semiconductor" title="Freescale Semiconductor">Freescale Semiconductor</a>\'s <a href="/wiki/AltiVec" title="AltiVec">AltiVec</a> and <a href="/wiki/Intel" title="Intel">Intel</a>\'s <a href="/wiki/Streaming_SIMD_Extensions" title="Streaming SIMD Extensions">Streaming SIMD Extensions</a> (SSE).\n</p>, <p><a href="/wiki/List_of_concurrent_and_parallel_programming_languages" title="List of concurrent and parallel programming languages">Concurrent programming languages</a>, <a href="/wiki/Library_(computing)" title="Library (computing)">libraries</a>, <a href="/wiki/Application_programming_interface" title="Application programming interface">APIs</a>, and <a href="/wiki/Parallel_programming_model" title="Parallel programming model">parallel programming models</a> (such as <a href="/wiki/Algorithmic_skeleton" title="Algorithmic skeleton">algorithmic skeletons</a>) have been created for programming parallel computers. These can generally be divided into classes based on the assumptions they make about the underlying memory architecture\xe2\x80\x94shared memory, distributed memory, or shared distributed memory. Shared memory programming languages communicate by manipulating shared memory variables. Distributed memory uses <a href="/wiki/Message_passing" title="Message passing">message passing</a>. <a href="/wiki/POSIX_Threads" title="POSIX Threads">POSIX Threads</a> and <a href="/wiki/OpenMP" title="OpenMP">OpenMP</a> are two of the most widely used shared memory APIs, whereas <a href="/wiki/Message_Passing_Interface" title="Message Passing Interface">Message Passing Interface</a> (MPI) is the most widely used message-passing system API.<sup class="reference" id="cite_ref-56"><a href="#cite_note-56">[56]</a></sup> One concept used in programming parallel programs is the <a href="/wiki/Futures_and_promises" title="Futures and promises">future concept</a>, where one part of a program promises to deliver a required datum to another part of a program at some future time.\n</p>, <p><a class="new" href="/w/index.php?title=CAPS_entreprise&amp;action=edit&amp;redlink=1" title="CAPS entreprise (page does not exist)">CAPS entreprise</a> and <a class="new" href="/w/index.php?title=Pathscale&amp;action=edit&amp;redlink=1" title="Pathscale (page does not exist)">Pathscale</a> are also coordinating their effort to make <a class="new" href="/w/index.php?title=Hybrid_multi-core_parallel_programming&amp;action=edit&amp;redlink=1" title="Hybrid multi-core parallel programming (page does not exist)">hybrid multi-core parallel programming</a> (HMPP) directives an open standard called <a href="/wiki/OpenHMPP" title="OpenHMPP">OpenHMPP</a>. The OpenHMPP directive-based programming model offers a syntax to efficiently offload computations on hardware accelerators and to optimize data movement to/from the hardware memory. OpenHMPP directives describe remote procedure call (RPC) on an accelerator device (e.g. GPU) or more generally a set of cores. The directives annotate <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> or <a href="/wiki/Fortran" title="Fortran">Fortran</a> codes to describe two sets of functionalities: the offloading of procedures (denoted codelets) onto a remote device and the optimization of data transfers between the CPU main memory and the accelerator memory.\n</p>, <p>The rise of consumer GPUs has led to support for <a href="/wiki/Compute_kernel" title="Compute kernel">compute kernels</a>, either in graphics APIs (referred to as <a class="mw-redirect" href="/wiki/Compute_shader" title="Compute shader">compute shaders</a>), in dedicated APIs (such as <a href="/wiki/OpenCL" title="OpenCL">OpenCL</a>), or in other language extensions.\n</p>, <p>Automatic parallelization of a sequential program by a <a href="/wiki/Compiler" title="Compiler">compiler</a> is the "holy grail" of parallel computing, especially with the aforementioned limit of processor frequency. Despite decades of work by compiler researchers, automatic parallelization has had only limited success.<sup class="reference" id="cite_ref-57"><a href="#cite_note-57">[57]</a></sup>\n</p>, <p>Mainstream parallel programming languages remain either <a href="/wiki/Explicit_parallelism" title="Explicit parallelism">explicitly parallel</a> or (at best) <a href="/wiki/Implicit_parallelism" title="Implicit parallelism">partially implicit</a>, in which a programmer gives the compiler <a href="/wiki/Directive_(programming)" title="Directive (programming)">directives</a> for parallelization. A few fully implicit parallel programming languages exist\xe2\x80\x94<a href="/wiki/SISAL" title="SISAL">SISAL</a>, Parallel <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, <a href="/wiki/SequenceL" title="SequenceL">SequenceL</a>, <a href="/wiki/System_C" title="System C">System C</a> (for <a class="mw-redirect" href="/wiki/FPGA" title="FPGA">FPGAs</a>), <a class="new" href="/w/index.php?title=Mitrion-C&amp;action=edit&amp;redlink=1" title="Mitrion-C (page does not exist)">Mitrion-C</a>, <a href="/wiki/VHDL" title="VHDL">VHDL</a>, and <a href="/wiki/Verilog" title="Verilog">Verilog</a>.\n</p>, <p>As a computer system grows in complexity, the <a href="/wiki/Mean_time_between_failures" title="Mean time between failures">mean time between failures</a> usually decreases. <a href="/wiki/Application_checkpointing" title="Application checkpointing">Application checkpointing</a> is a technique whereby the computer system takes a "snapshot" of the application\xe2\x80\x94a record of all current resource allocations and variable states, akin to a <a href="/wiki/Core_dump" title="Core dump">core dump</a>\xe2\x80\x94; this information can be used to restore the program if the computer should fail. Application checkpointing means that the program has to restart from only its last checkpoint rather than the beginning. While checkpointing provides benefits in a variety of situations, it is especially useful in highly parallel systems with a large number of processors used in <a class="mw-redirect" href="/wiki/High_performance_computing" title="High performance computing">high performance computing</a>.<sup class="reference" id="cite_ref-58"><a href="#cite_note-58">[58]</a></sup>\n</p>, <p>As parallel computers become larger and faster, we are now able to solve problems that had previously taken too long to run. Fields as varied as <a href="/wiki/Bioinformatics" title="Bioinformatics">bioinformatics</a> (for <a href="/wiki/Protein_folding" title="Protein folding">protein folding</a> and <a href="/wiki/Sequence_analysis" title="Sequence analysis">sequence analysis</a>) and economics (for <a href="/wiki/Mathematical_finance" title="Mathematical finance">mathematical finance</a>) have taken advantage of parallel computing. Common types of problems in parallel computing applications include:<sup class="reference" id="cite_ref-59"><a href="#cite_note-59">[59]</a></sup>\n</p>, <p>Parallel computing can also be applied to the design of <a href="/wiki/Fault-tolerant_computer_system" title="Fault-tolerant computer system">fault-tolerant computer systems</a>, particularly via <a href="/wiki/Lockstep_(computing)" title="Lockstep (computing)">lockstep</a> systems performing the same operation in parallel. This provides <a href="/wiki/Redundancy_(engineering)" title="Redundancy (engineering)">redundancy</a> in case one component fails, and also allows automatic <a class="mw-redirect" href="/wiki/Error_detection" title="Error detection">error detection</a> and <a class="mw-redirect" href="/wiki/Error_correction" title="Error correction">error correction</a> if the results differ. These methods can be used to help prevent single-event upsets caused by transient errors.<sup class="reference" id="cite_ref-60"><a href="#cite_note-60">[60]</a></sup> Although additional measures may be required in embedded or specialized systems, this method can provide a cost effective approach to achieve n-modular redundancy in commercial off-the-shelf systems.\n</p>, <p>The origins of true (MIMD) parallelism go back to <a href="/wiki/Luigi_Federico_Menabrea" title="Luigi Federico Menabrea">Luigi Federico Menabrea</a> and his <i>Sketch of the <a class="mw-redirect" href="/wiki/Analytic_Engine" title="Analytic Engine">Analytic Engine</a> Invented by <a href="/wiki/Charles_Babbage" title="Charles Babbage">Charles Babbage</a></i>.<sup class="reference" id="cite_ref-62"><a href="#cite_note-62">[62]</a></sup><sup class="reference" id="cite_ref-PH753_63-0"><a href="#cite_note-PH753-63">[63]</a></sup><sup class="reference" id="cite_ref-64"><a href="#cite_note-64">[64]</a></sup>\n</p>, <p>In April 1958, S. Gill (Ferranti) discussed parallel programming and the need for branching and waiting.<sup class="reference" id="cite_ref-65"><a href="#cite_note-65">[65]</a></sup> Also in 1958, IBM researchers <a href="/wiki/John_Cocke" title="John Cocke">John Cocke</a> and <a href="/wiki/Daniel_Slotnick" title="Daniel Slotnick">Daniel Slotnick</a> discussed the use of parallelism in numerical calculations for the first time.<sup class="reference" id="cite_ref-G_Wilson_66-0"><a href="#cite_note-G_Wilson-66">[66]</a></sup> <a href="/wiki/Burroughs_Corporation" title="Burroughs Corporation">Burroughs Corporation</a> introduced the D825 in 1962, a four-processor computer that accessed up to 16 memory modules through a <a href="/wiki/Crossbar_switch" title="Crossbar switch">crossbar switch</a>.<sup class="reference" id="cite_ref-67"><a href="#cite_note-67">[67]</a></sup> In 1967, Amdahl and Slotnick published a debate about the feasibility of parallel processing at American Federation of Information Processing Societies Conference.<sup class="reference" id="cite_ref-G_Wilson_66-1"><a href="#cite_note-G_Wilson-66">[66]</a></sup> It was during this debate that <a href="/wiki/Amdahl%27s_law" title="Amdahl's law">Amdahl\'s law</a> was coined to define the limit of speed-up due to parallelism.\n</p>, <p>In 1969, <a href="/wiki/Honeywell" title="Honeywell">Honeywell</a> introduced its first <a href="/wiki/Multics" title="Multics">Multics</a> system, a symmetric multiprocessor system capable of running up to eight processors in parallel.<sup class="reference" id="cite_ref-G_Wilson_66-2"><a href="#cite_note-G_Wilson-66">[66]</a></sup> <a href="/wiki/C.mmp" title="C.mmp">C.mmp</a>, a multi-processor project at <a href="/wiki/Carnegie_Mellon_University" title="Carnegie Mellon University">Carnegie Mellon University</a> in the 1970s, was among the first multiprocessors with more than a few processors. The first bus-connected multiprocessor with snooping caches was the <a class="new" href="/w/index.php?title=Synapse_N%2B1&amp;action=edit&amp;redlink=1" title="Synapse N+1 (page does not exist)">Synapse N+1</a> in 1984.<sup class="reference" id="cite_ref-PH753_63-1"><a href="#cite_note-PH753-63">[63]</a></sup>\n</p>, <p>SIMD parallel computers can be traced back to the 1970s. The motivation behind early SIMD computers was to amortize the <a href="/wiki/Propagation_delay" title="Propagation delay">gate delay</a> of the processor\'s <a href="/wiki/Control_unit" title="Control unit">control unit</a> over multiple instructions.<sup class="reference" id="cite_ref-68"><a href="#cite_note-68">[68]</a></sup> In 1964, Slotnick had proposed building a massively parallel computer for the <a href="/wiki/Lawrence_Livermore_National_Laboratory" title="Lawrence Livermore National Laboratory">Lawrence Livermore National Laboratory</a>.<sup class="reference" id="cite_ref-G_Wilson_66-3"><a href="#cite_note-G_Wilson-66">[66]</a></sup> His design was funded by the <a class="mw-redirect" href="/wiki/US_Air_Force" title="US Air Force">US Air Force</a>, which was the earliest SIMD parallel-computing effort, <a href="/wiki/ILLIAC_IV" title="ILLIAC IV">ILLIAC IV</a>.<sup class="reference" id="cite_ref-G_Wilson_66-4"><a href="#cite_note-G_Wilson-66">[66]</a></sup> The key to its design was a fairly high parallelism, with up to 256 processors, which allowed the machine to work on large datasets in what would later be known as <a href="/wiki/Vector_processor" title="Vector processor">vector processing</a>. However, ILLIAC IV was called "the most infamous of supercomputers", because the project was only one-fourth completed, but took 11 years and cost almost four times the original estimate.<sup class="reference" id="cite_ref-infamous_61-1"><a href="#cite_note-infamous-61">[61]</a></sup> When it was finally ready to run its first real application in 1976, it was outperformed by existing commercial supercomputers such as the <a href="/wiki/Cray-1" title="Cray-1">Cray-1</a>.\n</p>, <p>In the early 1970s, at the <a href="/wiki/MIT_Computer_Science_and_Artificial_Intelligence_Laboratory" title="MIT Computer Science and Artificial Intelligence Laboratory">MIT Computer Science and Artificial Intelligence Laboratory</a>, <a href="/wiki/Marvin_Minsky" title="Marvin Minsky">Marvin Minsky</a> and <a href="/wiki/Seymour_Papert" title="Seymour Papert">Seymour Papert</a> started developing the <i><a href="/wiki/Society_of_Mind" title="Society of Mind">Society of Mind</a></i> theory, which views the biological brain as <a href="/wiki/Massively_parallel" title="Massively parallel">massively parallel computer</a>. In 1986, Minsky published <i>The Society of Mind</i>, which claims that \xe2\x80\x9cmind is formed from many little agents, each mindless by itself\xe2\x80\x9d.<sup class="reference" id="cite_ref-69"><a href="#cite_note-69">[69]</a></sup> The theory attempts to explain how what we call intelligence could be a product of the interaction of non-intelligent parts. Minsky says that the biggest source of ideas about the theory came from his work in trying to create a machine that uses a robotic arm, a video camera, and a computer to build with children\'s blocks.<sup class="reference" id="cite_ref-70"><a href="#cite_note-70">[70]</a></sup>\n</p>, <p>Similar models (which also view biological brain as massively parallel computer, i.e., the brain is made up of a constellation of independent or semi-independent agents) were also described by:\n</p>, <p><br/>\n</p>, <p class="mw-empty-elt">\n</p>]