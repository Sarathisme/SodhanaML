Softwaredevelopmentistheprocessofconceiving,specifying,designing,programming,documenting,testing,andbugfixinginvolvedincreatingandmaintainingapplications,frameworks,orothersoftwarecomponents.Softwaredevelopmentisaprocessofwritingandmaintainingthesourcecode,butinabroadersense,itincludesallthatisinvolvedbetweentheconceptionofthedesiredsoftwarethroughtothefinalmanifestationofthesoftware,sometimesinaplannedandstructuredprocess.[1]Therefore,softwaredevelopmentmayincluderesearch,newdevelopment,prototyping,modification,reuse,re-engineering,maintenance,oranyotheractivitiesthatresultinsoftwareproducts.[2]\nSoftwarecanbedevelopedforavarietyofpurposes,thethreemostcommonbeingtomeetspecificneedsofaspecificclient/business(thecasewithcustomsoftware),tomeetaperceivedneedofsomesetofpotentialusers(thecasewithcommercialandopensourcesoftware),orforpersonaluse(e.g.ascientistmaywritesoftwaretoautomateamundanetask).Embeddedsoftwaredevelopment,thatis,thedevelopmentofembeddedsoftware,suchasusedforcontrollingconsumerproducts,requiresthedevelopmentprocesstobeintegratedwiththedevelopmentofthecontrolledphysicalproduct.Systemsoftwareunderliesapplicationsandtheprogrammingprocessitself,andisoftendevelopedseparately.\nTheneedforbetterqualitycontrolofthesoftwaredevelopmentprocesshasgivenrisetothedisciplineofsoftwareengineering,whichaimstoapplythesystematicapproachexemplifiedintheengineeringparadigmtotheprocessofsoftwaredevelopment.\nTherearemanyapproachestosoftwareprojectmanagement,knownassoftwaredevelopmentlifecyclemodels,methodologies,processes,ormodels.Thewaterfallmodelisatraditionalversion,contrastedwiththemorerecentinnovationofagilesoftwaredevelopment.\nAsoftwaredevelopmentprocess(alsoknownasasoftwaredevelopmentmethodology,model,orlifecycle)isaframeworkthatisusedtostructure,plan,andcontroltheprocessofdevelopinginformationsystems.Awidevarietyofsuchframeworkshasevolvedovertheyears,eachwithitsownrecognizedstrengthsandweaknesses.Thereareseveraldifferentapproachestosoftwaredevelopment:sometakeamorestructured,engineering-basedapproachtodevelopingbusinesssolutions,whereasothersmaytakeamoreincrementalapproach,wheresoftwareevolvesasitisdevelopedpiece-by-piece.Onesystemdevelopmentmethodologyisnotnecessarilysuitableforusebyallprojects.Eachoftheavailablemethodologiesisbestsuitedtospecifickindsofprojects,basedonvarioustechnical,organizational,projectandteamconsiderations.\nMostmethodologiessharesomecombinationofthefollowingstagesofsoftwaredevelopment:\nThesestagesareoftenreferredtocollectivelyasthesoftwaredevelopmentlife-cycle,orSDLC.Differentapproachestosoftwaredevelopmentmaycarryoutthesestagesindifferentorders,ordevotemoreorlesstimetodifferentstages.Thelevelofdetailofthedocumentationproducedateachstageofsoftwaredevelopmentmayalsovary.Thesestagesmayalsobecarriedoutinturn(a\xe2\x80\x9cwaterfall\xe2\x80\x9dbasedapproach),ortheymayberepeatedovervariouscyclesoriterations(amore"extreme"approach).Themoreextremeapproachusuallyinvolveslesstimespentonplanninganddocumentation,andmoretimespentoncodinganddevelopmentofautomatedtests.More\xe2\x80\x9cextreme\xe2\x80\x9dapproachesalsopromotecontinuoustestingthroughoutthedevelopmentlife-cycle,aswellashavingaworking(orbug-free)productatalltimes.Morestructuredor\xe2\x80\x9cwaterfall\xe2\x80\x9dbasedapproachesattempttoassessthemajorityofrisksanddevelopadetailedplanforthesoftwarebeforeimplementation(coding)begins,andavoidsignificantdesignchangesandre-codinginlaterstagesofthesoftwaredevelopmentlife-cycleplanning.\nTherearesignificantadvantagesanddisadvantagestothevariousmethodologies,andthebestapproachtosolvingaproblemusingsoftwarewilloftendependonthetypeofproblem.Iftheproblemiswellunderstoodandasolutioncanbeeffectivelyplannedoutaheadoftime,themore"waterfall"basedapproachmayworkthebest.If,ontheotherhand,theproblemisunique(atleasttothedevelopmentteam)andthestructureofthesoftwaresolutioncannotbeeasilyenvisioned,thenamore"extreme"incrementalapproachmayworkbest.\nThesourcesofideasforsoftwareproductsareplentiful.Theseideascancomefrommarketresearchincludingthedemographicsofpotentialnewcustomers,existingcustomers,salesprospectswhorejectedtheproduct,otherinternalsoftwaredevelopmentstaff,oracreativethirdparty.Ideasforsoftwareproductsareusuallyfirstevaluatedbymarketingpersonnelforeconomicfeasibility,forfitwithexistingchannelsdistribution,forpossibleeffectsonexistingproductlines,requiredfeatures,andforfitwiththecompany\'smarketingobjectives.Inamarketingevaluationphase,thecostandtimeassumptionsbecomeevaluated.Adecisionisreachedearlyinthefirstphaseastowhether,basedonthemoredetailedinformationgeneratedbythemarketinganddevelopmentstaff,theprojectshouldbepursuedfurther.[3]\nInthebook"GreatSoftwareDebates",AlanM.Davisstatesinthechapter"Requirements",sub-chapter"TheMissingPieceofSoftwareDevelopment"\nStudentsofengineeringlearnengineeringandarerarelyexposedtofinanceormarketing.Studentsofmarketinglearnmarketingandarerarelyexposedtofinanceorengineering.Mostofusbecomespecialistsinjustonearea.Tocomplicatematters,fewofusmeetinterdisciplinarypeopleintheworkforce,sotherearefewrolestomimic.Yet,softwareproductplanningiscriticaltothedevelopmentsuccessandabsolutelyrequiresknowledgeofmultipledisciplines.[4]Becausesoftwaredevelopmentmayinvolvecompromisingorgoingbeyondwhatisrequiredbytheclient,asoftwaredevelopmentprojectmaystrayintolesstechnicalconcernssuchashumanresources,riskmanagement,intellectualproperty,budgeting,crisismanagement,etc.Theseprocessesmayalsocausetheroleofbusinessdevelopmenttooverlapwithsoftwaredevelopment.\nPlanningisanobjectiveofeachandeveryactivity,wherewewanttodiscoverthingsthatbelongtotheproject.\nAnimportanttaskincreatingasoftwareprogramisextractingtherequirementsorrequirementsanalysis.[5]Customerstypicallyhaveanabstractideaofwhattheywantasanendresultbutdonotknowwhatsoftwareshoulddo.Skilledandexperiencedsoftwareengineersrecognizeincomplete,ambiguous,orevencontradictoryrequirementsatthispoint.Frequentlydemonstratinglivecodemayhelpreducetheriskthattherequirementsareincorrect.\n"Althoughmucheffortisputintherequirementsphasetoensurethatrequirementsarecompleteandconsistent,rarelythatisthecase;leavingthesoftwaredesignphaseasthemostinfluentialonewhenitcomestominimizingtheeffectsofneworchangingrequirements.Requirementsvolatilityischallengingbecausetheyimpactfutureoralreadygoingdevelopmentefforts."[6]\nOncethegeneralrequirementsaregatheredfromtheclient,ananalysisofthescopeofthedevelopmentshouldbedeterminedandclearlystated.Thisisoftencalledascopedocument.\nOncetherequirementsareestablished,thedesignofthesoftwarecanbeestablishedinasoftwaredesigndocument.Thisinvolvesapreliminaryorhigh-leveldesignofthemainmoduleswithanoverallpicture(suchasablockdiagram)ofhowthepartsfittogether.Thelanguage,operatingsystem,andhardwarecomponentsshouldallbeknownatthistime.Thenadetailedorlow-leveldesigniscreated,perhapswithprototypingasproof-of-conceptortofirmuprequirements.\nImplementationisthepartoftheprocesswheresoftwareengineersactuallyprogramthecodefortheproject.\nSoftwaretestingisanintegralandimportantphaseofthesoftwaredevelopmentprocess.Thispartoftheprocessensuresthatdefectsarerecognizedassoonaspossible.Insomeprocesses,generallyknownastest-drivendevelopment,testsmaybedevelopedjustbeforeimplementationandserveasaguidefortheimplementation\'scorrectness.\nDocumentingtheinternaldesignofsoftwareforthepurposeoffuturemaintenanceandenhancementisdonethroughoutdevelopment.ThismayalsoincludethewritingofanAPI,beitexternalorinternal.Thesoftwareengineeringprocesschosenbythedevelopingteamwilldeterminehowmuchinternaldocumentation(ifany)isnecessary.Plan-drivenmodels(e.g.,Waterfall)generallyproducemoredocumentationthanAgilemodels.\nDeploymentstartsdirectlyafterthecodeisappropriatelytested,approvedforrelease,andsoldorotherwisedistributedintoaproductionenvironment.Thismayinvolveinstallation,customization(suchasbysettingparameterstothecustomer\'svalues),testing,andpossiblyanextendedperiodofevaluation.[citationneeded]\nSoftwaretrainingandsupportisimportant,assoftwareisonlyeffectiveifitisusedcorrectly.[citationneeded]\nMaintainingandenhancingsoftwaretocopewithnewlydiscoveredfaultsorrequirementscantakesubstantialtimeandeffort,asmissedrequirementsmayforceredesignofthesoftware.[citationneeded]\nAviewmodelisaframeworkthatprovidestheviewpointsonthesystemanditsenvironment,tobeusedinthesoftwaredevelopmentprocess.Itisagraphicalrepresentationoftheunderlyingsemanticsofaview.\nThepurposeofviewpointsandviewsistoenablehumanengineerstocomprehendverycomplexsystemsandtoorganizetheelementsoftheproblemandthesolutionarounddomainsofexpertise.Intheengineeringofphysicallyintensivesystems,viewpointsoftencorrespondtocapabilitiesandresponsibilitieswithintheengineeringorganization.[7]\nMostcomplexsystemspecificationsaresoextensivethatnooneindividualcanfullycomprehendallaspectsofthespecifications.Furthermore,weallhavedifferentinterestsinagivensystemanddifferentreasonsforexaminingthesystem\'sspecifications.Abusinessexecutivewillaskdifferentquestionsofasystemmake-upthanwouldasystemimplementer.Theconceptofviewpointsframework,therefore,istoprovideseparateviewpointsintothespecificationofagivencomplexsystem.Theseviewpointseachsatisfyanaudiencewithinterestinsomesetofaspectsofthesystem.Associatedwitheachviewpointisaviewpointlanguage\nthatoptimizesthevocabularyandpresentationfortheaudienceofthatviewpoint.\nGraphicalrepresentationofthecurrentstateofinformationprovidesaveryeffectivemeansforpresentinginformationtobothusersandsystemdevelopers.\nUsually,amodeliscreatedafterconductinganinterview,referredtoasbusinessanalysis.Theinterviewconsistsofafacilitatoraskingaseriesofquestionsdesignedtoextractrequiredinformationthatdescribesaprocess.Theintervieweriscalledafacilitatortoemphasizethatitistheparticipantswhoprovidetheinformation.Thefacilitatorshouldhavesomeknowledgeoftheprocessofinterest,butthisisnotasimportantashavingastructuredmethodologybywhichthequestionsareaskedoftheprocessexpert.Themethodologyis\nimportantbecauseusuallyateamoffacilitatorsiscollectinginformationacrossthefacilityandtheresultsoftheinformationfromalltheinterviewersmustfittogetheroncecompleted.[8]\nThemodelsaredevelopedasdefiningeitherthecurrentstateoftheprocess,inwhichcasethefinalproductiscalledthe"as-is"snapshotmodel,oracollectionofideasofwhattheprocessshouldcontain,resultingina"what-can-be"model.Generationofprocessanddatamodelscanbeusedtodetermineiftheexistingprocessesandinformationsystemsaresoundandonlyneedminormodificationsorenhancements,orifre-engineeringisrequiredasacorrectiveaction.Thecreationofbusinessmodelsismorethanawaytovieworautomateyourinformationprocess.Analysiscanbeusedtofundamentallyreshapethewayyourbusinessororganizationconductsitsoperations.[8]\nComputer-aidedsoftwareengineering(CASE),inthefieldsoftwareengineering,isthescientificapplicationofasetofsoftwaretoolsandmethodstothedevelopmentofsoftwarewhichresultsinhigh-quality,defect-free,andmaintainablesoftwareproducts.[9]Italsoreferstomethodsforthedevelopmentofinformationsystemstogetherwithautomatedtoolsthatcanbeusedinthesoftwaredevelopmentprocess.[10]Theterm"computer-aidedsoftwareengineering"(CASE)canrefertothesoftwareusedfortheautomateddevelopmentofsystemssoftware,i.e.,computercode.TheCASEfunctionsincludeanalysis,design,andprogramming.CASEtoolsautomatemethodsfordesigning,documenting,andproducingstructuredcomputercodeinthedesiredprogramminglanguage.[11]\nTwokeyideasofComputer-aidedSoftwareSystemEngineering(CASE)are:[12]\nTypicalCASEtoolsexistforconfigurationmanagement,datamodeling,modeltransformation,refactoring,sourcecodegeneration.\nAnintegrateddevelopmentenvironment(IDE)alsoknownasintegrateddesignenvironmentorintegrateddebuggingenvironmentisasoftwareapplicationthatprovidescomprehensivefacilitiestocomputerprogrammersforsoftwaredevelopment.AnIDEnormallyconsistsofa:\nIDEsaredesignedtomaximizeprogrammerproductivitybyprovidingtight-knitcomponentswithsimilaruserinterfaces.TypicallyanIDEisdedicatedtoaspecificprogramminglanguage,soastoprovideafeaturesetwhichmostcloselymatchestheprogrammingparadigmsofthelanguage.\nAmodelinglanguageisanyartificiallanguagethatcanbeusedtoexpressinformationorknowledgeorsystemsinastructurethatisdefinedbyaconsistentsetofrules.Therulesareusedforinterpretationofthemeaningofcomponentsinthestructure.Amodelinglanguagecanbegraphicalortextual.[13]Graphicalmodelinglanguagesuseadiagramtechniqueswithnamedsymbolsthatrepresentconceptsandlinesthatconnectthesymbolsandthatrepresentrelationshipsandvariousothergraphicalannotationtorepresentconstraints.Textualmodelinglanguagestypicallyusestandardisedkeywordsaccompaniedbyparameterstomakecomputer-interpretableexpressions.\nExamplesofgraphicalmodellinglanguagesinthefieldofsoftwareengineeringare:\nNotallmodelinglanguagesareexecutable,andforthosethatare,usingthemdoesn\'tnecessarilymeanthatprogrammersarenolongerneeded.Onthecontrary,executablemodelinglanguagesareintendedtoamplifytheproductivityofskilledprogrammers,sothattheycanaddressmoredifficultproblems,suchasparallelcomputinganddistributedsystems.\nAprogrammingparadigmisafundamentalstyleofcomputerprogramming,whichisnotgenerallydictatedbytheprojectmanagementmethodology(suchaswaterfalloragile).Paradigmsdifferintheconceptsandabstractionsusedtorepresenttheelementsofaprogram(suchasobjects,functions,variables,constraints)andthestepsthatcompriseacomputation(suchasassignations,evaluation,continuations,dataflows).Sometimestheconceptsassertedbytheparadigmareutilizedcooperativelyinhigh-levelsystemarchitecturedesign;inothercases,theprogrammingparadigm\'sscopeislimitedtotheinternalstructureofaparticularprogramormodule.\nAprogramminglanguagecansupportmultipleparadigms.Forexample,programswritteninC++orObjectPascalcanbepurelyprocedural,orpurelyobject-oriented,orcontainelementsofbothparadigms.Softwaredesignersandprogrammersdecidehowtousethoseparadigmelements.Inobject-orientedprogramming,programmerscanthinkofaprogramasacollectionofinteractingobjects,whileinfunctionalprogrammingaprogramcanbethoughtofasasequenceofstatelessfunctionevaluations.Whenprogrammingcomputersorsystemswithmanyprocessors,process-orientedprogrammingallowsprogrammerstothinkaboutapplicationsassetsofconcurrentprocessesactinguponlogicallyshareddatastructures.\nJustasdifferentgroupsinsoftwareengineeringadvocatedifferentmethodologies,differentprogramminglanguagesadvocatedifferentprogrammingparadigms.Somelanguagesaredesignedtosupportoneparadigm(Smalltalksupportsobject-orientedprogramming,Haskellsupportsfunctionalprogramming),whileotherprogramminglanguagessupportmultipleparadigms(suchasObjectPascal,C++,C#,VisualBasic,CommonLisp,Scheme,Python,Ruby,andOz).\nManyprogrammingparadigmsareaswellknownforwhatmethodstheyforbidasforwhattheyenable.Forinstance,purefunctionalprogrammingforbidsusingside-effects;structuredprogrammingforbidsusinggotostatements.Partlyforthisreason,newparadigmsareoftenregardedasdoctrinaireoroverlyrigidbythoseaccustomedtoearlierstyles.[citationneeded]Avoidingcertainmethodscanmakeiteasiertoprovetheoremsaboutaprogram\'scorrectness,orsimplytounderstanditsbehavior.\nExamplesofhigh-levelparadigmsinclude:\n