[<p>In <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a>, a <b>software development process</b> is the process of dividing <a href="/wiki/Software_development" title="Software development">software development</a> work into distinct phases to improve <a href="/wiki/Software_design" title="Software design">design</a>, <a href="/wiki/Software_product_management" title="Software product management">product management</a>, and <a href="/wiki/Software_project_management" title="Software project management">project management</a>.  It is also known as a <b>software development life cycle</b>.  The methodology may include the pre-definition of specific <a href="/wiki/Deliverable" title="Deliverable">deliverables</a> and artifacts that are created and completed by a project team to develop or maintain an application.<sup class="reference" id="cite_ref-CMS08_1-0"><a href="#cite_note-CMS08-1">[1]</a></sup>\n</p>, <p>Most modern development processes can be vaguely described as <a href="/wiki/Agile_software_development" title="Agile software development">agile</a>. Other methodologies include <a href="/wiki/Waterfall_model" title="Waterfall model">waterfall</a>, <a href="/wiki/Software_prototyping" title="Software prototyping">prototyping</a>, <a href="/wiki/Iterative_and_incremental_development" title="Iterative and incremental development">iterative and incremental development</a>, <a class="mw-redirect" href="/wiki/Spiral_development" title="Spiral development">spiral development</a>, <a href="/wiki/Rapid_application_development" title="Rapid application development">rapid application development</a>, and <a href="/wiki/Extreme_programming" title="Extreme programming">extreme programming</a>.\n</p>, <p>Some people consider a life-cycle "model" a more general term for a category of methodologies and a software development "process" a more specific term to refer to a specific process chosen by a specific organization. For example, there are many specific software development processes that fit the spiral life-cycle model. The field is often considered a subset of the <a href="/wiki/Systems_development_life_cycle" title="Systems development life cycle">systems development life cycle</a>.\n</p>, <p>The software development methodology (also known as SDM) framework didn\'t emerge until the 1960s. According to Elliott (2004) the <a href="/wiki/Systems_development_life_cycle" title="Systems development life cycle">systems development life cycle</a> (SDLC) can be considered to be the oldest formalized methodology framework for building <a href="/wiki/Information_system" title="Information system">information systems</a>. The main idea of the SDLC has been "to pursue the development of information systems in a very deliberate, structured and methodical way, requiring each stage of the life cycle\xe2\x80\x93\xe2\x80\x93from inception of the idea to delivery of the final system\xe2\x80\x93\xe2\x80\x93to be carried out rigidly and sequentially"<sup class="reference" id="cite_ref-Ell04_2-0"><a href="#cite_note-Ell04-2">[2]</a></sup> within the context of the framework being applied. The main target of this methodology framework in the 1960s was "to develop large scale functional <a class="mw-redirect" href="/wiki/Business_system" title="Business system">business systems</a> in an age of large scale business conglomerates. Information systems activities revolved around heavy <a href="/wiki/Data_processing" title="Data processing">data processing</a> and <a class="mw-redirect" href="/wiki/Number_crunching" title="Number crunching">number crunching</a> routines".<sup class="reference" id="cite_ref-Ell04_2-1"><a href="#cite_note-Ell04-2">[2]</a></sup>\n</p>, <p>Methodologies, processes, and frameworks range from specific proscriptive steps that can be used directly by an organization in day-to-day work, to flexible frameworks that an organization uses to generate a custom set of steps tailored to the needs of a specific project or group.  In some cases a "sponsor" or "maintenance" organization distributes an official set of documents that describe the process.  Specific examples include:\n</p>, <p><b>2010s</b>\n</p>, <p>It is notable that since DSDM in 1994, all of the methodologies on the above list except RUP have been agile methodologies - yet many organisations, especially governments, still use  pre-agile processes (often waterfall or similar). Software process and <a href="/wiki/Software_quality" title="Software quality">software quality</a> are closely interrelated; some unexpected facets and effects have been observed in practice  <sup class="reference" id="cite_ref-ieeesw_3-0"><a href="#cite_note-ieeesw-3">[3]</a></sup>\n</p>, <p>Since the early 2000s scaling agile delivery processes has become the biggest challenge for teams using agile processes.<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup>\n</p>, <p>Among these another software development process has been established in <a href="/wiki/Open-source_software" title="Open-source software">open source</a>. The adoption of these best practices known and established processes within the confines of a company is called <a href="/wiki/Inner_source" title="Inner source">inner source</a>.\n</p>, <p>Several software development approaches have been used since the origin of information technology, in two main categories<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="Which categories? Why information technology? Why approaches and not processes (as the title of this Wiki article says)? (February 2017)">citation needed</span></a></i>]</sup>.  Typically an approach or a combination of approaches is chosen by management or a development team<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="Who said this? Doesn't this depend on the company? (February 2017)">citation needed</span></a></i>]</sup>.\n</p>, <p>"Traditional" methodologies such as waterfall that have distinct phases are sometimes known as <b>software development life cycle</b> (SDLC) methodologies<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="Where is it written? (February 2017)">citation needed</span></a></i>]</sup>, though this term could also be used more generally to refer to any methodology.  A "life cycle" approach with distinct phases is in contrast to Agile approaches which define a process of iteration, but where design, construction, and deployment of different pieces can occur simultaneously<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="Agile approaches also have a life cycle... (February 2017)">citation needed</span></a></i>]</sup>.\n</p>, <p><a href="/wiki/Continuous_integration" title="Continuous integration">Continuous integration</a> is the practice of merging all developer working copies to a shared <a href="/wiki/Trunk_(software)" title="Trunk (software)">mainline</a> several times a day.<sup class="reference" id="cite_ref-CI0_5-0"><a href="#cite_note-CI0-5">[5]</a></sup> <a href="/wiki/Grady_Booch" title="Grady Booch">Grady Booch</a> first named and proposed CI in <a href="/wiki/Booch_method" title="Booch method">his 1991 method</a>,<sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup> although he did not advocate integrating several times a day. <a href="/wiki/Extreme_programming" title="Extreme programming">Extreme programming</a> (XP) adopted the concept of CI and did advocate integrating more than once per day \xe2\x80\x93 perhaps as many as tens of times per day.\n</p>, <p><a href="/wiki/Software_prototyping" title="Software prototyping">Software prototyping</a> is about creating prototypes, i.e. incomplete versions of the software program being developed.\n</p>, <p>The basic principles are:<sup class="reference" id="cite_ref-CMS08_1-1"><a href="#cite_note-CMS08-1">[1]</a></sup>\n</p>, <p>A basic understanding of the fundamental business problem is necessary to avoid solving the wrong problems, but this is true for all software methodologies.\n</p>, <p>Various methods are acceptable for combining linear and iterative systems development methodologies, with the primary objective of each being to reduce inherent project risk by breaking a project into smaller segments and providing more ease-of-change during the development process.\n</p>, <p>There are three main variants of incremental development:<sup class="reference" id="cite_ref-CMS08_1-2"><a href="#cite_note-CMS08-1">[1]</a></sup>\n</p>, <p><a href="/wiki/Rapid_application_development" title="Rapid application development">Rapid application development</a> (RAD) is a software development methodology, which favors <a class="mw-redirect" href="/wiki/Iterative_development" title="Iterative development">iterative development</a> and the rapid construction of <a href="/wiki/Prototype" title="Prototype">prototypes</a> instead of large amounts of up-front planning. The "planning" of software developed using RAD is interleaved with writing the software itself. The lack of extensive pre-planning generally allows software to be written much faster, and makes it easier to change requirements.\n</p>, <p>The rapid development process starts with the development of preliminary <a href="/wiki/Data_model" title="Data model">data models</a> and <a class="mw-redirect" href="/wiki/Business_process_model" title="Business process model">business process models</a> using <a class="mw-redirect" href="/wiki/Structured_technique" title="Structured technique">structured techniques</a>. In the next stage, requirements are verified using prototyping, eventually to refine the data and process models. These stages are repeated iteratively; further development results in "a combined business requirements and technical design statement to be used for constructing new systems".<sup class="reference" id="cite_ref-WBD04_7-0"><a href="#cite_note-WBD04-7">[7]</a></sup>\n</p>, <p>The term was first used to describe a software development process introduced by <a href="/wiki/James_Martin_(author)" title="James Martin (author)">James Martin</a> in 1991.  According to Whitten (2003), it is a merger of various <a class="mw-redirect" href="/wiki/Structured_Analysis_and_Design_Technique" title="Structured Analysis and Design Technique">structured techniques</a>, especially data-driven <a class="mw-redirect" href="/wiki/Information_technology_engineering" title="Information technology engineering">information technology engineering</a>, with prototyping techniques to accelerate software systems development.<sup class="reference" id="cite_ref-WBD04_7-1"><a href="#cite_note-WBD04-7">[7]</a></sup>\n</p>, <p>The basic principles of rapid application development are:<sup class="reference" id="cite_ref-CMS08_1-3"><a href="#cite_note-CMS08-1">[1]</a></sup>\n</p>, <p>"Agile software development" refers to a group of software development methodologies based on iterative development, where requirements and solutions evolve via collaboration between self-organizing cross-functional teams. The term was coined in the year 2001 when the <a class="mw-redirect" href="/wiki/Agile_Manifesto" title="Agile Manifesto">Agile Manifesto</a> was formulated.\n</p>, <p>Agile software development uses iterative development as a basis but advocates a lighter and more people-centric viewpoint than traditional approaches. Agile processes fundamentally incorporate iteration and the continuous feedback that it provides to successively refine and deliver a software system.\n</p>, <p>There are many agile methodologies, including:\n</p>, <p>The waterfall model is a sequential development approach, in which development is seen as flowing steadily downwards (like a waterfall) through several phases, typically:\n</p>, <p>The first formal description of the method is often cited as an article published by <a href="/wiki/Winston_W._Royce" title="Winston W. Royce">Winston W. Royce</a><sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup> in 1970 although Royce did not use the term "waterfall" in this article. Royce presented this model as an example of a flawed, non-working model.<sup class="reference" id="cite_ref-9"><a href="#cite_note-9">[9]</a></sup>\n</p>, <p>The basic principles are:<sup class="reference" id="cite_ref-CMS08_1-4"><a href="#cite_note-CMS08-1">[1]</a></sup>\n</p>, <p>The waterfall model is a traditional engineering approach applied to software engineering.  A strict waterfall approach discourages revisiting and revising any prior phase once it is complete. This "inflexibility" in a pure waterfall model has been a source of criticism by supporters of other more "flexible" models.  It has been widely blamed for several large-scale government projects running over budget, over time and sometimes failing to deliver on requirements due to the <a href="/wiki/Big_Design_Up_Front" title="Big Design Up Front">Big Design Up Front</a> approach. Except when contractually required, the waterfall model has been largely superseded by more flexible and versatile methodologies developed specifically for software development. See <a href="/wiki/Waterfall_model#Criticism" title="Waterfall model">Criticism of Waterfall model</a>.\n</p>, <p>In 1988, <a href="/wiki/Barry_Boehm" title="Barry Boehm">Barry Boehm</a> published a formal software system development "spiral model," which combines some key aspect of the <a href="/wiki/Waterfall_model" title="Waterfall model">waterfall model</a> and <a href="/wiki/Rapid_application_development" title="Rapid application development">rapid prototyping</a> methodologies, in an effort to combine advantages of <a href="/wiki/Top-down_and_bottom-up_design" title="Top-down and bottom-up design">top-down and bottom-up</a> concepts.  It provided emphasis in a key area many felt had been neglected by other methodologies: deliberate iterative risk analysis, particularly suited to large-scale complex systems.\n</p>, <p>The basic principles are:<sup class="reference" id="cite_ref-CMS08_1-5"><a href="#cite_note-CMS08-1">[1]</a></sup>\n</p>, <p>Other high-level software project methodologies include:\n</p>, <p>Some "<a class="mw-redirect" href="/wiki/Process_model" title="Process model">process models</a>" are abstract descriptions for evaluating, comparing, and improving the specific process adopted by an organization.\n</p>, <p>A variety of such frameworks have evolved over the years, each with its own recognized strengths and weaknesses. One software development methodology framework is not necessarily suitable for use by all projects. Each of the available methodology frameworks are best suited to specific kinds of projects, based on various technical, organizational, project and team considerations.<sup class="reference" id="cite_ref-CMS08_1-6"><a href="#cite_note-CMS08-1">[1]</a></sup>\n</p>, <p><a href="/wiki/Software_development" title="Software development">Software development</a> organizations implement process methodologies to ease the process of development. Sometimes, contractors may require methodologies employed, an example is the U.S. <a href="/wiki/Arms_industry" title="Arms industry">defense industry</a>, which requires a rating based on <a class="mw-redirect" href="/wiki/Process_model" title="Process model">process models</a> to obtain contracts.  The international standard for describing the method of selecting, implementing and monitoring the life cycle for software is <a href="/wiki/ISO/IEC_12207" title="ISO/IEC 12207">ISO/IEC 12207</a>.\n</p>, <p>A decades-long goal has been to find repeatable, predictable processes that improve productivity and quality. Some try to systematize or formalize the seemingly unruly task of designing software. Others apply <a href="/wiki/Project_management" title="Project management">project management</a> techniques to designing software. Large numbers of software projects do not meet their expectations in terms of functionality, cost, or delivery schedule - see <a href="/wiki/List_of_failed_and_overbudget_custom_software_projects" title="List of failed and overbudget custom software projects">List of failed and overbudget custom software projects</a> for some notable examples.\n</p>, <p>Organizations may create a <a href="/wiki/Software_Engineering_Process_Group" title="Software Engineering Process Group">Software Engineering Process Group</a> (SEPG), which is the focal point for process improvement. Composed of line practitioners who have varied skills, the group is at the center of the collaborative effort of everyone in the organization who is involved with software engineering process improvement.\n</p>, <p>A particular development team may also agree to programming environment details, such as which <a href="/wiki/Integrated_development_environment" title="Integrated development environment">integrated development environment</a> is used, and one or more dominant <a href="/wiki/Programming_paradigm" title="Programming paradigm">programming paradigms</a>, <a href="/wiki/Programming_style" title="Programming style">programming style</a> rules, or choice of specific <a class="mw-redirect" href="/wiki/Software_libraries" title="Software libraries">software libraries</a> or <a href="/wiki/Software_framework" title="Software framework">software frameworks</a>.  These details are generally not dictated by the choice of model or general methodology.\n</p>]