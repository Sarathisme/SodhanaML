[<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, and more specifically in <a class="mw-redirect" href="/wiki/Computability_theory_(computer_science)" title="Computability theory (computer science)">computability theory</a> and <a href="/wiki/Computational_complexity_theory" title="Computational complexity theory">computational complexity theory</a>, a <b>model of computation</b> is a model which describes how a set of outputs are computed given a set of inputs. This model describes how units of computations, memories, and communications are organized. The <a href="/wiki/Computational_complexity" title="Computational complexity">computational complexity</a> of an <a href="/wiki/Algorithm" title="Algorithm">algorithm</a> can be measured given a model of computation. Using a model allows studying the performance of algorithms independently of the variations that are specific to particular <a href="/wiki/Implementation" title="Implementation">implementations</a> and specific technology.\n</p>, <p>Models of computation can be classified in three categories: sequential models, functional models, and concurrent models.\n</p>, <p>Sequential models include:\n</p>, <p>Functional models include:\n</p>, <p>Concurrent models include:\n</p>, <p>In the field of runtime <a href="/wiki/Analysis_of_algorithms" title="Analysis of algorithms">analysis of algorithms</a>, it is common to specify a  computational model in terms of <i>primitive operations</i> allowed which have unit cost, or simply <b>unit-cost operations</b>. A commonly used example is the <a class="mw-redirect" href="/wiki/Random_access_machine" title="Random access machine">random access machine</a>, which has unit cost for read and write access to all of its memory cells. In this respect, it differs from the above-mentioned Turing machine model.\n</p>, <p>In <i><a href="/wiki/Model-driven_engineering" title="Model-driven engineering">model-driven engineering</a></i>, the model of computation explains how the behaviour of the whole system is the result of the behaviour of each of its components.\n</p>, <p>A key point which is often overlooked is that published lower bounds for problems are often given for a model of computation that is more restricted than the set of operations that one could use in practice and therefore there may be algorithms that are faster than what would na\xc3\xafvely be thought possible.<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup>\n</p>, <p>There are many models of computation, differing in the set of admissible operations and their computations cost. They fall into the following broad categories: <a href="/wiki/Abstract_machine" title="Abstract machine">abstract machine</a> and models equivalent to it (e.g. <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a> is equivalent to the <a href="/wiki/Turing_machine" title="Turing machine">Turing machine</a>), used in proofs of computability and upper bounds on computational complexity of algorithms, and <a href="/wiki/Decision_tree_model" title="Decision tree model">decision tree models</a>, used in proofs of lower bounds on computational complexity of algorithmic problems.\n</p>]