[<p><b>Software design</b> is the process by which an <a href="/wiki/Agency_(philosophy)" title="Agency (philosophy)">agent</a> creates a specification of a <a href="/wiki/Artifact_(software_development)" title="Artifact (software development)">software artifact</a>, intended to accomplish <a href="/wiki/Goal" title="Goal">goals</a>, using a set of primitive components and subject to <a href="/wiki/Constraint_(mathematics)" title="Constraint (mathematics)">constraints</a>.<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> Software design may refer to either "all the activity involved in conceptualizing, framing, implementing, commissioning, and ultimately modifying complex systems" or "the activity following <a href="/wiki/Software_requirements" title="Software requirements">requirements</a> specification and before <a href="/wiki/Computer_programming" title="Computer programming">programming</a>, as ... [in] a stylized software engineering process."<sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup>\n</p>, <p>Software design usually involves problem solving and planning a <a href="/wiki/Software" title="Software">software</a> solution. This includes both a low-level component and <a class="mw-redirect" href="/wiki/Algorithm_design" title="Algorithm design">algorithm design</a> and a high-level, <a href="/wiki/Software_architecture" title="Software architecture">architecture</a> design.\n</p>, <p>Software design is the process of envisioning and defining software solutions to one or more sets of problems. One of the main components of software design is the <a class="mw-redirect" href="/wiki/Software_requirements_analysis" title="Software requirements analysis">software requirements analysis</a> (SRA). SRA is a part of the <a href="/wiki/Software_development_process" title="Software development process">software development process</a> that lists <a class="mw-redirect" href="/wiki/Specifications" title="Specifications">specifications</a> used in <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a>. If the software is "semi-automated" or <a class="mw-redirect" href="/wiki/User_centered_design" title="User centered design">user centered</a>, software design may involve <a href="/wiki/User_experience_design" title="User experience design">user experience design</a> yielding a <a href="/wiki/Storyboard" title="Storyboard">storyboard</a> to help determine those specifications. If the software is completely <a href="/wiki/Automation" title="Automation">automated</a> (meaning no <a href="/wiki/User_(computing)" title="User (computing)">user</a> or <a href="/wiki/User_interface" title="User interface">user interface</a>), a software design may be as simple as a <a class="mw-redirect" href="/wiki/Flow_chart" title="Flow chart">flow chart</a> or text describing a planned sequence of events. There are also semi-standard methods like <a href="/wiki/Unified_Modeling_Language" title="Unified Modeling Language">Unified Modeling Language</a> and <a href="/wiki/Fundamental_modeling_concepts" title="Fundamental modeling concepts">Fundamental modeling concepts</a>. In either case, some <a href="/wiki/Documentation" title="Documentation">documentation</a> of the plan is usually the product of the design. Furthermore, a software design may be <a href="/wiki/Platform-independent_model" title="Platform-independent model">platform-independent</a> or <a href="/wiki/Platform-specific_model" title="Platform-specific model">platform-specific</a>, depending upon the availability of the technology used for the design.\n</p>, <p>The main difference between software analysis and design is that the output of a software analysis consists of smaller problems to solve. Additionally, the analysis should not be designed very differently across different team members or groups. In contrast, the design focuses on capabilities, and thus multiple designs for the same problem can and will exist. Depending on the environment, the design often varies, whether it is created from reliable <a href="/wiki/Software_framework" title="Software framework">frameworks</a> or implemented with suitable <a class="mw-redirect" href="/wiki/Design_patterns" title="Design patterns">design patterns</a>. Design examples include operation systems, webpages, mobile devices or even the new cloud computing paradigm.\n</p>, <p>Software design is both a process and a model. The design process is a sequence of steps that enables the designer to describe all aspects of the software for building. Creative skill, past experience, a sense of what makes "good" software, and an overall commitment to quality are examples of critical success factors for a competent design. It is important to note, however, that the design process is not always a straightforward procedure; the design model can be compared to an architect\xe2\x80\x99s plans for a house. It begins by representing the totality of the thing that is to be built (e.g., a three-dimensional rendering of the house); slowly, the thing is refined to provide guidance for constructing each detail (e.g., the plumbing lay). Similarly, the design model that is created for software provides a variety of different views of the computer software. Basic design principles enable the software engineer to navigate the design process. Davis <sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup> suggests a set of principles for software design, which have been adapted and extended in the following list:\n</p>, <p>The design concepts provide the software designer with a foundation from which more sophisticated methods can be applied. A set of fundamental design concepts has evolved. They are as follows:\n</p>, <p>In his object model, Grady Booch mentions Abstraction, Encapsulation, Modularisation, and Hierarchy as fundamental software design principles.<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup> The acronym PHAME (Principles of Hierarchy, Abstraction, Modularisation, and Encapsulation) is sometimes used to refer to these four fundamental principles.<sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup>\n</p>, <p>There are many aspects to consider in the design of a piece of software. The importance of each consideration should reflect the goals and expectations that the software is being created to meet. Some of these aspects are:\n</p>, <p>A <a href="/wiki/Modeling_language" title="Modeling language">modeling language</a> is any artificial language that can be used to express information, knowledge or systems in a structure that is defined by a consistent set of rules. These rules are used for interpretation of the components within the structure. A modeling language can be graphical or textual. Examples of graphical modeling languages for software design are:\n</p>, <p>A software designer or architect may identify a design problem which has been visited and perhaps even solved by others in the past. A template or pattern describing a solution to a common problem is known as a <a class="mw-redirect" href="/wiki/Design_pattern_(computer_science)" title="Design pattern (computer science)">design pattern</a>.  The reuse of such patterns can help speed up the software development process.<sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup>\n</p>, <p>The difficulty of using the term "design" in relation to software is that in some senses, the source code of a program <i>is</i> the design for the program that it produces. To the extent that this is true, "software design" refers to the design of the design.  <a href="/wiki/Edsger_W._Dijkstra" title="Edsger W. Dijkstra">Edsger W. Dijkstra</a> referred to this layering of semantic levels as the "radical novelty" of computer programming,<sup class="reference" id="cite_ref-9"><a href="#cite_note-9">[9]</a></sup> and <a href="/wiki/Donald_Knuth" title="Donald Knuth">Donald Knuth</a> used his experience writing <a href="/wiki/TeX" title="TeX">TeX</a> to describe the futility of attempting to design a program prior to implementing it:\n</p>, <p>TEX would have been a complete failure if I had merely specified it and not participated fully in its initial implementation. The process of implementation constantly led me to unanticipated questions and to new insights about how the original specifications could be improved.<sup class="reference" id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup>\n</p>, <p><a class="mw-redirect" href="/wiki/Software_design_document" title="Software design document">Software design documentation</a> may be reviewed or presented to allow constraints, specifications and even requirements to be adjusted prior to <a href="/wiki/Computer_programming" title="Computer programming">computer programming</a>. Redesign may occur after review of a programmed <a href="/wiki/Simulation" title="Simulation">simulation</a> or <a href="/wiki/Prototype" title="Prototype">prototype</a>. It is possible to design software in the process of programming, without a plan or requirement analysis,<sup class="reference" id="cite_ref-11"><a href="#cite_note-11">[11]</a></sup> but for more complex projects this would not be considered feasible. A separate design prior to programming allows for <a class="mw-redirect" href="/wiki/Multidisciplinary" title="Multidisciplinary">multidisciplinary</a> designers and <a class="mw-redirect" href="/wiki/Subject_Matter_Expert" title="Subject Matter Expert">Subject Matter Experts</a> (SMEs) to collaborate with highly skilled programmers for software that is both useful and technically sound.\n</p>, <p><a href="/wiki/Software_design#Design_Principles" title="Software design">^</a><cite class="citation book">Roger S. Pressman. <i>Software engineering: a practitioner\xe2\x80\x99s approach</i>. McGraw-Hill. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>Â <a href="/wiki/Special:BookSources/0-07-365578-3" title="Special:BookSources/0-07-365578-3">0-07-365578-3</a>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Software+engineering%3A+a+practitioner%E2%80%99s+approach&amp;rft.pub=McGraw-Hill&amp;rft.isbn=0-07-365578-3&amp;rft.au=Roger+S.+Pressman&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ASoftware+design"></span><link href="mw-data:TemplateStyles:r861714446" rel="mw-deduplicated-inline-style"/>\n</p>]