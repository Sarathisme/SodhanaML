[<p class="mw-empty-elt">\n</p>, <p>An <b>embedded system</b> is a <a class="mw-redirect" href="/wiki/RTOS" title="RTOS">programmed controlling and operating system</a> with a dedicated function within a larger mechanical or electrical system, often with <a href="/wiki/Real-time_computing" title="Real-time computing">real-time computing</a> constraints.<sup class="reference" id="cite_ref-Barr-glossary_1-0"><a href="#cite_note-Barr-glossary-1">[1]</a></sup><sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup> It is <i>embedded</i> as part of a complete device often including hardware and mechanical parts. Embedded systems control many devices in common use today.<sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup> Ninety-eight percent of all <a href="/wiki/Microprocessor" title="Microprocessor">microprocessors</a> are manufactured to serve as embedded system component.<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup>\n</p>, <p>Examples of properties of typical embedded computers when compared with general-purpose counterparts are low power consumption, small size, rugged operating ranges, and low per-unit cost. This comes at the price of limited processing resources, which make them significantly more difficult to program and to interact with. However, by building intelligence mechanisms on top of the hardware, taking advantage of possible existing sensors and the existence of a network of embedded units, one can both optimally manage available resources at the unit and network levels as well as provide augmented functions, well beyond those available.<sup class="reference" id="cite_ref-Alippi2014_5-0"><a href="#cite_note-Alippi2014-5">[5]</a></sup> For example, intelligent techniques can be designed to manage power consumption of embedded systems.<sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup>\n</p>, <p>Modern embedded systems are often based on <a href="/wiki/Microcontroller" title="Microcontroller">microcontrollers</a> (i.e. CPUs with integrated memory or peripheral interfaces),<sup class="reference" id="cite_ref-micro_controller_7-0"><a href="#cite_note-micro_controller-7">[7]</a></sup> but ordinary microprocessors (using external chips for memory and peripheral interface circuits) are also common, especially in more complex systems. In either case, the processor(s) used may be types ranging from general purpose to those specialized in certain class of computations, or even custom designed for the application at hand. A common standard class of dedicated processors is the <a href="/wiki/Digital_signal_processor" title="Digital signal processor">digital signal processor</a> (DSP).\n</p>, <p>Since the embedded system is dedicated to specific tasks, design engineers can optimize it to reduce the size and cost of the product and increase the reliability and performance. Some embedded systems are mass-produced, benefiting from <a href="/wiki/Economies_of_scale" title="Economies of scale">economies of scale</a>.\n</p>, <p>Embedded systems range from portable devices such as <a class="mw-redirect" href="/wiki/Digital_watch" title="Digital watch">digital watches</a> and <a class="mw-redirect" href="/wiki/Digital_audio_player" title="Digital audio player">MP3 players</a>, to large stationary installations like <a href="/wiki/Traffic_light" title="Traffic light">traffic lights</a>, <a href="/wiki/Programmable_logic_controller" title="Programmable logic controller">factory controllers</a>, and largely complex systems like <a class="mw-redirect" href="/wiki/Hybrid_vehicles" title="Hybrid vehicles">hybrid vehicles</a>, <a class="mw-redirect" href="/wiki/MRI" title="MRI">MRI</a>, and <a href="/wiki/Avionics" title="Avionics">avionics</a>. Complexity varies from low, with a single <a href="/wiki/Microcontroller" title="Microcontroller">microcontroller</a> chip, to very high with multiple units, <a href="/wiki/Peripheral" title="Peripheral">peripherals</a> and networks mounted inside a large <a href="/wiki/Chassis" title="Chassis">chassis</a> or enclosure.\n</p>, <p>One of the very first recognizably modern embedded systems was the <a href="/wiki/Apollo_Guidance_Computer" title="Apollo Guidance Computer">Apollo Guidance Computer</a>,<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="linked article claims it is the first IC-based computer. nothing there supports it being the first embedded system. (August 2018)">citation needed</span></a></i>]</sup> developed ca. 1965 by <a href="/wiki/Charles_Stark_Draper" title="Charles Stark Draper">Charles Stark Draper</a> at the <a class="mw-redirect" href="/wiki/MIT_Instrumentation_Laboratory" title="MIT Instrumentation Laboratory">MIT Instrumentation Laboratory</a>. At the project\'s inception, the Apollo guidance computer was considered the riskiest item in the Apollo project as it employed the then newly developed monolithic integrated circuits to reduce the size and weight. An early mass-produced embedded system was the <a href="/wiki/D-17B" title="D-17B">Autonetics D-17 guidance computer</a> for the <a class="mw-redirect" href="/wiki/Minuteman_(missile)" title="Minuteman (missile)">Minuteman missile</a>, released in 1961. When the Minuteman II went into production in 1966, the D-17 was replaced with a new computer that was the first high-volume use of integrated circuits.\n</p>, <p>Since these early applications in the 1960s, embedded systems have come down in price and there has been a dramatic rise in processing power and functionality. An early <a href="/wiki/Microprocessor" title="Microprocessor">microprocessor</a> for example , the <a href="/wiki/Intel_4004" title="Intel 4004">Intel 4004</a> (released in 1971), was designed for <a href="/wiki/Calculator" title="Calculator">calculators</a> and other small systems but still required external memory and support chips. In 1978 National Engineering Manufacturers Association released a "standard" for programmable microcontrollers, including almost any computer-based controllers, such as single board computers, numerical, and event-based controllers.\n</p>, <p>As the cost of microprocessors and microcontrollers fell it became feasible to replace expensive knob-based <a class="mw-redirect" href="/wiki/Analog_electronics" title="Analog electronics">analog</a> components such as <a href="/wiki/Potentiometer" title="Potentiometer">potentiometers</a> and <a href="/wiki/Variable_capacitor" title="Variable capacitor">variable capacitors</a> with up/down buttons or knobs read out by a microprocessor even in consumer products. By the early 1980s, memory, input and output system components had been integrated into the same chip as the processor forming a <a href="/wiki/Microcontroller" title="Microcontroller">microcontroller</a>. Microcontrollers find applications where a general-purpose computer would be too costly.\n</p>, <p>A comparatively low-cost microcontroller may be programmed to fulfill the same role as a large number of separate components. Although in this context an embedded system is usually more complex than a traditional solution, most of the complexity is contained within the microcontroller itself. Very few additional components may be needed and most of the design effort is in the software. Software prototype and test can be quicker compared with the design and construction of a new circuit not using an embedded processor.\n</p>, <p>Embedded systems are commonly found in consumer, industrial, automotive, medical, commercial and military applications.\n</p>, <p>Telecommunications systems employ numerous embedded systems from <a class="mw-redirect" href="/wiki/Telephone_switch" title="Telephone switch">telephone switches</a> for the network to <a class="mw-redirect" href="/wiki/Cell_phone" title="Cell phone">cell phones</a> at the end user.\nComputer networking uses dedicated <a href="/wiki/Router_(computing)" title="Router (computing)">routers</a> and <a class="mw-redirect" href="/wiki/Network_bridge" title="Network bridge">network bridges</a> to route data.\n</p>, <p><a href="/wiki/Consumer_electronics" title="Consumer electronics">Consumer electronics</a> include <a href="/wiki/MP3_player" title="MP3 player">MP3 players</a>, mobile phones, <a href="/wiki/Video_game_console" title="Video game console">video game consoles</a>, <a href="/wiki/Digital_camera" title="Digital camera">digital cameras</a>, <a href="/wiki/Global_Positioning_System" title="Global Positioning System">GPS</a> receivers, and <a class="mw-redirect" href="/wiki/Computer_printer" title="Computer printer">printers</a>.\nHousehold appliances, such as <a href="/wiki/Microwave_oven" title="Microwave oven">microwave ovens</a>, <a href="/wiki/Washing_machine" title="Washing machine">washing machines</a> and <a class="mw-redirect" href="/wiki/Dishwashers" title="Dishwashers">dishwashers</a>, include embedded systems to provide flexibility, efficiency and features. Advanced <a href="/wiki/HVAC" title="HVAC">HVAC</a> systems use networked <a href="/wiki/Thermostat" title="Thermostat">thermostats</a> to more accurately and efficiently control temperature that can change by time of day and <a href="/wiki/Season" title="Season">season</a>. <a href="/wiki/Home_automation" title="Home automation">Home automation</a> uses wired- and wireless-networking that can be used to control lights, climate, security, audio/visual, surveillance, etc., all of which use embedded devices for sensing and controlling.\n</p>, <p>Transportation systems from flight to automobiles increasingly use embedded systems.\nNew airplanes contain advanced <a href="/wiki/Avionics" title="Avionics">avionics</a> such as <a class="mw-redirect" href="/wiki/Inertial_guidance_system" title="Inertial guidance system">inertial guidance systems</a> and <a href="/wiki/Global_Positioning_System" title="Global Positioning System">GPS</a> receivers that also have considerable safety requirements.\nVarious electric motors \xe2\x80\x94 <a class="mw-redirect" href="/wiki/Brushless_DC_motor" title="Brushless DC motor">brushless DC motors</a>, <a href="/wiki/Induction_motor" title="Induction motor">induction motors</a> and <a href="/wiki/DC_motor" title="DC motor">DC motors</a> \xe2\x80\x94 use electric/electronic <a href="/wiki/Motor_controller" title="Motor controller">motor controllers</a>.\n<a class="mw-redirect" href="/wiki/Automobile" title="Automobile">Automobiles</a>, <a href="/wiki/Electric_vehicle" title="Electric vehicle">electric vehicles</a>, and <a href="/wiki/Hybrid_vehicle" title="Hybrid vehicle">hybrid vehicles</a> increasingly use embedded systems to maximize efficiency and reduce pollution.\nOther automotive safety systems include <a href="/wiki/Anti-lock_braking_system" title="Anti-lock braking system">anti-lock braking system</a> (ABS), <a class="mw-redirect" href="/wiki/Electronic_Stability_Control" title="Electronic Stability Control">Electronic Stability Control</a> (ESC/ESP), <a href="/wiki/Traction_control_system" title="Traction control system">traction control</a> (TCS) and automatic <a href="/wiki/Four-wheel_drive" title="Four-wheel drive">four-wheel drive</a>.\n</p>, <p><a href="/wiki/Medical_equipment" title="Medical equipment">Medical equipment</a> uses embedded systems for <a href="/wiki/Vital_signs" title="Vital signs">vital signs</a> monitoring, <a class="mw-redirect" href="/wiki/Electronic_stethoscope" title="Electronic stethoscope">electronic stethoscopes</a> for amplifying sounds, and various <a href="/wiki/Medical_imaging" title="Medical imaging">medical imaging</a> (<a href="/wiki/Positron_emission_tomography" title="Positron emission tomography">PET</a>, <a class="mw-redirect" href="/wiki/Single_photon_emission_computed_tomography" title="Single photon emission computed tomography">SPECT</a>, <a class="mw-redirect" href="/wiki/Computed_tomography" title="Computed tomography">CT</a>, and <a href="/wiki/Magnetic_resonance_imaging" title="Magnetic resonance imaging">MRI</a>) for non-invasive internal inspections. Embedded systems within medical equipment are often powered by industrial computers.<sup class="reference" id="cite_ref-9"><a href="#cite_note-9">[9]</a></sup>\n</p>, <p>Embedded systems are used in transportation, fire safety, safety and security, medical applications and life critical systems, as these systems can be isolated from hacking and thus, be more reliable, unless connected to wired or wireless networks via on-chip 3G cellular or other methods for IoT monitoring and control purposes.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (October 2012)">citation needed</span></a></i>]</sup> For fire safety, the systems can be designed to have greater ability to handle higher temperatures and continue to operate. In dealing with security, the embedded systems can be self-sufficient and be able to deal with cut electrical and communication systems.\n</p>, <p>A new class of miniature wireless devices called <a class="mw-redirect" href="/wiki/Mote_(sensor)" title="Mote (sensor)">motes</a> are networked wireless sensors. Wireless sensor networking, <a class="mw-redirect" href="/wiki/WSN" title="WSN">WSN</a>, makes use of miniaturization made possible by advanced IC design to couple full wireless subsystems to sophisticated sensors, enabling people and companies to measure a myriad of things in the physical world and act on this information through IT monitoring and control systems. These motes are completely self-contained, and will typically run off a battery source for years before the batteries need to be changed or charged.\n</p>, <p>Embedded Wi-Fi modules provide a simple means of wirelessly enabling any device that communicates via a serial port.\n</p>, <p>Embedded systems are designed to do some specific task, rather than be a general-purpose computer for multiple tasks. Some also have <a href="/wiki/Real-time_computing" title="Real-time computing">real-time</a> performance constraints that must be met, for reasons such as safety and usability; others may have low or no performance requirements, allowing the system hardware to be simplified to reduce costs.\n</p>, <p>Embedded systems are not always standalone devices. Many embedded systems consist of small parts within a larger device that serves a more general purpose. For example, the <a href="/wiki/Gibson_Robot_Guitar" title="Gibson Robot Guitar">Gibson Robot Guitar</a> features an embedded system for tuning the strings, but the overall purpose of the Robot Guitar is, of course, to play music.<sup class="reference" id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup> Similarly, an embedded system in an <a class="mw-redirect" href="/wiki/Automobile" title="Automobile">automobile</a> provides a specific function as a subsystem of the car itself.\n</p>, <p>The program instructions written for embedded systems are referred to as <a href="/wiki/Firmware" title="Firmware">firmware</a>, and are stored in read-only memory or <a href="/wiki/Flash_memory" title="Flash memory">flash memory</a> chips. They run with limited computer hardware resources: little memory, small or non-existent keyboard or screen.\n</p>, <p>Embedded systems range from <a class="mw-redirect" href="/wiki/Headless_system" title="Headless system">no user interface</a> at all, in systems dedicated only to one task, to complex <a class="mw-redirect" href="/wiki/Desktop_operating_system#Graphical_user_interfaces" title="Desktop operating system">graphical user interfaces</a> that resemble modern computer desktop operating systems.\nSimple embedded devices use <a href="/wiki/Push-button" title="Push-button">buttons</a>, <a class="mw-redirect" href="/wiki/LED" title="LED">LEDs</a>, graphic or character <a class="mw-redirect" href="/wiki/LCD" title="LCD">LCDs</a> (<a href="/wiki/Hitachi_HD44780_LCD_controller" title="Hitachi HD44780 LCD controller">HD44780 LCD</a> for example) with a simple <a href="/wiki/Menu_(computing)" title="Menu (computing)">menu system</a>.\n</p>, <p>More sophisticated devices that use a graphical screen with <a class="mw-redirect" href="/wiki/Touch_screen" title="Touch screen">touch</a> sensing or screen-edge buttons provide flexibility while minimizing space used: the meaning of the buttons can change with the screen, and selection involves the natural behavior of pointing at what is desired. <a href="/wiki/Mobile_device" title="Mobile device">Handheld systems</a> often have a screen with a "joystick button" for a pointing device.\n</p>, <p>Some systems provide user interface remotely with the help of a serial (e.g. <a href="/wiki/RS-232" title="RS-232">RS-232</a>, <a href="/wiki/USB" title="USB">USB</a>, <a href="/wiki/I%C2%B2C" title="I\xc2\xb2C">I\xc2\xb2C</a>, etc.) or network (e.g. <a href="/wiki/Ethernet" title="Ethernet">Ethernet</a>) connection. This approach gives several advantages: extends the capabilities of embedded system, avoids the cost of a display, simplifies <a href="/wiki/Board_support_package" title="Board support package">BSP</a> and allows one to build a rich user interface on the PC. A good example of this is the combination of an <a href="/wiki/Embedded_HTTP_server" title="Embedded HTTP server">embedded web server</a> running on an embedded device (such as an <a href="/wiki/IP_camera" title="IP camera">IP camera</a>) or a <a href="/wiki/Router_(computing)" title="Router (computing)">network router</a>. The user interface is displayed in a <a href="/wiki/Web_browser" title="Web browser">web browser</a> on a PC connected to the device, therefore needing no software to be installed.\n</p>, <p>Embedded processors can be broken into two broad categories. Ordinary microprocessors (\xce\xbcP) use separate integrated circuits for memory and peripherals. Microcontrollers (\xce\xbcC) have on-chip peripherals, thus reducing power consumption, size and cost. In contrast to the personal computer market, many different basic <a class="mw-redirect" href="/wiki/CPU_architecture" title="CPU architecture">CPU architectures</a> are used since software is custom-developed for an application and is not a commodity product installed by the end user. Both <a href="/wiki/Von_Neumann_architecture" title="Von Neumann architecture">Von Neumann</a> as well as various degrees of <a href="/wiki/Harvard_architecture" title="Harvard architecture">Harvard architectures</a> are used. <a class="mw-redirect" href="/wiki/RISC" title="RISC">RISC</a> as well as non-RISC processors are found. Word lengths vary from 4-bit to 64-bits and beyond, although the most typical remain 8/16-bit. Most architectures come in a large number of different variants and shapes, many of which are also manufactured by several different companies.\n</p>, <p><a href="/wiki/List_of_common_microcontrollers" title="List of common microcontrollers">Numerous microcontrollers</a> have been developed for embedded systems use. General-purpose microprocessors are also used in embedded systems, but generally, require more support circuitry than microcontrollers.\n</p>, <p><a href="/wiki/PC/104" title="PC/104">PC/104</a> and PC/104+ are examples of standards for <i>ready-made</i> computer boards intended for small, low-volume embedded and ruggedized systems, mostly x86-based. These are often physically small compared to a standard PC, although still quite large compared to most simple (8/16-bit) embedded systems. They often use <a href="/wiki/DOS" title="DOS">DOS</a>, <a href="/wiki/Linux" title="Linux">Linux</a>, <a href="/wiki/NetBSD" title="NetBSD">NetBSD</a>, or an embedded <a href="/wiki/Real-time_operating_system" title="Real-time operating system">real-time operating system</a> such as <a class="mw-redirect" href="/wiki/MicroC/OS-II" title="MicroC/OS-II">MicroC/OS-II</a>, <a href="/wiki/QNX" title="QNX">QNX</a> or <a href="/wiki/VxWorks" title="VxWorks">VxWorks</a>. Sometimes these boards use non-x86 processors.\n</p>, <p>In certain applications, where small size or power efficiency are not primary concerns, the components used may be compatible with those used in general purpose x86 personal computers. Boards such as the VIA <a href="/wiki/EPIA" title="EPIA">EPIA</a> range help to bridge the gap by being PC-compatible but highly integrated, physically smaller or have other attributes making them attractive to embedded engineers. The advantage of this approach is that low-cost commodity components may be used along with the same software development tools used for general software development. Systems built in this way are still regarded as embedded since they are integrated into larger devices and fulfill a single role. Examples of devices that may adopt this approach are <a class="mw-redirect" href="/wiki/Automated_teller_machines" title="Automated teller machines">ATMs</a> and <a class="mw-redirect" href="/wiki/Arcade_machines" title="Arcade machines">arcade machines</a>, which contain code specific to the application.\n</p>, <p>However, most ready-made embedded systems boards are not PC-centered and do not use the ISA or PCI buses. When a <a class="mw-redirect" href="/wiki/System-on-a-chip" title="System-on-a-chip">system-on-a-chip</a> processor is involved, there may be little benefit to having a standardized bus connecting discrete components, and the environment for both hardware and software tools may be very different.\n</p>, <p>One common design style uses a small system module, perhaps the size of a business card, holding high density <a href="/wiki/Ball_grid_array" title="Ball grid array">BGA</a> chips such as an <a href="/wiki/ARM_architecture" title="ARM architecture">ARM</a>-based <a class="mw-redirect" href="/wiki/System-on-a-chip" title="System-on-a-chip">system-on-a-chip</a> processor and peripherals, external <a href="/wiki/Flash_memory" title="Flash memory">flash memory</a> for storage, and <a class="mw-redirect" href="/wiki/Dynamic_random_access_memory" title="Dynamic random access memory">DRAM</a> for runtime memory. The module vendor will usually provide boot software and make sure there is a selection of operating systems, usually including <a href="/wiki/Linux" title="Linux">Linux</a> and some real time choices. These modules can be manufactured in high volume, by organizations familiar with their specialized testing issues, and combined with much lower volume custom mainboards with application-specific external peripherals.\n</p>, <p>Implementation of embedded systems has advanced so that they can easily be implemented with already-made boards that are based on worldwide accepted platforms. These platforms include, but are not limited to, <a href="/wiki/Arduino" title="Arduino">Arduino</a> and <a href="/wiki/Raspberry_Pi" title="Raspberry Pi">Raspberry Pi</a>.\n</p>, <p>A common array for very-high-volume embedded systems is the <a href="/wiki/System_on_a_chip" title="System on a chip">system on a chip</a> (SoC) that contains a complete system consisting of multiple processors, multipliers, caches and interfaces on a single chip. SoCs can be implemented as an <a href="/wiki/Application-specific_integrated_circuit" title="Application-specific integrated circuit">application-specific integrated circuit</a> (ASIC) or using a <a href="/wiki/Field-programmable_gate_array" title="Field-programmable gate array">field-programmable gate array</a> (FPGA).\n</p>, <p>Embedded systems talk with the outside world via <a href="/wiki/Peripheral" title="Peripheral">peripherals</a>, such as:\n</p>, <p>As with other software, embedded system designers use <a href="/wiki/Compiler" title="Compiler">compilers</a>, <a href="/wiki/Assembly_language" title="Assembly language">assemblers</a>, and <a href="/wiki/Debugger" title="Debugger">debuggers</a> to develop embedded system software. However, they may also use some more specific tools:\n</p>, <p>Software tools can come from several sources:\n</p>, <p>As the complexity of embedded systems grows, higher level tools and operating systems are migrating into machinery where it makes sense. For example, <a class="mw-redirect" href="/wiki/Cellphone" title="Cellphone">cellphones</a>, <a href="/wiki/Personal_digital_assistant" title="Personal digital assistant">personal digital assistants</a> and other consumer computers often need significant software that is purchased or provided by a person other than the manufacturer of the electronics. In these systems, an open programming environment such as <a href="/wiki/Linux" title="Linux">Linux</a>, <a href="/wiki/NetBSD" title="NetBSD">NetBSD</a>, <a href="/wiki/OSGi" title="OSGi">OSGi</a> or <a href="/wiki/Embedded_Java" title="Embedded Java">Embedded Java</a> is required so that the third-party software provider can sell to a large market.\n</p>, <p>Embedded systems are commonly found in consumer, cooking, industrial, automotive, medical applications.\nSome examples of embedded systems are MP3 players, mobile phones, video game consoles, digital cameras, DVD players, and GPS. Household appliances, such as microwave ovens, washing machines and dishwashers, include embedded systems to provide flexibility and efficiency.\n</p>, <p>Embedded <a href="/wiki/Debugging" title="Debugging">debugging</a> may be performed at different levels, depending on the facilities available. The different metrics that characterize the different forms of embedded debugging are: does it slow down the main application, how close is the debugged system or application to the actual system or application, how expressive are the triggers that can be set for debugging (e.g., inspecting the memory when a particular <a href="/wiki/Program_counter" title="Program counter">program counter</a> value is reached), and what can be inspected in the debugging process (such as, only memory, or memory and registers, etc.).\n</p>, <p>From simplest to most sophisticated they can be roughly grouped into the following areas:\n</p>, <p>Unless restricted to external debugging, the programmer can typically load and run software through the tools, view the code running in the processor, and start or stop its operation. The view of the code may be as <a href="/wiki/High-level_programming_language" title="High-level programming language">HLL</a> <a class="mw-redirect" href="/wiki/Source-code" title="Source-code">source-code</a>, <a class="mw-redirect" href="/wiki/Assembly_code" title="Assembly code">assembly code</a> or mixture of both.\n</p>, <p>Because an embedded system is often composed of a wide variety of elements, the debugging strategy may vary. For instance, debugging a software- (and microprocessor-) centric embedded system is different from debugging an embedded system where most of the processing is performed by peripherals (DSP, FPGA, and co-processor).\nAn increasing number of embedded systems today use more than one single processor core. A common problem with multi-core development is the proper synchronization of software execution. In this case, the embedded system design may wish to check the data traffic on the busses between the processor cores, which requires very low-level debugging, at signal/bus level, with a <a href="/wiki/Logic_analyzer" title="Logic analyzer">logic analyzer</a>, for instance.\n</p>, <p>Real-time operating systems (<a class="mw-redirect" href="/wiki/RTOS" title="RTOS">RTOS</a>) often supports <a href="/wiki/Tracing_(software)" title="Tracing (software)">tracing</a> of operating system events. A graphical view is presented by a host PC tool, based on a recording of the system behavior. The trace recording can be performed in software, by the RTOS, or by special tracing hardware. RTOS tracing allows developers to understand timing and performance issues of the software system and gives a good understanding of the high-level system behaviors. Commercial tools like <a href="/wiki/RTXC_Quadros" title="RTXC Quadros">RTXC Quadros</a> or <a href="/wiki/IAR_Systems" title="IAR Systems">IAR Systems</a> exists.\n</p>, <p>Embedded systems often reside in machines that are expected to run continuously for years without errors, and in some cases recover by themselves if an error occurs. Therefore, the software is usually developed and tested more carefully than that for personal computers, and unreliable mechanical moving parts such as disk drives, switches or buttons are avoided.\n</p>, <p>Specific reliability issues may include:\n</p>, <p>A variety of techniques are used, sometimes in combination, to recover from errors\xe2\x80\x94both software bugs such as <a href="/wiki/Memory_leak" title="Memory leak">memory leaks</a>, and also <a href="/wiki/Soft_error" title="Soft error">soft errors</a> in the hardware:\n</p>, <p>For high volume systems such as <a class="mw-redirect" href="/wiki/Digital_audio_player" title="Digital audio player">portable music players</a> or <a href="/wiki/Mobile_phone" title="Mobile phone">mobile phones</a>, minimizing cost is usually the primary design consideration. Engineers typically select hardware that is just \xe2\x80\x9cgood enough\xe2\x80\x9d to implement the necessary functions.\n</p>, <p>For low-volume or prototype embedded systems, general purpose computers may be adapted by limiting the programs or by replacing the operating system with a <a href="/wiki/Real-time_operating_system" title="Real-time operating system">real-time operating system</a>.\n</p>, <p>There are several different types of software architecture in common use.\n</p>, <p>In this design, the software simply has a <a class="mw-redirect" href="/wiki/Loop_(computing)" title="Loop (computing)">loop</a>. The loop <a href="/wiki/Subroutine" title="Subroutine">calls subroutines</a>, each of which manages a part of the hardware or software. Hence it is called a simple control loop or control loop.\n</p>, <p>Some embedded systems are predominantly controlled by <a href="/wiki/Interrupt" title="Interrupt">interrupts</a>. This means that tasks performed by the system are triggered by different kinds of events; an interrupt could be generated, for example, by a timer in a predefined frequency, or by a serial port controller receiving a byte.\n</p>, <p>These kinds of systems are used if event handlers need low latency, and the event handlers are short and simple. Usually, these kinds of systems run a simple task in a main loop also, but this task is not very sensitive to unexpected delays.\n</p>, <p>Sometimes the interrupt handler will add longer tasks to a queue structure. Later, after the interrupt handler has finished, these tasks are executed by the main loop. This method brings the system close to a multitasking kernel with discrete processes.\n</p>, <p>A <a class="mw-redirect" href="/wiki/Nonpreemptive_multitasking" title="Nonpreemptive multitasking">nonpreemptive multitasking</a> system is very similar to the simple control loop scheme, except that the loop is hidden in an <a href="/wiki/Application_programming_interface" title="Application programming interface">API</a>.<sup class="reference" id="cite_ref-Barr-glossary_1-1"><a href="#cite_note-Barr-glossary-1">[1]</a></sup> The programmer defines a series of tasks, and each task gets its own environment to \xe2\x80\x9crun\xe2\x80\x9d in. When a task is idle, it calls an idle routine, usually called \xe2\x80\x9cpause\xe2\x80\x9d, \xe2\x80\x9cwait\xe2\x80\x9d, \xe2\x80\x9cyield\xe2\x80\x9d, \xe2\x80\x9cnop\xe2\x80\x9d (stands for <i>no operation</i>), etc.\n</p>, <p>The advantages and disadvantages are similar to that of the control loop, except that adding new software is easier, by simply writing a new task, or adding to the queue.\n</p>, <p>In this type of system, a low-level piece of code switches between tasks or threads based on a timer (connected to an interrupt). This is the level at which the system is generally considered to have an "operating system" kernel. Depending on how much functionality is required, it introduces more or less of the complexities of managing multiple tasks running conceptually in parallel.\n</p>, <p>As any code can potentially damage the data of another task (except in larger systems using an <a href="/wiki/Memory_management_unit" title="Memory management unit">MMU</a>) programs must be carefully designed and tested, and access to shared data must be controlled by some synchronization strategy, such as <a href="/wiki/Message_queue" title="Message queue">message queues</a>, <a href="/wiki/Semaphore_(programming)" title="Semaphore (programming)">semaphores</a> or a <a class="mw-redirect" href="/wiki/Non-blocking_synchronization" title="Non-blocking synchronization">non-blocking synchronization</a> scheme.\n</p>, <p>Because of these complexities, it is common for organizations to use a <a href="/wiki/Real-time_operating_system" title="Real-time operating system">real-time operating system</a> (RTOS), allowing the application programmers to concentrate on device functionality rather than operating system services, at least for large systems; smaller systems often cannot afford the overhead associated with a <i>generic</i> real-time system, due to limitations regarding memory size, performance, or battery life. The choice that an RTOS is required brings in its own issues, however, as the selection must be done prior to starting to the application development process. This timing forces developers to choose the embedded operating system for their device based upon current requirements and so restricts future options to a large extent.<sup class="reference" id="cite_ref-17"><a href="#cite_note-17">[16]</a></sup> The restriction of future options becomes more of an issue as product life decreases. Additionally the level of complexity is continuously growing as devices are required to manage variables such as serial, USB, TCP/IP, Bluetooth, Wireless LAN, trunk radio, multiple channels, data and voice, enhanced graphics, multiple states, multiple threads, numerous wait states and so on. These trends are leading to the uptake of <a class="mw-redirect" href="/wiki/Embedded_middleware" title="Embedded middleware">embedded middleware</a> in addition to a real-time operating system.\n</p>, <p>A <a href="/wiki/Microkernel" title="Microkernel">microkernel</a> is a logical step up from a real-time OS. The usual arrangement is that the operating system kernel allocates memory and switches the CPU to different threads of execution. User mode processes implement major functions such as file systems, network interfaces, etc.\n</p>, <p>In general, microkernels succeed when the task switching and intertask communication is fast and fail when they are slow.\n</p>, <p><a href="/wiki/Exokernel" title="Exokernel">Exokernels</a> communicate efficiently by normal subroutine calls. The hardware and all the software in the system are available to and extensible by application programmers.\n</p>, <p>In this case, a relatively large kernel with sophisticated capabilities is adapted to suit an embedded environment. This gives programmers an environment similar to a desktop operating system like <a href="/wiki/Linux" title="Linux">Linux</a> or <a href="/wiki/Microsoft_Windows" title="Microsoft Windows">Microsoft Windows</a>, and is therefore very productive for development; on the downside, it requires considerably more hardware resources, is often more expensive, and, because of the complexity of these kernels, can be less predictable and reliable.\n</p>, <p>Common examples of embedded monolithic kernels are <a class="mw-redirect" href="/wiki/Embedded_Linux" title="Embedded Linux">embedded Linux</a> and <a class="mw-redirect" href="/wiki/Windows_CE" title="Windows CE">Windows CE</a>.\n</p>, <p>Despite the increased cost in hardware, this type of embedded system is increasing in popularity, especially on the more powerful embedded devices such as <a href="/wiki/Wireless_router" title="Wireless router">wireless routers</a> and <a href="/wiki/Automotive_navigation_system" title="Automotive navigation system">GPS navigation systems</a>. Here are some of the reasons:\n</p>, <p>In addition to the core operating system, many embedded systems have additional upper-layer software components. These components consist of networking protocol stacks like <a class="mw-redirect" href="/wiki/Controller%E2%80%93area_network" title="Controller\xe2\x80\x93area network">CAN</a>, <a class="mw-redirect" href="/wiki/TCP/IP" title="TCP/IP">TCP/IP</a>, <a class="mw-redirect" href="/wiki/FTP" title="FTP">FTP</a>, <a class="mw-redirect" href="/wiki/HTTP" title="HTTP">HTTP</a>, and <a href="/wiki/HTTPS" title="HTTPS">HTTPS</a>, and also included storage capabilities like <a href="/wiki/File_Allocation_Table" title="File Allocation Table">FAT</a> and flash memory management systems. If the embedded device has audio and video capabilities, then the appropriate drivers and codecs will be present in the system. In the case of the monolithic kernels, many of these software layers are included. In the RTOS category, the availability of the additional software components depends upon the commercial offering.\n</p>]