[<p class="mw-empty-elt">\n</p>, <p>A <b>compiler</b> is a <a href="/wiki/Computer_program" title="Computer program">computer program</a> that transforms computer code written in one <a href="/wiki/Programming_language" title="Programming language">programming language</a> (the source language) into another programming language (the target language). Compilers are a type of <a href="/wiki/Translator_(computing)" title="Translator (computing)">translator</a> that support digital devices, primarily computers. The name <i>compiler</i> is primarily used for programs that translate <a href="/wiki/Source_code" title="Source code">source code</a> from a <a href="/wiki/High-level_programming_language" title="High-level programming language">high-level programming language</a> to a <a class="mw-redirect" href="/wiki/Lower_level_language" title="Lower level language">lower level language</a> (e.g., <a href="/wiki/Assembly_language" title="Assembly language">assembly language</a>, <a href="/wiki/Object_code" title="Object code">object code</a>, or <a href="/wiki/Machine_code" title="Machine code">machine code</a>) to create an <a href="/wiki/Executable" title="Executable">executable</a> program.<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup>\n</p>, <p>However, there are many different types of compilers. If the compiled program can run on a computer whose <a href="/wiki/Central_processing_unit" title="Central processing unit">CPU</a> or <a href="/wiki/Operating_system" title="Operating system">operating system</a> is different from the one on which the compiler runs, the compiler is a <a class="mw-redirect" href="/wiki/Cross-compiler" title="Cross-compiler">cross-compiler</a>. A <a class="mw-redirect" href="/wiki/Bootstrap_compiler" title="Bootstrap compiler">bootstrap compiler</a> is written in the language that it intends to compile. A program that translates from a <a class="mw-redirect" href="/wiki/Low-level_language" title="Low-level language">low-level language</a> to a higher level one is a <a href="/wiki/Decompiler" title="Decompiler">decompiler</a>. A program that translates between high-level languages is usually called a <a href="/wiki/Source-to-source_compiler" title="Source-to-source compiler">source-to-source compiler</a> or transpiler. A language <a href="/wiki/Rewriting" title="Rewriting">rewriter</a> is usually a program that translates the form of expressions without a change of language. The term <a href="/wiki/Compiler-compiler" title="Compiler-compiler">compiler-compiler</a> refers to tools used to create parsers that perform syntax analysis.\n</p>, <p>A compiler is likely to perform many or all of the following operations: <a href="/wiki/Preprocessor" title="Preprocessor">preprocessing</a>, <a href="/wiki/Lexical_analysis" title="Lexical analysis">lexical analysis</a>, <a href="/wiki/Parsing" title="Parsing">parsing</a>, <a href="/wiki/Semantic_analysis_(compilers)" title="Semantic analysis (compilers)">semantic analysis</a> (<a href="/wiki/Syntax-directed_translation" title="Syntax-directed translation">syntax-directed translation</a>), conversion of input programs to an <a href="/wiki/Intermediate_representation" title="Intermediate representation">intermediate representation</a>, <a class="mw-redirect" href="/wiki/Code_optimization" title="Code optimization">code optimization</a> and <a href="/wiki/Code_generation_(compiler)" title="Code generation (compiler)">code generation</a>. Compilers implement these operations in phases that promote efficient design and correct transformations of source input to target output. Program faults caused by incorrect compiler behavior can be very difficult to track down and work around; therefore, compiler implementers invest significant effort to ensure <a href="/wiki/Compiler_correctness" title="Compiler correctness">compiler correctness</a>.<sup class="reference" id="cite_ref-Sun2016_2-0"><a href="#cite_note-Sun2016-2">[2]</a></sup>\n</p>, <p>Compilers are not the only translators used to transform source programs. An <a href="/wiki/Interpreter_(computing)" title="Interpreter (computing)">interpreter</a> is computer software that transforms and then executes the indicated operations. The translation process influences the design of computer languages which leads to a preference of compilation or interpretation. In practice, an interpreter can be implemented for compiled languages and compilers can be implemented for interpreted languages.\n</p>, <p>Theoretical computing concepts developed by scientists, mathematicians, and engineers formed the basis of digital modern computing development during World War II. Primitive binary languages evolved because digital devices only understand ones and zeros and the circuit patterns in the underlying machine architecture. In the late 1940s, assembly languages were created to offer a more workable abstraction of the computer architectures. Limited <a class="mw-redirect" href="/wiki/Main_memory" title="Main memory">memory</a> capacity of early computers led to substantial technical challenges when the first compilers were designed. Therefore, the compilation process needed to be divided into several small programs. The front end programs produce the analysis products used by the back end programs to generate target code. As computer technology provided more resources, compiler designs could align better with the compilation process.\n</p>, <p>The human mind can design better solutions as the language moves from the machine to a higher level. So the development of high-level languages followed naturally from the capabilities offered by the digital computers. High-level languages are <a href="/wiki/Formal_language" title="Formal language">formal languages</a> that are strictly defined by their syntax and semantics which form the high-level language architecture. Elements of these formal languages include:\n</p>, <p>The sentences in a language may be defined by a set of rules called a grammar.<sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup>\n</p>, <p><a href="/wiki/Backus%E2%80%93Naur_form" title="Backus\xe2\x80\x93Naur form">Backus\xe2\x80\x93Naur form</a> (BNF) describes the syntax of "sentences" of a language and was used for the syntax of Algol 60 by <a href="/wiki/John_Backus" title="John Backus">John Backus</a>.<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup> The ideas derive from the <a href="/wiki/Context-free_grammar" title="Context-free grammar">context-free grammar</a> concepts by <a href="/wiki/Noam_Chomsky" title="Noam Chomsky">Noam Chomsky</a>, a linguist.<sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup> "BNF and its extensions have become standard tools for describing the syntax of programming notations, and in many cases parts of compilers are generated automatically from a BNF description."<sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup>\n</p>, <p>In the 1940s, <a href="/wiki/Konrad_Zuse" title="Konrad Zuse">Konrad Zuse</a> designed an algorithmic programming language called <a href="/wiki/Plankalk%C3%BCl" title="Plankalk\xc3\xbcl">Plankalk\xc3\xbcl</a> ("Plan Calculus"). While no actual implementation occurred until the 1970s, it presented concepts later seen in <a href="/wiki/APL_(programming_language)" title="APL (programming language)">APL</a> designed by Ken Iverson in the late 1950s.<sup class="reference" id="cite_ref-7"><a href="#cite_note-7">[7]</a></sup> APL is a language for mathematical computations.\n</p>, <p>High-level language design during the formative years of digital computing provided useful programming tools for a variety of applications:\n</p>, <p>Compiler technology evolved from the need for a strictly defined transformation of the high-level source program into a low-level target program for the digital computer. The compiler could be viewed as a front end to deal with analysis of the source code and a back end to synthesize the analysis into the target code. Optimization between the front end and back end could produce more efficient target code.<sup class="reference" id="cite_ref-11"><a href="#cite_note-11">[11]</a></sup>\n</p>, <p>Some early milestones in the development of compiler technology:\n</p>, <p>Early operating systems and software were written in assembly language. In the 60s and early 70s, the use of high-level languages for system programming was still controversial due to resource limitations. However, several research and industry efforts began the shift toward high-level systems programming languages, for example, <a href="/wiki/BCPL" title="BCPL">BCPL</a>, <a href="/wiki/BLISS" title="BLISS">BLISS</a>, <a href="/wiki/B_(programming_language)" title="B (programming language)">B</a>, and <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>.\n</p>, <p><a href="/wiki/BCPL" title="BCPL">BCPL</a> (Basic Combined Programming Language) designed in 1966 by <a href="/wiki/Martin_Richards_(computer_scientist)" title="Martin Richards (computer scientist)">Martin Richards</a> at the University of Cambridge was originally developed as a compiler writing tool.<sup class="reference" id="cite_ref-16"><a href="#cite_note-16">[16]</a></sup> Several compilers have been implemented, Richards\' book provides insights to the language and its compiler.<sup class="reference" id="cite_ref-17"><a href="#cite_note-17">[17]</a></sup> BCPL was not only an influential systems programming language that is still used in research<sup class="reference" id="cite_ref-18"><a href="#cite_note-18">[18]</a></sup> but also provided a basis for the design of B and C languages.\n</p>, <p><a href="/wiki/BLISS" title="BLISS">BLISS</a> (Basic Language for Implementation of System Software) was developed for a Digital Equipment Corporation (DEC) PDP-10 computer by W.A. Wulf\'s Carnegie Mellon University (CMU) research team. The CMU team went on to develop BLISS-11 compiler one year later in 1970.\n</p>, <p><a href="/wiki/Multics" title="Multics">Multics</a> (Multiplexed Information and Computing Service), a time-sharing operating system project, involved <a class="mw-redirect" href="/wiki/MIT" title="MIT">MIT</a>, <a href="/wiki/Bell_Labs" title="Bell Labs">Bell Labs</a>, <a href="/wiki/General_Electric" title="General Electric">General Electric</a> (later <a href="/wiki/Honeywell" title="Honeywell">Honeywell</a>) and was led by <a href="/wiki/Fernando_J._Corbat%C3%B3" title="Fernando J. Corbat\xc3\xb3">Fernando Corbat\xc3\xb3</a> from MIT.<sup class="reference" id="cite_ref-19"><a href="#cite_note-19">[19]</a></sup> Multics was written in the <a href="/wiki/PL/I" title="PL/I">PL/I</a> language developed by IBM and IBM User Group.<sup class="reference" id="cite_ref-20"><a href="#cite_note-20">[20]</a></sup> IBM\'s goal was to satisfy business, scientific, and systems programming requirements. There were other languages that could have been considered but PL/I offered the most complete solution even though it had not been implemented.<sup class="reference" id="cite_ref-21"><a href="#cite_note-21">[21]</a></sup> For the first few years of the Mulitics project, a subset of the language could be compiled to assembly language with the Early PL/I (EPL) compiler by Doug McIlory and Bob Morris from Bell Labs.<sup class="reference" id="cite_ref-22"><a href="#cite_note-22">[22]</a></sup> EPL supported the project until a boot-strapping compiler for the full PL/I could be developed.<sup class="reference" id="cite_ref-23"><a href="#cite_note-23">[23]</a></sup>\n</p>, <p>Bell Labs left the Multics project in 1969: "Over time, hope was replaced by frustration as the group effort initially failed to produce an economically useful system."<sup class="reference" id="cite_ref-24"><a href="#cite_note-24">[24]</a></sup> Continued participation would drive up project support costs. So researchers turned to other development efforts. A system programming language <a href="/wiki/B_(programming_language)" title="B (programming language)">B</a> based on BCPL concepts was written by <a href="/wiki/Dennis_Ritchie" title="Dennis Ritchie">Dennis Ritchie</a> and <a href="/wiki/Ken_Thompson" title="Ken Thompson">Ken Thompson</a>. Ritchie created a boot-strapping compiler for B and wrote <a href="/wiki/Unix" title="Unix">Unics</a> (Uniplexed Information and Computing Service) operating system for a PDP-7 in B. Unics eventually became spelled Unix.\n</p>, <p>Bell Labs started development and expansion of <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> based on B and BCPL. The BCPL compiler had been transported to Multics by Bell Labs and BCPL was a preferred language at Bell Labs.<sup class="reference" id="cite_ref-25"><a href="#cite_note-25">[25]</a></sup> Initially, a front-end program to Bell Labs\' B compiler was used while a C compiler was developed. In 1971, a new PDP-11 provided the resource to define extensions to B and rewrite the compiler. By 1973 the design of C language was essentially complete and the Unix kernel for a PDP-11 was rewritten in C. Steve Johnson started development of Portable C Compiler (PCC) to support retargeting of C compilers to new machines.<sup class="reference" id="cite_ref-26"><a href="#cite_note-26">[26]</a></sup><sup class="reference" id="cite_ref-27"><a href="#cite_note-27">[27]</a></sup>\n</p>, <p><a href="/wiki/Object-oriented_programming" title="Object-oriented programming">Object-oriented programming</a> (OOP) offered some interesting possibilities for application development and maintenance. OOP concepts go further back but were part of <a class="mw-redirect" href="/wiki/LISP" title="LISP">LISP</a> and <a href="/wiki/Simula" title="Simula">Simula</a> language science.<sup class="reference" id="cite_ref-28"><a href="#cite_note-28">[28]</a></sup> At Bell Labs, the development of <a href="/wiki/C%2B%2B" title="C++">C++</a> became interested in OOP.<sup class="reference" id="cite_ref-29"><a href="#cite_note-29">[29]</a></sup> C++ was first used in 1980 for systems programming. The initial design leveraged C language systems programming capabilities with Simula concepts. Object-oriented facilities were added in 1983.<sup class="reference" id="cite_ref-30"><a href="#cite_note-30">[30]</a></sup> The Cfront program implemented a C++ front-end for C84 language compiler. In subsequent years several C++ compilers were developed as C++ popularity grew.\n</p>, <p>In many application domains, the idea of using a higher-level language quickly caught on. Because of the expanding functionality supported by newer <a href="/wiki/Programming_language" title="Programming language">programming languages</a> and the increasing complexity of computer architectures, compilers became more complex.\n</p>, <p><a href="/wiki/DARPA" title="DARPA">DARPA</a> (Defense Advanced Research Projects Agency) sponsored a compiler project with Wulf\'s CMU research team in 1970. The Production Quality Compiler-Compiler <a href="/wiki/PQCC" title="PQCC">PQCC</a> design would produce a Production Quality Compiler (PQC) from formal definitions of source language and the target.<sup class="reference" id="cite_ref-31"><a href="#cite_note-31">[31]</a></sup> PQCC tried to extend the term compiler-compiler beyond the traditional meaning as a parser generator (e.g., <a href="/wiki/Yacc" title="Yacc">Yacc</a>) without much success. PQCC might more properly be referred to as a compiler generator.\n</p>, <p>PQCC research into code generation process sought to build a truly automatic compiler-writing system. The effort discovered and designed the phase structure of the PQC. The BLISS-11 compiler provided the initial structure.<sup class="reference" id="cite_ref-32"><a href="#cite_note-32">[32]</a></sup> The phases included analyses (front end), intermediate translation to virtual machine (middle end), and translation to the target (back end). TCOL was developed for the PQCC research to handle language specific constructs in the intermediate representation.<sup class="reference" id="cite_ref-33"><a href="#cite_note-33">[33]</a></sup> Variations of TCOL supported various languages. The PQCC project investigated techniques of automated compiler construction. The design concepts proved useful in optimizing compilers and compilers for the object-oriented programming language <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a>.\n</p>, <p>The Ada Stoneman Document formalized the program support environment (APSE) along with the kernel (KAPSE) and minimal (MAPSE). An Ada interpreter NYU/ED supported development and standardization efforts with American National Standards Institute (ANSI) and the International Standards Organization (ISO). Initial Ada compiler development by the U.S. Military Services included the compilers in a complete integrated design environment along the lines of the Stoneman Document. Army and Navy worked on the Ada Language System (ALS) project targeted to DEC/VAX architecture while the Air Force started on the Ada Integrated Environment (AIE) targeted to IBM 370 series. While the projects did not provide the desired results, they did contribute to the overal effort on Ada development.<sup class="reference" id="cite_ref-34"><a href="#cite_note-34">[34]</a></sup>\n</p>, <p>Other Ada compiler efforts got under way in Britain at University of York and in Germany at University of Karlsruhe. In the U. S., Verdix (later acquired by Rational) delivered the Verdix Ada Development System (VADS) to the Army. VADS provided a set of development tools including a compiler. Unix/VADS could be hosted on a variety of Unix platforms such as DEC Ultrix and the Sun 3/60 Solaris targeted to Motorola 68020 in an Army CECOM evaluation.<sup class="reference" id="cite_ref-35"><a href="#cite_note-35">[35]</a></sup> There were soon many Ada compilers available that passed the Ada Validation tests. The Free Software Foundation GNU project developed the <a href="/wiki/GNU_Compiler_Collection" title="GNU Compiler Collection">GNU Compiler Collection</a> (GCC) which provides a core capability to support multiple languages and targets. The Ada version <a href="/wiki/GNAT" title="GNAT">GNAT</a> is one of the most widely used Ada compilers. GNAT is free but there is also commercial support, for example, AdaCore, was founded in 1994 to provide commercial software solutions for Ada. GNAT Pro includes the GNU GCC based GNAT with a tool suite to provide an <a href="/wiki/Integrated_development_environment" title="Integrated development environment">integrated development environment</a>.\n</p>, <p>High-level languages continued to drive compiler research and development. Focus areas included optimization and automatic code generation. Trends in programming languages and development environments influenced compiler technology. More compilers became included in language distributions (PERL, Java Development Kit) and as a component of an IDE (VADS, Eclipse, Ada Pro). The interrelationship and interdependence of technologies grew. The advent of web services promoted growth of web languages and scripting languages. Scripts trace back to the early days of Command Line Interfaces (CLI) where the user could enter commands to be executed by the system. User Shell concepts developed with languages to write shell programs. Early Windows designs offered a simple batch programming capability. The conventional transformation of these language used an interpreter. While not widely used, Bash and Batch compilers have been written. More recently sophisticated interpreted languages became part of the developers tool kit. Modern scripting languages include PHP, Python, Ruby and Lua. (Lua is widely used in game development.) All of these have interpreter and compiler support.<sup class="reference" id="cite_ref-36"><a href="#cite_note-36">[36]</a></sup>\n</p>, <p>"When the field of compiling began in the late 50s, its focus was limited to the translation of high-level language programs into machine code ... The compiler field is increasingly intertwined with other disciplines including computer architecture, programming languages, formal methods, software engineering, and computer security."<sup class="reference" id="cite_ref-37"><a href="#cite_note-37">[37]</a></sup> The "Compiler Research: The Next 50 Years" article noted the importance of object-oriented languages and Java. Security and parallel computing were cited among the future research targets.\n</p>, <p>A compiler implements a formal transformation from a high-level source program to a low-level target program. Compiler design can define an end to end solution or tackle a defined subset that interfaces with other compilation tools e.g. preprocessors, assemblers, linkers. Design requirements include rigorously defined interfaces both internally between compiler components and externally between supporting toolsets.\n</p>, <p>In the early days, the approach taken to compiler design was directly affected by the complexity of the computer language to be processed, the experience of the person(s) designing it, and the resources available. Resource limitations led to the need to pass through the source code more than once.\n</p>, <p>A compiler for a relatively simple language written by one person might be a single, monolithic piece of software. However, as the source language grows in complexity the design may be split into a number of interdependent phases. Separate phases provide design improvements that focus development on the functions in the compilation process.\n</p>, <p>Classifying compilers by number of passes has its background in the hardware resource limitations of computers. Compiling involves performing lots of work and early computers did not have enough memory to contain one program that did all of this work. So compilers were split up into smaller programs which each made a pass over the source (or some representation of it) performing some of the required analysis and translations.\n</p>, <p>The ability to compile in a <a href="/wiki/One-pass_compiler" title="One-pass compiler">single pass</a> has classically been seen as a benefit because it simplifies the job of writing a compiler and one-pass compilers generally perform compilations faster than <a href="/wiki/Multi-pass_compiler" title="Multi-pass compiler">multi-pass compilers</a>. Thus, partly driven by the resource limitations of early systems, many early languages were specifically designed so that they could be compiled in a single pass (e.g., <a href="/wiki/Pascal_(programming_language)" title="Pascal (programming language)">Pascal</a>).\n</p>, <p>In some cases the design of a language feature may require a compiler to perform more than one pass over the source. For instance, consider a declaration appearing on line 20 of the source which affects the translation of a statement appearing on line 10. In this case, the first pass needs to gather information about declarations appearing after statements that they affect, with the actual translation happening during a subsequent pass.\n</p>, <p>The disadvantage of compiling in a single pass is that it is not possible to perform many of the sophisticated <a class="mw-redirect" href="/wiki/Compiler_optimization" title="Compiler optimization">optimizations</a> needed to generate high quality code. It can be difficult to count exactly how many passes an optimizing compiler makes. For instance, different phases of optimization may analyse one expression many times but only analyse another expression once.\n</p>, <p>Splitting a compiler up into small programs is a technique used by researchers interested in producing provably correct compilers. Proving the correctness of a set of small programs often requires less effort than proving the correctness of a larger, single, equivalent program.\n</p>, <p>Regardless of the exact number of phases in the compiler design, the phases can be assigned to one of three stages. The stages include a front end, a middle end, and a back end.\n</p>, <p>This front/middle/back-end approach makes it possible to combine front ends for different languages with back ends for different <a href="/wiki/Central_processing_unit" title="Central processing unit">CPUs</a> while sharing the optimizations of the middle end.<sup class="reference" id="cite_ref-38"><a href="#cite_note-38">[38]</a></sup> Practical examples of this approach are the <a href="/wiki/GNU_Compiler_Collection" title="GNU Compiler Collection">GNU Compiler Collection</a>, <a href="/wiki/LLVM" title="LLVM">LLVM</a>,<sup class="reference" id="cite_ref-LattnerBook1st_39-0"><a href="#cite_note-LattnerBook1st-39">[39]</a></sup> and the <a href="/wiki/Amsterdam_Compiler_Kit" title="Amsterdam Compiler Kit">Amsterdam Compiler Kit</a>, which have multiple front-ends, shared optimizations and multiple back-ends.\n</p>, <p>The front end analyzes the source code to build an internal representation of the program, called the <a href="/wiki/Intermediate_representation" title="Intermediate representation">intermediate representation</a> (IR). It also manages the <a href="/wiki/Symbol_table" title="Symbol table">symbol table</a>, a data structure mapping each symbol in the source code to associated information such as location, type and scope.\n</p>, <p>While the frontend can be a single monolithic function or program, as in a <a class="mw-redirect" href="/wiki/Scannerless_parser" title="Scannerless parser">scannerless parser</a>, it is more commonly implemented and analyzed as several phases, which may execute sequentially or concurrently. This method is favored due to its modularity and <a href="/wiki/Separation_of_concerns" title="Separation of concerns">separation of concerns</a>. Most commonly today, the frontend is broken into three phases: <a href="/wiki/Lexical_analysis" title="Lexical analysis">lexical analysis</a> (also known as lexing), <a class="mw-redirect" href="/wiki/Syntax_analysis" title="Syntax analysis">syntax analysis</a> (also known as scanning or parsing), and <a href="/wiki/Semantic_analysis_(compilers)" title="Semantic analysis (compilers)">semantic analysis</a>. Lexing and parsing comprise the syntactic analysis (word syntax and phrase syntax, respectively), and in simple cases these modules (the lexer and parser) can be automatically generated from a grammar for the language, though in more complex cases these require manual modification. The lexical grammar and phrase grammar are usually <a href="/wiki/Context-free_grammar" title="Context-free grammar">context-free grammars</a>, which simplifies analysis significantly, with context-sensitivity handled at the semantic analysis phase. The semantic analysis phase is generally more complex and written by hand, but can be partially or fully automated using <a href="/wiki/Attribute_grammar" title="Attribute grammar">attribute grammars</a>. These phases themselves can be further broken down: lexing as scanning and evaluating, and parsing as building a <a href="/wiki/Parse_tree" title="Parse tree">concrete syntax tree</a> (CST, parse tree) and then transforming it into an <a href="/wiki/Abstract_syntax_tree" title="Abstract syntax tree">abstract syntax tree</a> (AST, syntax tree). In some cases additional phases are used, notably <i>line reconstruction</i> and <i>preprocessing,</i> but these are rare.\n</p>, <p>The main phases of the front end include the following:\n</p>, <p>The middle end performs optimizations on the intermediate representation in order to improve the performance and the quality of the produced machine code.<sup class="reference" id="cite_ref-43"><a href="#cite_note-43">[43]</a></sup> The middle end contains those optimizations that are independent of the CPU architecture being targeted.\n</p>, <p>The main phases of the middle end include the following:\n</p>, <p>Compiler analysis is the prerequisite for any compiler optimization, and they tightly work together. For example, <a href="/wiki/Dependence_analysis" title="Dependence analysis">dependence analysis</a> is crucial for <a class="mw-redirect" href="/wiki/Loop_transformation" title="Loop transformation">loop transformation</a>.\n</p>, <p>The scope of compiler analysis and optimizations vary greatly; their scope may range from operating within a <a href="/wiki/Basic_block" title="Basic block">basic block</a>, to whole procedures, or even the whole program.  There is a trade-off between the granularity of the optimizations and the cost of compilation.  For example, <a href="/wiki/Peephole_optimization" title="Peephole optimization">peephole optimizations</a> are fast to perform during compilation but only affect a small local fragment of the code, and can be performed independently of the context in which the code fragment appears.  In contrast, <a href="/wiki/Interprocedural_optimization" title="Interprocedural optimization">interprocedural optimization</a> requires more compilation time and memory space, but enable optimizations which are only possible by considering the behavior of multiple functions simultaneously.\n</p>, <p>Interprocedural analysis and optimizations are common in modern commercial compilers from <a href="/wiki/Hewlett-Packard" title="Hewlett-Packard">HP</a>, <a href="/wiki/IBM" title="IBM">IBM</a>, <a href="/wiki/Silicon_Graphics" title="Silicon Graphics">SGI</a>, <a href="/wiki/Intel" title="Intel">Intel</a>, <a href="/wiki/Microsoft" title="Microsoft">Microsoft</a>, and <a href="/wiki/Sun_Microsystems" title="Sun Microsystems">Sun Microsystems</a>. The <a href="/wiki/Free_software" title="Free software">free software</a> <a href="/wiki/GNU_Compiler_Collection" title="GNU Compiler Collection">GCC</a> was criticized for a long time for lacking powerful interprocedural optimizations, but it is changing in this respect. Another open source compiler with full analysis and optimization infrastructure is <a href="/wiki/Open64" title="Open64">Open64</a>, which is used by many organizations for research and commercial purposes.\n</p>, <p>Due to the extra time and space needed for compiler analysis and optimizations, some compilers skip them by default. Users have to use compilation options to explicitly tell the compiler which optimizations should be enabled.\n</p>, <p>The back end is responsible for the CPU architecture specific optimizations and for <a href="/wiki/Code_generation_(compiler)" title="Code generation (compiler)">code generation</a><i>.</i>\n</p>, <p>The main phases of the back end include the following:\n</p>, <p><a href="/wiki/Compiler_correctness" title="Compiler correctness">Compiler correctness</a> is the branch of software engineering that deals with trying to show that a compiler behaves according to its <a href="/wiki/Programming_language" title="Programming language">language specification</a>.<sup class="reference" id="cite_ref-45"><a href="#cite_note-45">[45]</a></sup><sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Verifiability#Self-published_sources" title="Wikipedia:Verifiability"><span title="The material near this tag may rely on a self-published source. (March 2017)">self-published source?</span></a></i>]</sup><sup class="noprint Inline-Template noprint Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:No_original_research#Primary,_secondary_and_tertiary_sources" title="Wikipedia:No original research"><span title="This claim needs references to reliable secondary sources. (March 2017)">non-primary source needed</span></a></i>]</sup> Techniques include developing the compiler using <a href="/wiki/Formal_methods" title="Formal methods">formal methods</a> and using rigorous testing (often called compiler validation) on an existing compiler.\n</p>, <p>Higher-level programming languages usually appear with a type of <a href="/wiki/Translator_(computing)" title="Translator (computing)">translation</a> in mind: either designed as <a href="/wiki/Compiled_language" title="Compiled language">compiled language</a> or <a href="/wiki/Interpreted_language" title="Interpreted language">interpreted language</a>. However, in practice there is rarely anything about a language that <i>requires</i> it to be exclusively compiled or exclusively interpreted, although it is possible to design languages that rely on re-interpretation at run time. The categorization usually reflects the most popular or widespread implementations of a language \xe2\x80\x94 for instance, <a href="/wiki/BASIC" title="BASIC">BASIC</a> is sometimes called an interpreted language, and C a compiled one, despite the existence of BASIC compilers and C interpreters.\n</p>, <p>Interpretation does not replace compilation completely. It only hides it from the user and makes it gradual. Even though an interpreter can itself be interpreted, a directly executed program is needed somewhere at the bottom of the stack (see <a class="mw-redirect" href="/wiki/Machine_language" title="Machine language">machine language</a>).\n</p>, <p>Further, compilers can contain interpreters for optimization reasons. For example, where an expression can be executed during compilation and the results inserted into the output program, then it prevents it having to be recalculated each time the program runs, which can greatly speed up the final program. Modern trends toward <a href="/wiki/Just-in-time_compilation" title="Just-in-time compilation">just-in-time compilation</a> and <a href="/wiki/Bytecode" title="Bytecode">bytecode interpretation</a> at times blur the traditional categorizations of compilers and interpreters even further.\n</p>, <p>Some language specifications spell out that implementations <i>must</i> include a compilation facility; for example, <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a>. However, there is nothing inherent in the definition of Common Lisp that stops it from being interpreted. Other languages have features that are very easy to implement in an interpreter, but make writing a compiler much harder; for example, <a href="/wiki/APL_(programming_language)" title="APL (programming language)">APL</a>, <a class="mw-redirect" href="/wiki/SNOBOL4" title="SNOBOL4">SNOBOL4</a>, and many scripting languages allow programs to construct arbitrary source code at runtime with regular string operations, and then execute that code by passing it to a special <a href="/wiki/Eval" title="Eval">evaluation function</a>. To implement these features in a compiled language, programs must usually be shipped with a <a href="/wiki/Runtime_library" title="Runtime library">runtime library</a> that includes a version of the compiler itself.\n</p>, <p>One classification of compilers is by the <a class="mw-redirect" href="/wiki/Platform_(computing)" title="Platform (computing)">platform</a> on which their generated code executes. This is known as the <i>target platform.</i>\n</p>, <p>A <i>native</i> or <i>hosted</i> compiler is one whose output is intended to directly run on the same type of computer and operating system that the compiler itself runs on. The output of a <a href="/wiki/Cross_compiler" title="Cross compiler">cross compiler</a> is designed to run on a different platform. Cross compilers are often used when developing software for <a href="/wiki/Embedded_system" title="Embedded system">embedded systems</a> that are not intended to support a software development environment.\n</p>, <p>The output of a compiler that produces code for a <a href="/wiki/Virtual_machine" title="Virtual machine">virtual machine</a> (VM) may or may not be executed on the same platform as the compiler that produced it. For this reason such compilers are not usually classified as native or cross compilers.\n</p>, <p>The lower level language that is the target of a compiler may itself be a <a href="/wiki/High-level_programming_language" title="High-level programming language">high-level programming language</a>. C, often viewed as some sort of portable assembler, can also be the target language of a compiler. E.g.: <a href="/wiki/Cfront" title="Cfront">Cfront</a>, the original compiler for <a href="/wiki/C%2B%2B" title="C++">C++</a> used C as target language. The C created by such a compiler is usually not intended to be read and maintained by humans. So <a class="mw-redirect" href="/wiki/Indent_style" title="Indent style">indent style</a> and pretty C intermediate code are irrelevant. Some features of C turn it into a good target language. E.g.: C code with <a href="/wiki/C_preprocessor#Special_macros_and_directives" title="C preprocessor"><code>#line</code></a> directives can be generated to support <a href="/wiki/Debugging" title="Debugging">debugging</a> of the original source.\n</p>, <p>While a common compiler type outputs machine code, there are many other types:\n</p>]