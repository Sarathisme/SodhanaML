[<p>A <b>programming tool</b> or <b>software development tool</b> is a <a href="/wiki/Computer_program" title="Computer program">computer program</a> that <a href="/wiki/Software_developer" title="Software developer">software developers</a> use to create, debug, maintain, or otherwise support other programs and applications. The term usually refers to relatively simple programs, that can be combined together to accomplish a task, much as one might use multiple hand <a href="/wiki/Tool" title="Tool">tools</a> to fix a physical object. The most basic tools are a <a href="/wiki/Source_code_editor" title="Source code editor">source code editor</a> and a <a href="/wiki/Compiler" title="Compiler">compiler</a> or <a href="/wiki/Interpreter_(computing)" title="Interpreter (computing)">interpreter</a>, which are used ubiquitously and continuously. Other tools are used more or less depending on the language, development methodology, and individual engineer, and are often used for a discrete task, like a <a href="/wiki/Debugger" title="Debugger">debugger</a> or <a href="/wiki/Profiling_(computer_programming)" title="Profiling (computer programming)">profiler</a>. Tools may be discrete programs, executed separately \xe2\x80\x93 often from the <a class="mw-redirect" href="/wiki/Command_line" title="Command line">command line</a> \xe2\x80\x93 or may be parts of a single large program, called an <a href="/wiki/Integrated_development_environment" title="Integrated development environment">integrated development environment</a> (IDE). In many cases, particularly for simpler use, simple ad hoc techniques are used instead of a tool, such as <a class="mw-redirect" href="/wiki/Print_debugging" title="Print debugging">print debugging</a> instead of using a debugger, manual timing (of overall program or section of code) instead of a profiler, or tracking bugs in a  text file or spreadsheet instead of a <a href="/wiki/Bug_tracking_system" title="Bug tracking system">bug tracking system</a>.\n</p>, <p>The distinction between tools and applications is murky. For example, developers use simple databases (such as a <a class="mw-redirect" href="/wiki/Flat_file_database" title="Flat file database">file containing a list of important values</a>) all the time as tools.<sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Accuracy_dispute#Disputed_statement" title="Wikipedia:Accuracy dispute"><span title="The material near this tag is possibly inaccurate or nonfactual. (March 2010)">dubious</span></a> <span class="metadata"> â€“ <a href="/wiki/Talk:Programming_tool#Dubious" title="Talk:Programming tool">discuss</a></span></i>]</sup> However a full-blown database is usually thought of as an application or software in its own right. For many years, <a href="/wiki/Computer-aided_software_engineering" title="Computer-aided software engineering">computer-assisted software engineering</a> (CASE) tools were sought after. Successful tools have proven elusive.In one sense, CASE tools emphasized design and architecture support, such as for UML. But the most successful of these tools are IDEs.\n</p>, <p>Modern computers are very complex and in order to productively program them,\nvarious abstractions are needed. For example, rather than writing down a\nprogram\'s binary representation a programmer will write a program in a\n<a href="/wiki/Programming_language" title="Programming language">programming language</a> like C, Java or Python.\nProgramming tools like <a href="/wiki/Assembly_language#Assembler" title="Assembly language">assemblers</a>, \n<a href="/wiki/Compiler" title="Compiler">compilers</a> and <a href="/wiki/Linker_(computing)" title="Linker (computing)">linkers</a> translate a\nprogram from a human writeable and readable source language into the bits and\nbytes that can be executed by a computer. Interpreters interpret the\nprogram on the fly to produce the desired behaviour.\n</p>, <p>These programs perform many well defined and repetitive tasks that would\nnonetheless be time consuming and error-prone when performed by a human,\nlike laying out parts of a program in memory and fixing up the references\nbetween parts of a program as a linker does.\nOptimizing compilers on the other hand can perform complex transformations\non the source code in order to improve the execution speed or\nother characteristics of a program. This allows a programmer to focus more\non higher level, conceptual aspects of a program without worrying about the details\nof the machine it is running on.\n</p>, <p>Because of the high complexity of software, it is not possible to understand\nmost programs at a single glance even for the most experienced software developer.\nThe abstractions provided by high-level programming languages also make it harder\nto understand the connection between the source code written by a programmer and\nthe actual program\'s behaviour.\nIn order to find <a href="/wiki/Software_bug" title="Software bug">bugs</a> in programs and to prevent creating new bugs when extending a program, a software developer uses some programming tools to visualize all kinds of information about programs.\n</p>, <p>For example, a <a href="/wiki/Debugger" title="Debugger">debugger</a> allows a programmer to extract information about a\nrunning program in terms of the source language used to program it.\nThe debugger can compute the value of a variable in the source program from the state of the concrete machine by using information stored by the compiler. Memory debuggers can directly point out questionable or outright wrong memory accesses of running programs which may otherwise remain undetected and are a common source of program failures.\n</p>, <p>Software tools come in many forms:\n</p>, <p><a href="/wiki/Integrated_development_environment" title="Integrated development environment">Integrated development environments</a> combine the features of many tools into one package. They for example make it easier to do specific tasks, such as searching for content only in files in a particular project. IDEs may for example be used for development of enterprise-level applications.\n</p>, <p>Different aspects of IDEs for specific programming languages can be found in this <a href="/wiki/Comparison_of_integrated_development_environments" title="Comparison of integrated development environments">comparison of integrated development environments</a>.\n</p>, <p><a class="image" href="/wiki/File:Commons-logo.svg"><img alt="" class="noviewer" data-file-height="1376" data-file-width="1024" height="16" src="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/12px-Commons-logo.svg.png" srcset="//upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/18px-Commons-logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/24px-Commons-logo.svg.png 2x" width="12"/></a> Media related to <a class="extiw" href="https://commons.wikimedia.org/wiki/Category:Programming_tools" title="commons:Category:Programming tools">Programming tools </a> at Wikimedia Commons\n</p>]