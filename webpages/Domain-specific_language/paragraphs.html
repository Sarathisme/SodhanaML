[<p>A <b>domain-specific language</b> (<b>DSL</b>) is a <a href="/wiki/Computer_language" title="Computer language">computer language</a> specialized to a particular application <a href="/wiki/Domain_(software_engineering)" title="Domain (software engineering)">domain</a>. This is in contrast to a <a href="/wiki/General-purpose_language" title="General-purpose language">general-purpose language</a> (GPL), which is broadly applicable across domains. There are a wide variety of DSLs, ranging from widely used languages for common domains, such as <a href="/wiki/HTML" title="HTML">HTML</a> for web pages, down to languages used by only one or a few pieces of software, such as <a href="/wiki/MUSH" title="MUSH">MUSH</a> soft code. DSLs can be further subdivided by the kind of language, and include domain-specific <a href="/wiki/Markup_language" title="Markup language"><i>markup</i> languages</a>, domain-specific <a href="/wiki/Modeling_language" title="Modeling language"><i>modeling</i> languages</a> (more generally, <a href="/wiki/Specification_language" title="Specification language">specification languages</a>), and domain-specific <a href="/wiki/Programming_language" title="Programming language"><i>programming</i> languages</a>. Special-purpose computer languages have always existed in the computer age, but the term "domain-specific language" has become more popular due to the rise of <a href="/wiki/Domain-specific_modeling" title="Domain-specific modeling">domain-specific modeling</a>. Simpler DSLs, particularly ones used by a single application, are sometimes informally called <b>mini-languages</b>.\n</p>, <p>The line between general-purpose languages and domain-specific languages is not always sharp, as a language may have specialized features for a particular domain but be applicable more broadly, or conversely may in principle be capable of broad application but in practice used primarily for a specific domain. For example, <a href="/wiki/Perl" title="Perl">Perl</a> was originally developed as a text-processing and glue language, for the same domain as <a href="/wiki/AWK" title="AWK">AWK</a> and <a href="/wiki/Shell_script" title="Shell script">shell scripts</a>, but was mostly used as a general-purpose programming language later on. By contrast, <a href="/wiki/PostScript" title="PostScript">PostScript</a> is a <a class="mw-redirect" href="/wiki/Turing_complete" title="Turing complete">Turing complete</a> language, and in principle can be used for any task, but in practice is narrowly used as a <a href="/wiki/Page_description_language" title="Page description language">page description language</a>.\n</p>, <p>The design and use of appropriate DSLs is a key part of <a href="/wiki/Domain_engineering" title="Domain engineering">domain engineering</a>, by using a language suitable to the domain at hand \xe2\x80\x93 this may consist of using an existing DSL or GPL, or developing a new DSL. <a href="/wiki/Language-oriented_programming" title="Language-oriented programming">Language-oriented programming</a> considers the creation of special-purpose languages for expressing problems as standard part of the problem solving process. Creating a domain-specific language (with software to support it), rather than reusing an existing language, can be worthwhile if the language allows a particular type of problem or solution to be expressed more clearly than an existing language would allow and the type of problem in question reappears sufficiently often. Pragmatically, a DSL may be specialized to a particular problem domain, a particular problem representation technique, a particular solution technique, or other aspect of a domain.\n</p>, <p>A domain-specific language is created specifically to solve problems in a particular domain and is not intended to be able to solve problems outside it (although that may be technically possible).  In contrast, general-purpose languages are created to solve problems in many domains. The domain can also be a business area.  Some examples of business areas include:\n</p>, <p>A domain-specific language is somewhere between a tiny programming language and a <a href="/wiki/Scripting_language" title="Scripting language">scripting language</a>, and is often used in a way analogous to a <a class="mw-redirect" href="/wiki/Programming_library" title="Programming library">programming library</a>. The boundaries between these concepts are quite blurry, much like the boundary between scripting languages and general-purpose languages.\n</p>, <p>Domain-specific languages are languages (or often, declared syntaxes or grammars) with very specific goals in design and implementation. A domain-specific language can be one of a visual diagramming language, such as those created by the <a href="/wiki/Generic_Eclipse_Modeling_System" title="Generic Eclipse Modeling System">Generic Eclipse Modeling System</a>, programmatic abstractions, such as the <a href="/wiki/Eclipse_Modeling_Framework" title="Eclipse Modeling Framework">Eclipse Modeling Framework</a>, or textual languages. For instance, the command line utility <a href="/wiki/Grep" title="Grep">grep</a> has a <a href="/wiki/Regular_expression" title="Regular expression">regular expression</a> syntax which matches patterns in lines of text. The <a href="/wiki/Sed" title="Sed">sed</a> utility defines a syntax for matching and replacing regular expressions.  Often, these tiny languages can be used together inside a <a class="mw-redirect" href="/wiki/Operating_system_shell" title="Operating system shell">shell</a> to perform more complex programming tasks.\n</p>, <p>The line between domain-specific languages and <a href="/wiki/Scripting_language" title="Scripting language">scripting languages</a> is somewhat blurred, but domain-specific languages often lack low-level functions for filesystem access, interprocess control, and other functions that characterize full-featured programming languages, scripting or otherwise. Many domain-specific languages do not compile to <a class="mw-redirect" href="/wiki/Byte-code" title="Byte-code">byte-code</a> or executable code, but to various kinds of media objects: GraphViz exports to <a href="/wiki/PostScript" title="PostScript">PostScript</a>, <a href="/wiki/GIF" title="GIF">GIF</a>, <a href="/wiki/JPEG" title="JPEG">JPEG</a>, etc., where <a href="/wiki/Csound" title="Csound">Csound</a> compiles to audio files, and a ray-tracing domain-                       specific language like <a href="/wiki/POV-Ray" title="POV-Ray">POV</a> compiles to graphics files. A computer language like <a href="/wiki/SQL" title="SQL">SQL</a> presents an interesting case: it can be deemed a domain-specific language because it is specific to a specific domain (in SQL\'s case, accessing and managing relational databases), and is often called from another application, but SQL has more keywords and functions than many scripting languages, and is often thought of as a language in its own right, perhaps because of the prevalence of database manipulation in programming and the amount of mastery required to be an expert in the language.\n</p>, <p>Further blurring this line, many domain-specific languages have exposed APIs, and can be accessed from other programming languages without breaking the flow of execution or calling a separate process, and can thus operate as programming libraries.\n</p>, <p>Some domain-specific languages expand over time to include full-featured programming tools, which further complicates the question of whether a language is domain-specific or not. A good example is the <a class="mw-redirect" href="/wiki/Functional_language" title="Functional language">functional language</a> <a href="/wiki/XSLT" title="XSLT">XSLT</a>, specifically designed for transforming one XML graph into another, which has been extended since its inception to allow (particularly in its 2.0 version) for various forms of filesystem interaction, string and date manipulation, and data typing.\n</p>, <p>In <a href="/wiki/Model-driven_engineering" title="Model-driven engineering">model-driven engineering</a>, many examples of domain-specific languages may be found like <a href="/wiki/Object_Constraint_Language" title="Object Constraint Language">OCL</a>, a language for decorating models with assertions or <a href="/wiki/QVT" title="QVT">QVT</a>, a domain-specific transformation language. However languages like <a href="/wiki/Unified_Modeling_Language" title="Unified Modeling Language">UML</a> are typically general purpose modeling languages.\n</p>, <p>To summarize, an analogy might be useful: a Very Little Language is like a knife, which can be used in thousands of different ways, from cutting food to cutting down trees. A domain-specific language is like an electric drill: it is a powerful tool with a wide variety of uses, but a specific context, namely, putting holes in things. A General Purpose Language is a complete workbench, with a variety of tools intended for performing a variety of tasks. Domain-specific languages should be used by programmers who, looking at their current workbench, realize they need a better drill, and find that a particular domain-specific language provides exactly that.\n</p>, <p>There are several usage patterns for domain-specific languages:<sup class="reference" id="cite_ref-Mernik05_1-0"><a href="#cite_note-Mernik05-1">[1]</a></sup><sup class="reference" id="cite_ref-Spinellis01_2-0"><a href="#cite_note-Spinellis01-2">[2]</a></sup>\n</p>, <p>Many domain-specific languages can be used in more than one way.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (September 2009)">citation needed</span></a></i>]</sup> DSL code embedded in a host language may have special syntax support, such as regexes in sed, AWK, Perl or JavaScript, or may be passed as strings.\n</p>, <p>Adopting a domain-specific language approach to software engineering involves both risks and opportunities. The well-designed domain-specific language manages to find the proper balance between these.\n</p>, <p>Domain-specific languages have important design goals that contrast with those of general-purpose languages:\n</p>, <p>In programming, idioms are methods imposed by programmers to handle common development tasks, e.g.:\n</p>, <p>General purpose programming languages rarely support such idioms, but domain-specific languages can describe them, e.g.:\n</p>, <p>Examples of domain-specific languages include <a href="/wiki/HTML" title="HTML">HTML</a>, <a href="/wiki/Logo_(programming_language)" title="Logo (programming language)">Logo</a> for pencil-like drawing, <a href="/wiki/Verilog" title="Verilog">Verilog</a> and <a class="mw-redirect" href="/wiki/VHSIC_hardware_description_language" title="VHSIC hardware description language">VHDL</a> hardware description languages, <a href="/wiki/MATLAB" title="MATLAB">MATLAB</a> and <a href="/wiki/GNU_Octave" title="GNU Octave">GNU Octave</a> for matrix programming, <a class="mw-redirect" href="/wiki/Mathematica" title="Mathematica">Mathematica</a>, <a href="/wiki/Maple_(software)" title="Maple (software)">Maple</a> and <a href="/wiki/Maxima_(software)" title="Maxima (software)">Maxima</a> for <a href="/wiki/Symbol" title="Symbol">symbolic</a> <a href="/wiki/Mathematics" title="Mathematics">mathematics</a>, <a href="/wiki/Specification_and_Description_Language" title="Specification and Description Language">Specification and Description Language</a> for reactive and distributed systems, <a href="/wiki/Spreadsheet" title="Spreadsheet">spreadsheet</a> formulas and macros, <a href="/wiki/SQL" title="SQL">SQL</a> for <a href="/wiki/Relational_database" title="Relational database">relational database</a> queries, <a href="/wiki/Yacc" title="Yacc">YACC</a> grammars for creating <a class="mw-redirect" href="/wiki/Parsers" title="Parsers">parsers</a>, <a class="mw-redirect" href="/wiki/Regular_expressions" title="Regular expressions">regular expressions</a> for specifying <a href="/wiki/Lexical_analysis" title="Lexical analysis">lexers</a>, the <a href="/wiki/Generic_Eclipse_Modeling_System" title="Generic Eclipse Modeling System">Generic Eclipse Modeling System</a> for creating diagramming languages, <a href="/wiki/Csound" title="Csound">Csound</a> for sound and music synthesis, and the input languages of <a class="mw-redirect" href="/wiki/GraphViz" title="GraphViz">GraphViz</a> and <a href="/wiki/GrGen" title="GrGen">GrGen</a>, software packages used for <a class="mw-redirect" href="/wiki/Graph_layout" title="Graph layout">graph layout</a> and <a href="/wiki/Graph_rewriting" title="Graph rewriting">graph rewriting</a>.\n</p>, <p>The GML scripting language used by <a href="/wiki/GameMaker_Studio" title="GameMaker Studio">GameMaker Studio</a> is a domain-specific language targeted at novice programmers to easily be able to learn programming. While the language serves as a blend of multiple languages including <a class="mw-redirect" href="/wiki/Delphi_(programming_language)" title="Delphi (programming language)">Delphi</a>, <a href="/wiki/C%2B%2B" title="C++">C++</a>, and <a href="/wiki/BASIC" title="BASIC">BASIC</a>, there is a lack of structures, data types, and other features of a full-fledged programming language. Many of the built-in functions are <a href="/wiki/Sandbox_(software_development)" title="Sandbox (software development)">sandboxed</a> for the purpose of easy portability. The language primarily serves to make it easy for anyone to pick up the language and develop a game.\n</p>, <p><a href="/wiki/Unix" title="Unix">Unix</a> <a class="mw-redirect" href="/wiki/Shell_scripts" title="Shell scripts">shell scripts</a> give a good example of a domain-specific language for <a href="/wiki/Data_(computing)" title="Data (computing)">data</a><sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup> organization. They can manipulate data in <a href="/wiki/Computer_file" title="Computer file">files</a> or user input in many different ways.  Domain abstractions and notations include <a href="/wiki/Stream_(computing)" title="Stream (computing)">streams</a> (such as stdin and stdout) and operations on streams (such as redirection and pipe).  These abstractions combine to make a robust language to describe the flow and organization of data.\n</p>, <p>The language consists of a simple interface (a script) for running and controlling <a href="/wiki/Process_(computing)" title="Process (computing)">processes</a> that perform small <a href="/wiki/Task_(computing)" title="Task (computing)">tasks</a>.  These tasks represent the <a href="/wiki/Programming_idiom" title="Programming idiom">idioms</a> of organizing data into a desired format such as tables, graphs, charts, etc.\n</p>, <p>These tasks consist of simple <a href="/wiki/Control_flow" title="Control flow">control-flow</a> and string manipulation mechanisms that cover a lot of common usages like searching and replacing <a href="/wiki/String_(computer_science)" title="String (computer science)">string</a> in files, or counting occurrences of strings (frequency counting).\n</p>, <p>Even though Unix scripting languages are <a class="mw-redirect" href="/wiki/Turing_complete" title="Turing complete">Turing complete</a>, they differ from <a href="/wiki/General-purpose_language" title="General-purpose language">general purpose languages</a>.<sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Please_clarify" title="Wikipedia:Please clarify"><span title="The text near this tag may need clarification or removal of jargon. (March 2016)">clarification needed</span></a></i>]</sup>\n</p>, <p>In practice, <a class="mw-redirect" href="/wiki/Scripting_languages" title="Scripting languages">scripting languages</a> are used to weave together small Unix tools such as <a href="/wiki/Grep" title="Grep">grep</a>, <a href="/wiki/Ls" title="Ls">ls</a>, <a href="/wiki/Sort_(Unix)" title="Sort (Unix)">sort</a> or <a href="/wiki/Wc_(Unix)" title="Wc (Unix)">wc</a>.\n</p>, <p><a class="mw-redirect" href="/wiki/ColdFusion" title="ColdFusion">ColdFusion</a>\'s associated scripting language is another example of a domain-specific language for data-driven websites.\nThis scripting language is used to weave together languages and services such as Java, .NET, C++, SMS, email, email servers, http, ftp, exchange, directory services, and file systems for use in websites.\n</p>, <p>The <a href="/wiki/ColdFusion_Markup_Language" title="ColdFusion Markup Language">ColdFusion Markup Language</a> (CFML) includes a set of tags that can be used in ColdFusion pages to interact with data\nsources, manipulate data, and display output. CFML tag syntax is similar to HTML element syntax.\n</p>, <p><a href="/wiki/Erlang_(programming_language)" title="Erlang (programming language)">The Erlang Open Telecom Platform</a> was originally designed for use inside <a href="/wiki/Ericsson" title="Ericsson">Ericsson</a> as a domain-specific language. The language itself offers a platform of libraries to create finite state machines, generic servers and event managers that quickly allow an engineer to deploy applications, or support libraries, that have been shown in industry benchmarks to outperform other languages intended for a mixed set of domains, such as C and C++. The language is now officially open source and can be downloaded from their website.\n</p>, <p>FilterMeister is a programming environment, with a programming language that is based on C, for the specific purpose of creating <a class="mw-redirect" href="/wiki/Photoshop" title="Photoshop">Photoshop</a>-compatible image processing filter plug-ins; FilterMeister runs as a Photoshop plug-in itself and it can load and execute scripts or compile and export them as independent plug-ins.\nAlthough the FilterMeister language reproduces a significant portion of the C language and function library, it contains only those features which can be used within the context of Photoshop plug-ins and adds a number of specific features only useful in this specific domain.\n</p>, <p>The <i>Template</i> feature of <a href="/wiki/MediaWiki" title="MediaWiki">MediaWiki</a> is an embedded domain-specific language whose fundamental purpose is to support the creation of <a href="/wiki/Wikipedia:Template_messages" title="Wikipedia:Template messages">page templates</a> and the <a href="/wiki/Wikipedia:Transclusion" title="Wikipedia:Transclusion">transclusion</a> (inclusion by reference) of MediaWiki pages into other MediaWiki pages.\n</p>, <p>There has been much interest in domain-specific languages to improve the productivity and quality of <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a>.  Domain-specific language could possibly provide a robust set of tools for efficient software engineering. Such tools are beginning to make their way into development of critical software systems.\n</p>, <p>The Software Cost Reduction Toolkit<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup> is an example of this. The toolkit is a suite of utilities including a specification editor to create a <a class="mw-redirect" href="/wiki/Software_Requirements_Specification" title="Software Requirements Specification">requirements specification</a>, a dependency graph browser to display variable dependencies, a <a class="new" href="/w/index.php?title=Consistency_checker&amp;action=edit&amp;redlink=1" title="Consistency checker (page does not exist)">consistency checker</a> to catch missing cases in <a href="/wiki/Well-formed_formula" title="Well-formed formula">well-formed formulas</a> in the specification, a <a class="mw-redirect" href="/wiki/Model_checker" title="Model checker">model checker</a> and a <a class="mw-redirect" href="/wiki/Automated_theorem_prover" title="Automated theorem prover">theorem prover</a> to check program properties against the specification, and an invariant generator that automatically constructs invariants based on the requirements.\n</p>, <p>Complementing <a href="/wiki/Language-oriented_programming" title="Language-oriented programming">language-oriented programming</a>, as well as all other forms of domain-specific languages, are the class of compiler writing tools called <a class="mw-redirect" href="/wiki/Metacompiler" title="Metacompiler">metacompilers</a>. A metacompiler is not only useful for generating <a class="mw-redirect" href="/wiki/Parser" title="Parser">parsers</a> and <a class="mw-redirect" href="/wiki/Code_generator" title="Code generator">code generators</a> for domain-specific languages, but a <a class="mw-redirect" href="/wiki/Metacompiler" title="Metacompiler">metacompiler</a> itself compiles a domain-specific <a href="/wiki/Metalanguage" title="Metalanguage">metalanguage</a> specifically designed for the domain of <a href="/wiki/Metaprogramming" title="Metaprogramming">metaprogramming</a>.\n</p>, <p>Besides parsing domain-specific languages, metacompilers are useful for generating a wide range of software engineering and analysis tools.  The meta-compiler methodology is often found in <a href="/wiki/Program_transformation" title="Program transformation">program transformation systems</a>.\n</p>, <p>Metacompilers that played a significant role in both computer science and the computer industry include <a href="/wiki/META_II" title="META II">Meta-II</a><sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup> and its descendent <a href="/wiki/TREE-META" title="TREE-META">TreeMeta</a>.<sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup>\n</p>, <p><a href="/wiki/Unreal_(1998_video_game)" title="Unreal (1998 video game)">Unreal</a> and <a href="/wiki/Unreal_Tournament" title="Unreal Tournament">Unreal Tournament</a> unveiled a language called <a class="mw-redirect" href="/wiki/UnrealScript" title="UnrealScript">UnrealScript</a>. This allowed for rapid development of modifications compared to the competitor <a href="/wiki/Quake_(video_game)" title="Quake (video game)">Quake</a> (using the <a class="mw-redirect" href="/wiki/Id_Tech_2" title="Id Tech 2">Id Tech 2</a> engine). The Id Tech engine used standard <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> code meaning C had to be learned and properly applied, while UnrealScript was optimized for ease of use and efficiency. Similarly, the development of more recent games introduced their own specific languages, one more common example is <a href="/wiki/Lua_(programming_language)" title="Lua (programming language)">Lua</a> for scripting.\n</p>, <p>Various <a href="/wiki/Business_rules_engine" title="Business rules engine">Business Rules Engines</a> have been developed for automating policy and business rules used in both government and private industry.  <a href="/wiki/ILOG" title="ILOG">ILOG</a>, <a href="/wiki/Oracle_Policy_Automation" title="Oracle Policy Automation">Oracle Policy Automation</a>, <a class="new" href="/w/index.php?title=DTRules&amp;action=edit&amp;redlink=1" title="DTRules (page does not exist)">DTRules</a>, <a href="/wiki/Drools" title="Drools">Drools</a> and others provide support for DSLs aimed to support various problem domains.  <a class="new" href="/w/index.php?title=DTRules&amp;action=edit&amp;redlink=1" title="DTRules (page does not exist)">DTRules</a> goes so far as to define an interface for the use of multiple DSLs within a Rule Set.\n</p>, <p>The purpose of Business Rules Engines is to define a representation of business logic in as human readable fashion as possible.  This allows both <a href="/wiki/Subject-matter_expert" title="Subject-matter expert">subject matter experts</a> and developers to work with and understand the same representation of the business logic.  Most Rules Engines provide both an approach to simplifying the control structures for business logic (for example, using Declarative Rules or <a href="/wiki/Decision_table" title="Decision table">Decision Tables</a>) coupled with alternatives to programming syntax in favor of DSLs.\n</p>, <p>Statistical modellers have developed domain-specific languages such as\n<a href="/wiki/Bayesian_inference_using_Gibbs_sampling" title="Bayesian inference using Gibbs sampling">Bugs</a>, <a href="/wiki/Just_another_Gibbs_sampler" title="Just another Gibbs sampler">Jags</a>, and <a href="/wiki/Stan_(software)" title="Stan (software)">Stan</a>. These languages provide a syntax for describing a Bayesian model, and generate a method for solving it using simulation.\n</p>, <p>Generate object handling and services based on a <a href="/wiki/Interface_description_language" title="Interface description language">Interface Description Language</a> for a domain-specific language such as JavaScript for web applications, HTML for documentation, C++ for high performance code, etc. This is done by cross language frameworks such as <a href="/wiki/Apache_Thrift" title="Apache Thrift">Apache Thrift</a> or <a href="/wiki/Protocol_Buffers" title="Protocol Buffers">Google Protocol Buffers</a>.\n</p>, <p><a href="/wiki/Cucumber_(software)#Gherkin_.28Language.29" title="Cucumber (software)">Gherkin</a> is a language designed to define test cases to check the behaviour of software, without specifying how that behaviour is implemented. It is meant to be read and used by non-technical users using a natural language syntax and a <a href="/wiki/Off-side_rule" title="Off-side rule">line-oriented design</a>. The tests defined with Gherkin must then be implemented in a general programming language. Then, the steps in a Gherkin program acts as a syntax for method invocation accessible to non-developers.\n</p>, <p>Other prominent examples of domain-specific languages include:\n</p>, <p>Some of the advantages:<sup class="reference" id="cite_ref-Mernik05_1-1"><a href="#cite_note-Mernik05-1">[1]</a></sup><sup class="reference" id="cite_ref-Spinellis01_2-1"><a href="#cite_note-Spinellis01-2">[2]</a></sup>\n</p>, <p>Some of the disadvantages:\n</p>]