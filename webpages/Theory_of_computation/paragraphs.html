[<p>In <a href="/wiki/Theoretical_computer_science" title="Theoretical computer science">theoretical computer science</a> and <a href="/wiki/Mathematics" title="Mathematics">mathematics</a>, the <b>theory of computation</b> is the branch that deals with how efficiently problems can be solved on a <a href="/wiki/Model_of_computation" title="Model of computation">model of computation</a>, using an <a href="/wiki/Algorithm" title="Algorithm">algorithm</a>.  The field is divided into three major branches: <a href="/wiki/Automata_theory" title="Automata theory">automata theory</a> and languages, <a href="/wiki/Computability_theory" title="Computability theory">computability theory</a>, and <a href="/wiki/Computational_complexity_theory" title="Computational complexity theory">computational complexity theory</a>, which are linked by the question: <i>"What are the fundamental capabilities and limitations of computers?".</i><sup class="reference" id="cite_ref-Sipser-3rd_1-0"><a href="#cite_note-Sipser-3rd-1">[1]</a></sup>\n</p>, <p>In order to perform a rigorous study of computation, computer scientists work with a mathematical abstraction of computers called a <a href="/wiki/Model_of_computation" title="Model of computation">model of computation</a>.  There are several models in use, but the most commonly examined is the <a href="/wiki/Turing_machine" title="Turing machine">Turing machine</a>.<sup class="reference" id="cite_ref-Hodges-2012_2-0"><a href="#cite_note-Hodges-2012-2">[2]</a></sup> Computer scientists study the Turing machine because it is simple to formulate, can be analyzed and used to prove results, and because it represents what many consider the most powerful possible "reasonable" model of computation (see <a href="/wiki/Church%E2%80%93Turing_thesis" title="Church\xe2\x80\x93Turing thesis">Church\xe2\x80\x93Turing thesis</a>).<sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup> It might seem that the potentially infinite memory capacity is an unrealizable attribute, but any <a href="/wiki/Decidability_(logic)" title="Decidability (logic)">decidable</a> problem<sup class="reference" id="cite_ref-Monk1976_4-0"><a href="#cite_note-Monk1976-4">[4]</a></sup> solved by a Turing machine will always require only a finite amount of memory. So in principle, any problem that can be solved (decided) by a Turing machine can be solved by a computer that has a finite amount of memory.\n</p>, <p>The theory of computation can be considered the creation of models of all kinds in the field of computer science. Therefore, <a href="/wiki/Mathematical_logic" title="Mathematical logic">mathematics and logic</a> are used. In the last century it became an independent academic discipline and was separated from mathematics.\n</p>, <p>Some pioneers of the theory of computation were <a href="/wiki/Alonzo_Church" title="Alonzo Church">Alonzo Church</a>, <a href="/wiki/Kurt_G%C3%B6del" title="Kurt G\xc3\xb6del">Kurt G\xc3\xb6del</a>, <a href="/wiki/Alan_Turing" title="Alan Turing">Alan Turing</a>, <a class="mw-redirect" href="/wiki/Stephen_Kleene" title="Stephen Kleene">Stephen Kleene</a>, <a href="/wiki/R%C3%B3zsa_P%C3%A9ter" title="R\xc3\xb3zsa P\xc3\xa9ter">R\xc3\xb3zsa P\xc3\xa9ter</a>, <a href="/wiki/John_von_Neumann" title="John von Neumann">John von Neumann</a> and <a href="/wiki/Claude_Shannon" title="Claude Shannon">Claude Shannon</a>.\n</p>, <p>Automata theory is the study of abstract machines (or more appropriately, abstract \'mathematical\' machines or systems) and the computational problems that can be solved using these machines. These abstract machines are called automata. Automata comes from the Greek word (\xce\x91\xcf\x85\xcf\x84\xcf\x8c\xce\xbc\xce\xb1\xcf\x84\xce\xb1) which means that something is doing something by itself.\nAutomata theory is also closely related to <a href="/wiki/Formal_language" title="Formal language">formal language</a> theory,<sup class="reference" id="cite_ref-hopcroft-ullman_5-0"><a href="#cite_note-hopcroft-ullman-5">[5]</a></sup> as the automata are often classified by the class of formal languages they are able to recognize. An automaton can be a finite representation of a formal language that may be an infinite set. Automata are used as theoretical models for computing machines, and are used for proofs about computability.\n</p>, <p>Language theory is a branch of mathematics concerned with describing languages as a set of operations over an <a href="/wiki/Alphabet" title="Alphabet">alphabet</a>. It is closely linked with automata theory, as automata are used to generate and recognize formal languages. There are several classes of formal languages, each allowing more complex language specification than the one before it, i.e. <a href="/wiki/Chomsky_hierarchy" title="Chomsky hierarchy">Chomsky hierarchy</a>,<sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup> and each corresponding to a class of automata which recognizes it. Because automata are used as models for computation, formal languages are the preferred mode of specification for any problem that must be computed.\n</p>, <p>Computability theory deals primarily with the question of the extent to which a problem is solvable on a computer. The statement that the <a href="/wiki/Halting_problem" title="Halting problem">halting problem</a> cannot be solved by a Turing machine<sup class="reference" id="cite_ref-7"><a href="#cite_note-7">[7]</a></sup> is one of the most important results in computability theory, as it is an example of a concrete problem that is both easy to formulate and impossible to solve using a Turing machine.  Much of computability theory builds on the halting problem result.\n</p>, <p>Another important step in computability theory was <a href="/wiki/Rice%27s_theorem" title="Rice's theorem">Rice\'s theorem</a>, which states that for all non-trivial properties of partial functions, it is <a href="/wiki/Decidability_(logic)" title="Decidability (logic)">undecidable</a> whether a Turing machine computes a partial function with that property.<sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup>\n</p>, <p>Computability theory is closely related to the branch of <a href="/wiki/Mathematical_logic" title="Mathematical logic">mathematical logic</a> called <a class="mw-redirect" href="/wiki/Recursion_theory" title="Recursion theory">recursion theory</a>, which removes the restriction of studying only models of computation which are reducible to the Turing model.<sup class="reference" id="cite_ref-davis_9-0"><a href="#cite_note-davis-9">[9]</a></sup>  Many mathematicians and computational theorists who study recursion theory will refer to it as computability theory.\n</p>, <p><a href="/wiki/Computational_complexity_theory" title="Computational complexity theory">Complexity theory</a> considers not only whether a problem can be solved at all on a computer, but also how efficiently the problem can be solved.  Two major aspects are considered: time complexity and space complexity, which are respectively how many steps does it take to perform a computation, and how much memory is required to perform that computation.\n</p>, <p>In order to analyze how much time and space a given <a href="/wiki/Algorithm" title="Algorithm">algorithm</a> requires, computer scientists express the time or space required to solve the problem as a function of the size of the input problem.  For example, finding a particular number in a long list of numbers becomes harder as the list of numbers grows larger.  If we say there are <i>n</i> numbers in the list, then if the list is not sorted or indexed in any way we may have to look at every number in order to find the number we\'re seeking.  We thus say that  in order to solve this problem, the computer needs to perform a number of steps that grows linearly in the size of the problem.\n</p>, <p>To simplify this problem, computer scientists have adopted <a href="/wiki/Big_O_notation" title="Big O notation">Big O notation</a>, which allows functions to be compared in a way that ensures that particular aspects of a machine\'s construction do not need to be considered, but rather only the <a href="/wiki/Asymptotic_analysis" title="Asymptotic analysis">asymptotic behavior</a> as problems become large.  So in our previous example we might say that the problem requires <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math alttext="{\\displaystyle O(n)}" xmlns="http://www.w3.org/1998/Math/MathML">\n  <semantics>\n    <mrow class="MJX-TeXAtom-ORD">\n      <mstyle displaystyle="true" scriptlevel="0">\n        <mi>O</mi>\n        <mo stretchy="false">(</mo>\n        <mi>n</mi>\n        <mo stretchy="false">)</mo>\n      </mstyle>\n    </mrow>\n    <annotation encoding="application/x-tex">{\\displaystyle O(n)}</annotation>\n  </semantics>\n</math></span><img alt="O(n)" aria-hidden="true" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a" style="vertical-align: -0.838ex; width:4.977ex; height:2.843ex;"/></span> steps to solve.\n</p>, <p>Perhaps the most important open problem in all of <a href="/wiki/Computer_science" title="Computer science">computer science</a> is the question of whether a certain broad class of problems denoted <a href="/wiki/NP_(complexity)" title="NP (complexity)">NP</a> can be solved efficiently. This is discussed further at <a class="mw-redirect" href="/wiki/P_%3D_NP_problem" title="P = NP problem">Complexity classes P and NP</a>, and <a href="/wiki/P_versus_NP_problem" title="P versus NP problem">P versus NP problem</a> is one of the seven <a href="/wiki/Millennium_Prize_Problems" title="Millennium Prize Problems">Millennium Prize Problems</a> stated by the <a href="/wiki/Clay_Mathematics_Institute" title="Clay Mathematics Institute">Clay Mathematics Institute</a> in 2000. The <a class="external text" href="http://www.claymath.org/sites/default/files/pvsnp.pdf" rel="nofollow">Official Problem Description</a> was given by <a href="/wiki/Turing_Award" title="Turing Award">Turing Award</a> winner <a href="/wiki/Stephen_Cook" title="Stephen Cook">Stephen Cook</a>.\n</p>, <p>Aside from a <a href="/wiki/Turing_machine" title="Turing machine">Turing machine</a>, other equivalent (See: <a href="/wiki/Church%E2%80%93Turing_thesis" title="Church\xe2\x80\x93Turing thesis">Church\xe2\x80\x93Turing thesis</a>) models of computation are in use.\n</p>, <p>In addition to the general computational models, some simpler computational models are useful for special, restricted applications.  <a class="mw-redirect" href="/wiki/Regular_expressions" title="Regular expressions">Regular expressions</a>, for example,  specify string patterns in many contexts, from office productivity software to <a href="/wiki/Programming_language" title="Programming language">programming languages</a>. Another formalism mathematically equivalent to regular expressions, <a class="mw-redirect" href="/wiki/Finite_state_machines" title="Finite state machines">Finite automata</a> are used in circuit design and in some kinds of problem-solving. <a href="/wiki/Context-free_grammar" title="Context-free grammar">Context-free grammars</a>  specify programming language syntax.  Non-deterministic <a href="/wiki/Pushdown_automaton" title="Pushdown automaton">pushdown automata</a> are another formalism equivalent to context-free grammars. <a href="/wiki/Primitive_recursive_function" title="Primitive recursive function">Primitive recursive functions</a> are a defined subclass of the recursive functions.\n</p>, <p>Different models of computation have the ability to do different tasks. One way to measure the power of a computational model is to study the class of <a href="/wiki/Formal_language" title="Formal language">formal languages</a> that the model can generate; in such a way to the <a href="/wiki/Chomsky_hierarchy" title="Chomsky hierarchy">Chomsky hierarchy</a> of languages is obtained.\n</p>, <p>(There are many textbooks in this area; this list is by necessity incomplete.)\n</p>]