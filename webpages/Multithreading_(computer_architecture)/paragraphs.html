[<p>In <a href="/wiki/Computer_architecture" title="Computer architecture">computer architecture</a>, <b>multithreading</b> is the ability of a <a href="/wiki/Central_processing_unit" title="Central processing unit">central processing unit</a> (CPU) (or a single core in a <a href="/wiki/Multi-core_processor" title="Multi-core processor">multi-core processor</a>) to execute multiple <a href="/wiki/Process_(computing)" title="Process (computing)">processes</a> or <a class="mw-redirect" href="/wiki/Thread_(computer_science)" title="Thread (computer science)">threads</a> concurrently, supported by the <a href="/wiki/Operating_system" title="Operating system">operating system</a>. This approach differs from <a href="/wiki/Multiprocessing" title="Multiprocessing">multiprocessing</a>. In a multithreaded application, the processes and threads share the resources of a single or multiple cores, which include the computing units, the <a href="/wiki/CPU_cache" title="CPU cache">CPU caches</a>, and the <a href="/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">translation lookaside buffer</a> (TLB).\n</p>, <p>Where multiprocessing systems include multiple complete processing units in one or more cores, multithreading aims to increase utilization of a single core by using <a class="mw-redirect" href="/wiki/Thread-level_parallelism" title="Thread-level parallelism">thread-level parallelism</a>, as well as <a href="/wiki/Instruction-level_parallelism" title="Instruction-level parallelism">instruction-level parallelism</a>. As the two techniques are complementary, they are sometimes combined in systems with multiple multithreading CPUs and with CPUs with multiple multithreading cores.\n</p>, <p>The multithreading <a href="/wiki/Paradigm" title="Paradigm">paradigm</a> has become more popular as efforts to further exploit <a href="/wiki/Instruction-level_parallelism" title="Instruction-level parallelism">instruction-level parallelism</a> have stalled since the late 1990s. This allowed the concept of <a class="mw-redirect" href="/wiki/Throughput_computing" title="Throughput computing">throughput computing</a> to re-emerge from the more specialized field of <a href="/wiki/Transaction_processing" title="Transaction processing">transaction processing</a>. Even though it is very difficult to further speed up a single thread or single program, most computer systems are actually multitasking among multiple threads or programs. Thus, techniques that improve the throughput of all tasks result in overall performance gains.\n</p>, <p>Two major techniques for throughput computing are <i>multithreading</i> and <i><a href="/wiki/Multiprocessing" title="Multiprocessing">multiprocessing</a></i>.\n</p>, <p>If a thread gets a lot of <a href="/wiki/CPU_cache#Cache_miss" title="CPU cache">cache misses</a>, the other threads can continue taking advantage of the unused computing resources, which may lead to faster overall execution, as these resources would have been idle if only a single thread were executed. Also, if a thread cannot use all the computing resources of the CPU (because instructions depend on each other\'s result), running another thread may prevent those resources from becoming idle.\n</p>, <p>Multiple threads can interfere with each other when sharing hardware resources such as caches or <a href="/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">translation lookaside buffers</a> (TLBs). As a result, execution times of a single thread are not improved and can be degraded, even when only one thread is executing, due to lower frequencies or additional pipeline stages that are necessary to accommodate thread-switching hardware.\n</p>, <p>Overall efficiency varies; Intel claims up to 30% improvement with its <a class="mw-redirect" href="/wiki/Hyper-Threading_Technology" title="Hyper-Threading Technology">Hyper-Threading Technology</a>,<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> while a synthetic program just performing a loop of non-optimized dependent floating-point operations actually gains a 100% speed improvement when run in parallel. On the other hand, hand-tuned <a href="/wiki/Assembly_language" title="Assembly language">assembly language</a> programs using <a href="/wiki/MMX_(instruction_set)" title="MMX (instruction set)">MMX</a> or <a href="/wiki/AltiVec" title="AltiVec">AltiVec</a> extensions and performing data prefetches (as a good video encoder might) do not suffer from cache misses or idle computing resources. Such programs therefore do not benefit from hardware multithreading and can indeed see degraded performance due to contention for shared resources.\n</p>, <p>From the software standpoint, hardware support for multithreading is more visible to software, requiring more changes to both application programs and operating systems than multiprocessing. Hardware techniques used to support <a class="mw-redirect" href="/wiki/Thread_(computer_science)" title="Thread (computer science)">multithreading</a> often parallel the software techniques used for <a class="new" href="/w/index.php?title=Multitasking_of_computer_programs&amp;action=edit&amp;redlink=1" title="Multitasking of computer programs (page does not exist)">computer multitasking</a>. Thread scheduling is also a major problem in multithreading.\n</p>, <p>The simplest type of multithreading occurs when one thread runs until it is blocked by an event that normally would create a long-latency stall. Such a stall might be a cache miss that has to access off-chip memory, which might take hundreds of CPU cycles for the data to return. Instead of waiting for the stall to resolve, a threaded processor would switch execution to another thread that was ready to run. Only when the data for the previous thread had arrived, would the previous thread be placed back on the list of <a href="/wiki/Process_state#Ready" title="Process state">ready-to-run</a> threads.\n</p>, <p>For example:\n</p>, <p>Conceptually, it is similar to cooperative multi-tasking used in <a href="/wiki/Real-time_operating_system" title="Real-time operating system">real-time operating systems</a>, in which tasks voluntarily give up execution time when they need to wait upon some type of the event. This type of multithreading is known as block, cooperative or coarse-grained multithreading.\n</p>, <p>The goal of multithreading hardware support is to allow quick switching between a blocked thread and another thread ready to run. To achieve this goal, the hardware cost is to replicate the program visible registers, as well as some processor control registers (such as the program counter). Switching from one thread to another thread means the hardware switches from using one register set to another; to switch efficiently between active threads, each active thread needs to have its own register set. For example, to quickly switch between two threads, the register hardware needs to be instantiated twice.\n</p>, <p>Additional hardware support for multithreading allows thread switching to be done in one CPU cycle, bringing performance improvements. Also, additional hardware allows each thread to behave as if it were executing alone and not sharing any hardware resources with other threads, minimizing the amount of software changes needed within the application and the operating system to support multithreading.\n</p>, <p>Many families of <a href="/wiki/Microcontroller" title="Microcontroller">microcontrollers</a> and embedded processors have multiple register banks to allow quick <a href="/wiki/Context_switch" title="Context switch">context switching</a> for interrupts. Such schemes can be considered a type of block multithreading among the user program thread and the interrupt threads.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (October 2010)">citation needed</span></a></i>]</sup>\n</p>, <p>The purpose of interleaved multithreading is to remove all <a href="/wiki/Data_dependency" title="Data dependency">data dependency</a> stalls from the execution <a href="/wiki/Pipeline_(computing)" title="Pipeline (computing)">pipeline</a>. Since one thread is relatively independent from other threads, there is less chance of one instruction in one pipelining stage needing an output from an older instruction in the pipeline. Conceptually, it is similar to <a href="/wiki/Preemption_(computing)" title="Preemption (computing)">preemptive</a> multitasking used in operating systems; an analogy would be that the time slice given to each active thread is one CPU cycle.\n</p>, <p>For example:\n</p>, <p>This type of multithreading was first called barrel processing, in which the staves of a barrel represent the pipeline stages and their executing threads. Interleaved, preemptive, fine-grained or time-sliced multithreading are more modern terminology.\n</p>, <p>In addition to the hardware costs discussed in the block type of multithreading, interleaved multithreading has an additional cost of each pipeline stage tracking the thread ID of the instruction it is processing. Also, since there are more threads being executed concurrently in the pipeline, shared resources such as caches and TLBs need to be larger to avoid thrashing between the different threads.\n</p>, <p>The most advanced type of multithreading applies to <a href="/wiki/Superscalar_processor" title="Superscalar processor">superscalar processors</a>. Whereas a normal superscalar processor issues multiple instructions from a single thread every CPU cycle, in simultaneous multithreading (SMT) a superscalar processor can issue instructions from multiple threads every CPU cycle. Recognizing that any single thread has a limited amount of <a href="/wiki/Instruction-level_parallelism" title="Instruction-level parallelism">instruction-level parallelism</a>, this type of multithreading tries to exploit parallelism available across multiple threads to decrease the waste associated with unused issue slots.\n</p>, <p>For example:\n</p>, <p>To distinguish the other types of multithreading from SMT, the term "<a href="/wiki/Temporal_multithreading" title="Temporal multithreading">temporal multithreading</a>" is used to denote when instructions from only one thread can be issued at a time.\n</p>, <p>In addition to the hardware costs discussed for interleaved multithreading, SMT has the additional cost of each pipeline stage tracking the thread ID of each instruction being processed. Again, shared resources such as caches and TLBs have to be sized for the large number of active threads being processed.\n</p>, <p>Implementations include <a href="/wiki/Digital_Equipment_Corporation" title="Digital Equipment Corporation">DEC</a> (later <a href="/wiki/Compaq" title="Compaq">Compaq</a>) <a href="/wiki/Alpha_21464" title="Alpha 21464">EV8</a> (not completed), <a href="/wiki/Intel" title="Intel">Intel</a> <a class="mw-redirect" href="/wiki/Hyper-Threading_Technology" title="Hyper-Threading Technology">Hyper-Threading Technology</a>, <a href="/wiki/IBM" title="IBM">IBM</a> <a href="/wiki/POWER5" title="POWER5">POWER5</a>, <a href="/wiki/Sun_Microsystems" title="Sun Microsystems">Sun Microsystems</a> <a href="/wiki/UltraSPARC_T2" title="UltraSPARC T2">UltraSPARC T2</a>, <a href="/wiki/Cray" title="Cray">Cray</a> <a href="/wiki/Cray_XMT" title="Cray XMT">XMT</a>, and <a class="mw-redirect" href="/wiki/AMD" title="AMD">AMD</a> <a href="/wiki/Bulldozer_(microarchitecture)" title="Bulldozer (microarchitecture)">Bulldozer</a> and <a href="/wiki/Zen_(microarchitecture)" title="Zen (microarchitecture)">Zen</a> microarchitectures.\n</p>, <p>A major area of research is the thread scheduler that must quickly choose from among the list of ready-to-run threads to execute next, as well as maintain the ready-to-run and stalled thread lists. An important subtopic is the different thread priority schemes that can be used by the scheduler. The thread scheduler might be implemented totally in software, totally in hardware, or as a hardware/software combination.\n</p>, <p>Another area of research is what type of events should cause a thread switch: cache misses, inter-thread communication, <a href="/wiki/Direct_memory_access" title="Direct memory access">DMA</a> completion, etc.\n</p>, <p>If the multithreading scheme replicates all of the software-visible state, including privileged control registers and TLBs, then it enables <a href="/wiki/Virtual_machine" title="Virtual machine">virtual machines</a> to be created for each thread. This allows each thread to run its own operating system on the same processor. On the other hand, if only user-mode state is saved, then less hardware is required, which would allow more threads to be active at one time for the same die area or cost.\n</p>]