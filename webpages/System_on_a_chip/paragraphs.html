[<p>A <b>system on a chip</b> or <b>system on chip</b> (<b><abbr title="System on Chip">SoC</abbr>,</b> <span class="nowrap"><span class="IPA nopopups noexcerpt"><a href="/wiki/Help:IPA/English" title="Help:IPA/English">/<span style="border-bottom:1px dotted"><span title="/\xcb\x8c/: secondary stress follows">\xcb\x8c</span><span title="/\xc9\x9b/: 'e' in 'dress'">\xc9\x9b</span><span title="'s' in 'sigh'">s</span><span title="/\xcb\x8c/: secondary stress follows">\xcb\x8c</span><span title="/o\xca\x8a/: 'o' in 'code'">o\xca\x8a</span><span title="/\xcb\x88/: primary stress follows">\xcb\x88</span><span title="'s' in 'sigh'">s</span><span title="/i\xcb\x90/: 'ee' in 'fleece'">i\xcb\x90</span></span>/</a></span></span> <a href="/wiki/Help:Pronunciation_respelling_key" title="Help:Pronunciation respelling key"><i title="English pronunciation respelling">es-oh-<span style="font-size:90%">SEE</span></i></a> or <span class="nowrap"><span class="IPA nopopups noexcerpt"><a href="/wiki/Help:IPA/English" title="Help:IPA/English">/<span style="border-bottom:1px dotted"><span title="'s' in 'sigh'">s</span><span title="/\xc9\x92/: 'o' in 'body'">\xc9\x92</span><span title="'k' in 'kind'">k</span></span>/</a></span></span> <a href="/wiki/Help:Pronunciation_respelling_key" title="Help:Pronunciation respelling key"><i title="English pronunciation respelling">sock</i></a>)<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[nb 1]</a></sup> is an <a href="/wiki/Integrated_circuit" title="Integrated circuit">integrated circuit</a> (also known as a "chip") that integrates all components of a <a href="/wiki/Computer" title="Computer">computer</a> or other <a href="/wiki/Electronics" title="Electronics">electronic system</a>.  These components typically include a <a href="/wiki/Central_processing_unit" title="Central processing unit">central processing unit</a> (CPU), <a href="/wiki/Computer_memory" title="Computer memory">memory</a>, <a href="/wiki/Input/output" title="Input/output">input/output</a> ports and <a href="/wiki/Computer_data_storage#Secondary_storage" title="Computer data storage">secondary storage</a> – all on a single <a href="/wiki/Substrate_(electronics)" title="Substrate (electronics)">substrate</a>.  It may contain <a class="mw-redirect" href="/wiki/Digital_signal_(electronics)" title="Digital signal (electronics)">digital</a>, <a href="/wiki/Analog_signal" title="Analog signal">analog</a>, <a href="/wiki/Mixed-signal_integrated_circuit" title="Mixed-signal integrated circuit">mixed-signal</a>, and often <a href="/wiki/Radio_frequency" title="Radio frequency">radio frequency</a> <a href="/wiki/Signal_processing" title="Signal processing">signal processing</a> functions, depending on the application.  As they are integrated on a single <a href="/wiki/Substrate_(electronics)" title="Substrate (electronics)">electronic substrate</a>, SoCs consume much less power and take up much less area than multi-chip designs with equivalent functionality.  Because of this, SoCs are very common in the <a href="/wiki/Mobile_computing" title="Mobile computing">mobile computing</a> and <a href="/wiki/Edge_computing" title="Edge computing">edge computing</a> markets.<sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[1]</a></sup><sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[2]</a></sup>  Systems on chip are commonly used in <a href="/wiki/Embedded_system" title="Embedded system">embedded systems</a> and the <a href="/wiki/Internet_of_things" title="Internet of things">Internet of Things</a>.\n</p>, <p>Systems on Chip are in contrast to the common traditional <a href="/wiki/Motherboard" title="Motherboard">motherboard</a>-based <a href="/wiki/Personal_computer" title="Personal computer">PC</a> <a href="/wiki/Computer_architecture" title="Computer architecture">architecture</a>, which separates components based on function and connects them through a central interfacing circuit board.<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[nb 2]</a></sup>  Whereas a motherboard houses and connects detachable or replaceable components, SoCs integrate all of these components into a single integrated circuit, as if all these functions were built into the motherboard.  An SoC will typically integrate a CPU, graphics and memory interfaces,<sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[nb 3]</a></sup> hard-disk and USB connectivity,<sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[nb 4]</a></sup> <a href="/wiki/Random-access_memory" title="Random-access memory">random-access</a> and <a href="/wiki/Read-only_memory" title="Read-only memory">read-only</a> <a href="/wiki/Computer_memory" title="Computer memory">memories</a> and secondary storage on a single circuit die, whereas a motherboard would connect these modules as <a class="mw-redirect" href="/wiki/Discrete_components" title="Discrete components">discrete components</a> or <a href="/wiki/Expansion_card" title="Expansion card">expansion cards</a>.\n</p>, <p>More tightly integrated computer system designs improve <a href="/wiki/Computer_performance" title="Computer performance">performance</a> and reduce <a class="mw-redirect" href="/wiki/Power_consumption" title="Power consumption">power consumption</a> as well as <a href="/wiki/Die_(integrated_circuit)" title="Die (integrated circuit)">semiconductor die</a> area needed for an equivalent design composed of discrete modules, at the cost of reduced <a href="/wiki/Interchangeable_parts" title="Interchangeable parts">replaceability</a> of components.  By definition, SoC designs are fully or nearly fully integrated across different component <a href="/wiki/Modularity" title="Modularity">modules</a>.  For these reasons, there has been a general trend towards tighter integration of components in the <a href="/wiki/Semiconductor_industry" title="Semiconductor industry">computer hardware industry</a>, in part due to the influence of SoCs and lessons learned from the mobile and embedded computing markets.  Systems-on-Chip can be viewed as part of a larger trend towards <a href="/wiki/Embedded_system" title="Embedded system">embedded computing</a> and <a href="/wiki/Hardware_acceleration" title="Hardware acceleration">hardware acceleration</a>.\n</p>, <p>\nAn SoC integrates a <a href="/wiki/Microcontroller" title="Microcontroller">microcontroller</a> or <a href="/wiki/Microprocessor" title="Microprocessor">microprocessor</a> with advanced peripherals like <a href="/wiki/Graphics_processing_unit" title="Graphics processing unit">graphics processing unit</a> (GPU), <a href="/wiki/Wi-Fi" title="Wi-Fi">Wi-Fi</a> module, or one or more <a href="/wiki/Coprocessor" title="Coprocessor">coprocessors</a>.  Similar to how a microcontroller integrates a microprocessor with peripheral circuits and memory, an SoC can be seen as integrating a microcontroller with even more advanced <a href="/wiki/Peripheral" title="Peripheral">peripherals</a>.  </p>, <p>In general, there are four distinguishable types of SoCs: \n</p>, <p>Systems-on-chip can be applied to any computing task.  However, they are typically used in mobile computing such as tablets, smartphones, smartwatches and netbooks as well as <a href="/wiki/Embedded_system" title="Embedded system">embedded systems</a> and in applications where previously <a href="/wiki/Microcontroller" title="Microcontroller">microcontrollers</a> would be used. \n</p>, <p>Where previously only microcontrollers could be used, SoCs are rising to prominence in the embedded systems market.  Tighter system integration offers better reliability and <a href="/wiki/Mean_time_between_failures" title="Mean time between failures">mean time between failure</a>, and SoCs offer more advanced functionality and computing power than microcontrollers.<sup class="reference" id="cite_ref-7"><a href="#cite_note-7">[3]</a></sup>  Applications include <a href="/wiki/AI_accelerator" title="AI accelerator">AI acceleration</a>, embedded <a href="/wiki/Machine_vision" title="Machine vision">machine vision</a>,<sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[4]</a></sup> data collection, <a href="/wiki/Telemetry" title="Telemetry">telemetry</a>, vector processing and <a href="/wiki/Ambient_intelligence" title="Ambient intelligence">ambient intelligence</a>.  Often embedded systems-on-chip target the <a href="/wiki/Internet_of_things" title="Internet of things">internet of things</a>, <a href="/wiki/Internet_of_things" title="Internet of things">industrial internet of things</a> and <a href="/wiki/Edge_computing" title="Edge computing">edge computing</a> markets.\n</p>, <p><a href="/wiki/Mobile_computing" title="Mobile computing">Mobile computing</a> based SoCs  typically bundle processors, memories, on-chip <a href="/wiki/Cache_(computing)" title="Cache (computing)">caches</a>, <a class="mw-redirect" href="/wiki/Wireless_networking" title="Wireless networking">wireless networking</a> capabilities and often <a href="/wiki/Digital_camera" title="Digital camera">digital camera</a> hardware and firmware. Some mobile computing SoCs include:\n</p>, <p>Systems-on-chip are being applied to <a href="/wiki/Personal_computer" title="Personal computer">personal computers</a> as of 2018.<sup class="reference" id="cite_ref-:3_10-1"><a href="#cite_note-:3-10">[6]</a></sup>  They are particularly applied to <a href="/wiki/Laptop" title="Laptop">laptops</a> and <a href="/wiki/Tablet_computer" title="Tablet computer">tablet PCs</a>.  Tablet and laptop manufacturers have learned lessons from embedded systems and smartphone markets including about reduced power consumption, better performance and reliability from tighter <a href="/wiki/System_integration" title="System integration">integration</a> of hardware and <a href="/wiki/Firmware" title="Firmware">firmware</a> <a class="mw-redirect" href="/wiki/Module_system" title="Module system">modules</a>, and <a href="/wiki/LTE_(telecommunication)" title="LTE (telecommunication)">LTE</a> and other <a href="/wiki/Wireless_network" title="Wireless network">wireless network</a> communications integrated on chip (integrated <a href="/wiki/Network_interface_controller" title="Network interface controller">network interface controllers</a>).<sup class="reference" id="cite_ref-12"><a href="#cite_note-12">[8]</a></sup>\n</p>, <p><a href="/wiki/ARM_architecture" title="ARM architecture">ARM</a> based: \n</p>, <p><a href="/wiki/X86" title="X86">x86</a> based: \n</p>, <p>An SoC consists of hardware <a class="mw-redirect" href="/wiki/Functional_unit" title="Functional unit">functional units</a>, including <a href="/wiki/Microprocessor" title="Microprocessor">microprocessors</a> that run <a href="/wiki/Computer_program" title="Computer program">software code</a>, as well as a <a class="mw-redirect" href="/wiki/Communications_subsystem" title="Communications subsystem">communications subsystem</a> to connect, control, direct and interface between these functional modules.\n</p>, <p>An SoC must have at least one <a class="mw-redirect" href="/wiki/Processor_core" title="Processor core">processor core</a>, but will typically have more.  Processor cores can be a <a href="/wiki/Microcontroller" title="Microcontroller">microcontroller</a>, <a href="/wiki/Microprocessor" title="Microprocessor">microprocessor</a> (\xce\xbcP),<sup class="reference" id="cite_ref-Furber_ARM_13-0"><a href="#cite_note-Furber_ARM-13">[9]</a></sup> <a href="/wiki/Digital_signal_processor" title="Digital signal processor">digital signal processor</a> (DSP) or <a href="/wiki/Application-specific_instruction_set_processor" title="Application-specific instruction set processor">application-specific instruction set processor</a> (ASIP) core.<sup class="reference" id="cite_ref-:1_14-0"><a href="#cite_note-:1-14">[10]</a></sup>  ASIPs have <a href="/wiki/Instruction_set_architecture" title="Instruction set architecture">instruction sets</a> that are customized for an <a href="/wiki/Application_domain" title="Application domain">application domain</a> and designed to be more efficient than general-purpose instructions for a specific type of workload. <a href="/wiki/Multi-processor_system-on-chip" title="Multi-processor system-on-chip">Multiprocessor SoCs</a> have more than one processor core by definition. \n</p>, <p>Whether single-core, <a href="/wiki/Multi-core_processor" title="Multi-core processor">multi-core</a> or <a class="mw-redirect" href="/wiki/Manycore" title="Manycore">manycore</a>, SoC processor cores typically use <a href="/wiki/Reduced_instruction_set_computer" title="Reduced instruction set computer">RISC</a> instruction set architectures.  RISC architectures are advantageous over <a href="/wiki/Complex_instruction_set_computer" title="Complex instruction set computer">CISC</a> processors for systems-on-chip because they require less digital logic, and therefore less power and area on <a href="/wiki/Die_(integrated_circuit)" title="Die (integrated circuit)">board</a>, and in the <a href="/wiki/Embedded_system" title="Embedded system">embedded</a> and <a href="/wiki/Mobile_computing" title="Mobile computing">mobile</a> computing markets these are often highly constrained.  In particular, SoC processor cores often use the <a href="/wiki/ARM_architecture" title="ARM architecture">ARM architecture</a> because it is a <a href="/wiki/Soft_microprocessor" title="Soft microprocessor">soft processor</a> specified as an <a class="mw-redirect" href="/wiki/IP_core" title="IP core">IP core</a> and more power efficient than <a href="/wiki/X86" title="X86">x86</a>.<sup class="reference" id="cite_ref-Furber_ARM_13-1"><a href="#cite_note-Furber_ARM-13">[9]</a></sup>\n</p>, <p>Systems-on-chip must have <a href="/wiki/Semiconductor_memory" title="Semiconductor memory">semiconductor memory</a> blocks to perform their computation, as do <a href="/wiki/Microcontroller" title="Microcontroller">microcontrollers</a> and other <a href="/wiki/Embedded_system" title="Embedded system">embedded systems</a>.  Depending on the application, SoC memory may form a <a href="/wiki/Memory_hierarchy" title="Memory hierarchy">memory hierarchy</a> and <a href="/wiki/Cache_hierarchy" title="Cache hierarchy">cache hierarchy</a>.  In the mobile computing market, this is common, but in many <a href="/wiki/Low-power_electronics" title="Low-power electronics">low-power</a> embedded microcontrollers this is not necessary.\n</p>, <p>Memory technologies for SoCs include <a href="/wiki/Read-only_memory" title="Read-only memory">read-only memory</a> (ROM), <a href="/wiki/Random-access_memory" title="Random-access memory">random-access memory</a> (RAM), electrically erasable programmable ROM (<a href="/wiki/EEPROM" title="EEPROM">EEPROM</a>) and <a href="/wiki/Flash_memory" title="Flash memory">flash memory</a>.<sup class="reference" id="cite_ref-Furber_ARM_13-2"><a href="#cite_note-Furber_ARM-13">[9]</a></sup>  As in other computer systems, RAM can be subdivided into relatively faster but more expensive <a href="/wiki/Static_random-access_memory" title="Static random-access memory">static RAM</a> (SRAM) and the slower but cheaper <a href="/wiki/Dynamic_random-access_memory" title="Dynamic random-access memory">dynamic RAM</a> (DRAM).  When a SoC has a <a href="/wiki/Cache_(computing)" title="Cache (computing)">cache</a> hierarchy, SRAM will usually be used to implement <a href="/wiki/Processor_register" title="Processor register">processor registers</a> and cores\' <a class="mw-redirect" href="/wiki/L1_cache" title="L1 cache">L1 caches</a> whereas DRAM will be used for lower levels of the cache hierarchy including <a class="mw-redirect" href="/wiki/Main_memory" title="Main memory">main memory</a>.  "Main memory" may be specific to a single processor (which can be <a href="/wiki/Multi-core_processor" title="Multi-core processor">multi-core</a>) when the SoC <a href="/wiki/Multi-processor_system-on-chip" title="Multi-processor system-on-chip">has multiple processors</a>, in which case it is <a href="/wiki/Distributed_memory" title="Distributed memory">distributed memory</a> and must be sent via <a href="#Intermodule_communication">\xc2\xa7 Intermodule communication</a> on-chip to be accessed by a different processor.<sup class="reference" id="cite_ref-:1_14-1"><a href="#cite_note-:1-14">[10]</a></sup>  For further discussion of multi-processing memory issues, see <a href="/wiki/Cache_coherence" title="Cache coherence">cache coherence</a> and <a href="/wiki/Memory_latency" title="Memory latency">memory latency</a>.\n</p>, <p>SoCs include external <a href="/wiki/Electrical_connector" title="Electrical connector">interfaces</a>, typically for <a href="/wiki/Communication_protocol" title="Communication protocol">communication protocols</a>. These are often based upon industry standards such as <a href="/wiki/USB" title="USB">USB</a>, <a class="mw-redirect" href="/wiki/FireWire" title="FireWire">FireWire</a>, <a href="/wiki/Ethernet" title="Ethernet">Ethernet</a>, <a href="/wiki/Universal_synchronous_and_asynchronous_receiver-transmitter" title="Universal synchronous and asynchronous receiver-transmitter">USART</a>, <a href="/wiki/Serial_Peripheral_Interface" title="Serial Peripheral Interface">SPI</a>, <a href="/wiki/HDMI" title="HDMI">HDMI</a>, <a href="/wiki/I%C2%B2C" title="I\xc2\xb2C">I\xc2\xb2C</a>, etc. These interfaces will differ according to the intended application.  <a href="/wiki/Wireless_network" title="Wireless network">Wireless networking</a> protocols such as <a href="/wiki/Wi-Fi" title="Wi-Fi">Wi-Fi</a>, <a href="/wiki/Bluetooth" title="Bluetooth">Bluetooth</a>, <a href="/wiki/6LoWPAN" title="6LoWPAN">6LoWPAN</a> and <a href="/wiki/Near-field_communication" title="Near-field communication">near-field communication</a> may also be supported.\n</p>, <p>When needed, SoCs include <a href="/wiki/Analog_signal" title="Analog signal">analog</a> interfaces including <a href="/wiki/Analog-to-digital_converter" title="Analog-to-digital converter">analog-to-digital</a> and <a href="/wiki/Digital-to-analog_converter" title="Digital-to-analog converter">digital-to-analog converters</a>, often for <a href="/wiki/Signal_processing" title="Signal processing">signal processing</a>.  These may be able to interface with different types of <a href="/wiki/Sensor" title="Sensor">sensors</a> or <a href="/wiki/Actuator" title="Actuator">actuators</a>, including <a href="/wiki/Smart_transducer" title="Smart transducer">smart transducers</a>.  They may interface with application-specific <a href="/wiki/Modularity" title="Modularity">modules</a> or shields.<sup class="reference" id="cite_ref-15"><a href="#cite_note-15">[nb 5]</a></sup>  Or they may be internal to the SoC, such as if an analog sensor is built in to the SoC and its readings must be converted to digital signals for mathematical processing.\n</p>, <p><a href="/wiki/Digital_signal_processor" title="Digital signal processor">Digital signal processor</a> (DSP) cores are often included on systems-on-chip.  They perform <a href="/wiki/Signal_processing" title="Signal processing">signal processing</a> operations in systems-on-chip for <a href="/wiki/Sensor" title="Sensor">sensors</a>, <a href="/wiki/Actuator" title="Actuator">actuators</a>, <a href="/wiki/Data_collection" title="Data collection">data collection</a>, <a href="/wiki/Data_analysis" title="Data analysis">data analysis</a> and multimedia processing. DSP cores typically feature <a href="/wiki/Very_long_instruction_word" title="Very long instruction word">very long instruction word</a> (VLIW) and <a href="/wiki/SIMD" title="SIMD">single instruction, multiple data</a> (SIMD) <a href="/wiki/Instruction_set_architecture" title="Instruction set architecture">instruction set architectures</a>, and are therefore highly amenable to exploiting <a href="/wiki/Instruction-level_parallelism" title="Instruction-level parallelism">instruction-level parallelism</a> through <a href="/wiki/Parallel_processing_(DSP_implementation)" title="Parallel processing (DSP implementation)">parallel processing</a> and <a class="mw-redirect" href="/wiki/Superscalar_execution" title="Superscalar execution">superscalar execution</a>.<sup class="reference" id="cite_ref-:1_14-2"><a href="#cite_note-:1-14">[10]</a></sup><sup class="reference" style="white-space:nowrap;">:<span>4</span></sup>  DSP cores most often feature application-specific instructions, and as such are typically <a class="mw-redirect" href="/wiki/Application-specific_instruction-set_processor" title="Application-specific instruction-set processor">application-specific instruction-set processors</a> (ASIP).  Such application-specific instructions correspond to dedicated hardware <a class="mw-redirect" href="/wiki/Functional_unit" title="Functional unit">functional units</a> that compute those instructions.\n</p>, <p>Typical DSP instructions include <a href="/wiki/Multiply%E2%80%93accumulate_operation" title="Multiply\xe2\x80\x93accumulate operation">multiply-accumulate</a>, <a href="/wiki/Fast_Fourier_transform" title="Fast Fourier transform">Fast Fourier transform</a>, <a class="mw-redirect" href="/wiki/Fused_multiply-accumulate" title="Fused multiply-accumulate">fused multiply-add</a>, and <a href="/wiki/Convolution" title="Convolution">convolutions</a>.\n</p>, <p>As with other computer systems, SoCs require <a href="/wiki/Clock_generator" title="Clock generator">timing sources</a> to generate <a href="/wiki/Clock_signal" title="Clock signal">clock signals</a>, control execution of SoC functions and provide time context to <a href="/wiki/Signal_processing" title="Signal processing">signal processing</a> applications of the SoC, if needed.  Popular time sources are <a class="mw-redirect" href="/wiki/Crystal_oscillators" title="Crystal oscillators">crystal oscillators</a> and <a href="/wiki/Phase-locked_loop" title="Phase-locked loop">phase-locked loops</a>. \n</p>, <p>System-on-chip <a href="/wiki/Peripheral" title="Peripheral">peripherals</a> including <a href="/wiki/Counter_(digital)" title="Counter (digital)">counter</a>-timers, real-time <a href="/wiki/Timer" title="Timer">timers</a> and <a href="/wiki/Power-on_reset" title="Power-on reset">power-on reset</a> generators. SoCs also include <a href="/wiki/Voltage_regulator" title="Voltage regulator">voltage regulators</a> and <a href="/wiki/Power_management" title="Power management">power management</a> circuits.\n</p>, <p>Systems-on-chip comprise many <a href="/wiki/Execution_unit" title="Execution unit">execution units</a>.  These units must often send <a href="/wiki/Data" title="Data">data</a> and <a class="mw-redirect" href="/wiki/Instruction_(computing)" title="Instruction (computing)">instructions</a> back and forth.  Because of this, all but the most trivial SoCs require <a href="/wiki/Communications_system" title="Communications system">communications subsystems</a>.  Originally, as with other <a href="/wiki/Microcomputer" title="Microcomputer">microcomputer</a> technologies, <a href="/wiki/Bus_(computing)" title="Bus (computing)">data bus</a> architectures were used, but recently designs based on sparse intercommunication networks known as <a href="/wiki/Network_on_a_chip" title="Network on a chip">networks-on-chip</a> (NoC) have risen to prominence and are forecast to overtake bus architectures for SoC design in the near future.<sup class="reference" id="cite_ref-:0_16-0"><a href="#cite_note-:0-16">[11]</a></sup>\n</p>, <p>Historically, a shared global <a href="/wiki/Bus_(computing)" title="Bus (computing)">computer bus</a> typically connected the different components, also called "blocks" of the System-on-Chip.<sup class="reference" id="cite_ref-:0_16-1"><a href="#cite_note-:0-16">[11]</a></sup>  A very common bus for system-on-chip communications is ARM\'s royalty-free Advanced Microcontroller Bus Architecture (<a href="/wiki/Advanced_Microcontroller_Bus_Architecture" title="Advanced Microcontroller Bus Architecture">AMBA</a>) standard. \n</p>, <p><a href="/wiki/Direct_memory_access" title="Direct memory access">Direct memory access</a> controllers route data directly between external interfaces and SoC memory, bypassing the CPU or <a href="/wiki/Control_unit" title="Control unit">control unit</a>, thereby increasing the data <a href="/wiki/Throughput" title="Throughput">throughput</a> of the system-on-chip.  This is similar to some <a href="/wiki/Device_driver" title="Device driver">device drivers</a> of peripherals on component-based <a href="/wiki/Multi-chip_module" title="Multi-chip module">multi-chip module</a> PC architectures. \n</p>, <p>Computer buses are limited in <a href="/wiki/Scalability" title="Scalability">scalability</a>, supporting only up to tens of cores (<a class="mw-redirect" href="/wiki/Multicore" title="Multicore">multicore</a>) on a single chip.<sup class="reference" id="cite_ref-:0_16-2"><a href="#cite_note-:0-16">[11]</a></sup><sup class="reference" style="white-space:nowrap;">:<span>xiii</span></sup>  Wire delay is not scalable due to continued <a href="/wiki/Miniaturization" title="Miniaturization">miniaturization</a>, <a href="/wiki/Computer_performance" title="Computer performance">system performance</a> does not scale with the number of cores attached, the SoC\'s <a class="mw-redirect" href="/wiki/Operating_frequency" title="Operating frequency">operating frequency</a> must decrease with each additional core attached for power to be sustainable, and long wires consume large amounts of electrical power. These challenges are prohibitive to supporting <a class="mw-redirect" href="/wiki/Manycore" title="Manycore">manycore</a> systems on chip.<sup class="reference" id="cite_ref-:0_16-3"><a href="#cite_note-:0-16">[11]</a></sup><sup class="reference" style="white-space:nowrap;">:<span>xiii</span></sup>\n</p>, <p>In the late <a href="/wiki/2010s" title="2010s">2010s</a>, a trend of systems-on-chip implementing <a class="mw-redirect" href="/wiki/Communications_subsystem" title="Communications subsystem">communications subsystems</a> in terms of a network-like topology instead of <a href="/wiki/Bus_(computing)" title="Bus (computing)">bus-based</a> protocols has emerged.  A trend towards <a href="/wiki/Multi-processor_system-on-chip" title="Multi-processor system-on-chip">more processor cores on SoCs</a> has caused on-chip communication efficiency to become one of the key factors in determining the overall system performance and cost.<sup class="reference" id="cite_ref-:0_16-4"><a href="#cite_note-:0-16">[11]</a></sup><sup class="reference" style="white-space:nowrap;">:<span>xiii</span></sup>  This has led to the emergence of interconnection networks with <a href="/wiki/Router_(computing)" title="Router (computing)">router</a>-based <a href="/wiki/Packet_switching" title="Packet switching">packet switching</a> known as "<a href="/wiki/Network_on_a_chip" title="Network on a chip">networks on chip</a>" (NoCs) to overcome the <a href="/wiki/Bottleneck_(engineering)" title="Bottleneck (engineering)">bottlenecks</a> of bus-based networks.<sup class="reference" id="cite_ref-:0_16-5"><a href="#cite_note-:0-16">[11]</a></sup><sup class="reference" style="white-space:nowrap;">:<span>xiii</span></sup> \n</p>, <p>Networks-on-chip have advantages including destination- and application-specific <a href="/wiki/Routing" title="Routing">routing</a>, greater power efficiency and reduced possibility of <a href="/wiki/Bus_contention" title="Bus contention">bus contention</a>.  Network-on-chip architectures take inspiration from <a class="mw-redirect" href="/wiki/Networking_protocol" title="Networking protocol">networking protocols</a> like <a href="/wiki/Transmission_Control_Protocol" title="Transmission Control Protocol">TCP</a> and the <a href="/wiki/Internet_protocol_suite" title="Internet protocol suite">Internet protocol suite</a> for on-chip communication,<sup class="reference" id="cite_ref-:0_16-6"><a href="#cite_note-:0-16">[11]</a></sup> although they typically have fewer <a href="/wiki/Network_layer" title="Network layer">network layers</a>.  Optimal network-on-chip <a href="/wiki/Network_architecture" title="Network architecture">network architectures</a> are an ongoing area of much research interest.  NoC architectures range from traditional distributed computing <a href="/wiki/Network_topology" title="Network topology">network topologies</a> such as <a href="/wiki/Torus_interconnect" title="Torus interconnect">torus</a>, <a href="/wiki/Hypercube_internetwork_topology" title="Hypercube internetwork topology">hypercube</a>, <a href="/wiki/Mesh_networking" title="Mesh networking">meshes</a> and <a href="/wiki/Tree_network" title="Tree network">tree networks</a> to <a href="/wiki/Genetic_algorithm_scheduling" title="Genetic algorithm scheduling">genetic algorithm scheduling</a> to <a href="/wiki/Randomized_algorithm" title="Randomized algorithm">randomized algorithms</a> such as <a href="/wiki/Branching_random_walk" title="Branching random walk">random walks with branching</a> and randomized <a href="/wiki/Time_to_live" title="Time to live">time to live</a> (TTL).\n</p>, <p>Many SoC researchers consider NoC architectures to be the future of system-on-chip design because they have been shown to efficiently meet power and throughput needs of SoC designs.  Current NoC architectures are two-dimensional.  2D IC design has limited <a href="/wiki/Floorplan_(microelectronics)" title="Floorplan (microelectronics)">floorplanning</a> choices as the number of cores in SoCs increase, so as <a href="/wiki/Three-dimensional_integrated_circuit" title="Three-dimensional integrated circuit">three-dimensional integrated circuits</a> (3DICs) emerge, SoC designers look to build three-dimensional on-chip networks known as 3DNoCs.<sup class="reference" id="cite_ref-:0_16-7"><a href="#cite_note-:0-16">[11]</a></sup>\n</p>, <p>A system on chip consists of both the <a href="/wiki/Electronic_hardware" title="Electronic hardware">hardware</a>, described in <a href="#Structure">\xc2\xa7 Structure</a>, and the <a href="/wiki/Software" title="Software">software</a> controlling the microcontroller, microprocessor or digital signal processor cores, peripherals and interfaces.  The <a href="/wiki/Design_flow_(EDA)" title="Design flow (EDA)">design flow</a> for an SoC aims to develop this hardware and software at the same time, also known as architectural co-design.  The design flow must also take into account optimizations (<a href="#Optimization_goals">\xc2\xa7 Optimization goals</a>) and constraints.\n</p>, <p>Most SoCs are developed from pre-qualified hardware component <a href="/wiki/Semiconductor_intellectual_property_core" title="Semiconductor intellectual property core">IP core specifications</a> for the hardware elements and <a href="/wiki/Execution_unit" title="Execution unit">execution units</a>, collectively "blocks", described above, together with software <a href="/wiki/Device_driver" title="Device driver">device drivers</a> that may control their operation.  Of particular importance are the <a href="/wiki/Protocol_stack" title="Protocol stack">protocol stacks</a> that drive industry-standard interfaces like <a class="mw-redirect" href="/wiki/Universal_Serial_Bus" title="Universal Serial Bus">USB</a>.  The hardware blocks are put together using <a href="/wiki/Computer-aided_design" title="Computer-aided design">computer-aided design</a> tools, specifically <a href="/wiki/Electronic_design_automation" title="Electronic design automation">electronic design automation</a> tools; the <a href="/wiki/Modular_programming" title="Modular programming">software modules</a> are integrated using a software <a href="/wiki/Integrated_development_environment" title="Integrated development environment">integrated development environment</a>.\n</p>, <p>Systems-on-chip components are also often designed in <a href="/wiki/High-level_programming_language" title="High-level programming language">high-level programming languages</a> such as <a href="/wiki/C%2B%2B" title="C++">C++</a>, <a href="/wiki/MATLAB" title="MATLAB">MATLAB</a> or <a href="/wiki/SystemC" title="SystemC">SystemC</a> and converted to <a href="/wiki/Register-transfer_level" title="Register-transfer level">RTL</a> designs through <a href="/wiki/High-level_synthesis" title="High-level synthesis">high-level synthesis</a> (HLS) tools such as <a href="/wiki/C_to_HDL" title="C to HDL">C to HDL</a> or <a href="/wiki/Flow_to_HDL" title="Flow to HDL">flow to HDL</a>.<sup class="reference" id="cite_ref-17"><a href="#cite_note-17">[12]</a></sup>  HLS products called "algorithmic synthesis" allow designers to use C++ to model and synthesize system, circuit, software and verification levels all in one high level language commonly known to <a class="mw-redirect" href="/wiki/Computer_engineers" title="Computer engineers">computer engineers</a> in a manner independent of time scales, which are typically specified in HDL.<sup class="reference" id="cite_ref-18"><a href="#cite_note-18">[13]</a></sup>  Other components can remain software and be compiled and embedded onto <a href="/wiki/Soft_microprocessor" title="Soft microprocessor">soft-core processors</a> included in the SoC as modules in HDL as <a href="/wiki/Semiconductor_intellectual_property_core" title="Semiconductor intellectual property core">IP cores</a>.\n</p>, <p>Once the <a href="/wiki/Computer_architecture" title="Computer architecture">architecture</a> of the SoC has been defined, any new hardware elements are written in an abstract <a href="/wiki/Hardware_description_language" title="Hardware description language">hardware description language</a> termed <a href="/wiki/Register-transfer_level" title="Register-transfer level">register transfer level</a> (RTL) which defines the circuit behavior, or synthesized into RTL from a high level language through high-level synthesis.  These elements are connected together in a hardware description language to create the full SoC design.  The logic specified to connect these components and convert between possibly different interfaces provided by different vendors is called <a href="/wiki/Glue_logic" title="Glue logic">glue logic</a>.\n</p>, <p>Chips are verified for logical correctness before being sent to a <a href="/wiki/Semiconductor_fabrication_plant" title="Semiconductor fabrication plant">semiconductor foundry</a>.  This process is called <a href="/wiki/Functional_verification" title="Functional verification">functional verification</a> and it accounts for a significant portion of the time and energy expended in the <a class="mw-redirect" href="/wiki/Integrated_circuit_development" title="Integrated circuit development">chip design life cycle</a>, often quoted as 70%.<sup class="reference" id="cite_ref-70%_verification?_19-0"><a href="#cite_note-70%_verification?-19">[14]</a></sup><sup class="reference" id="cite_ref-verification_vs._validation_20-0"><a href="#cite_note-verification_vs._validation-20">[15]</a></sup> With the growing complexity of chips, <a href="/wiki/Hardware_verification_language" title="Hardware verification language">hardware verification languages</a> like <a href="/wiki/SystemVerilog" title="SystemVerilog">SystemVerilog</a>, <a href="/wiki/SystemC" title="SystemC">SystemC</a>, <a href="/wiki/E_(verification_language)" title="E (verification language)">e</a>, and <a href="/wiki/OpenVera" title="OpenVera">OpenVera</a> are being used.  <a href="/wiki/Software_bug" title="Software bug">Bugs</a> found in the verification stage are reported to the designer.\n</p>, <p>Traditionally, engineers have employed simulation acceleration, <a href="/wiki/Emulator" title="Emulator">emulation</a> or prototyping on <a href="/wiki/Reconfigurable_computing" title="Reconfigurable computing">reprogrammable hardware</a> to verify and debug hardware and software for SoC designs prior to the finalization of the design, known as <a href="/wiki/Tape-out" title="Tape-out">tape-out</a>.  <a href="/wiki/Field-programmable_gate_array" title="Field-programmable gate array">Field-programmable gate arrays</a> (FPGAs) are favored for prototyping systems-on-chip because <a href="/wiki/FPGA_prototyping" title="FPGA prototyping">FPGA prototypes</a> are reprogrammable, allow <a href="/wiki/Debugging" title="Debugging">debugging</a> and are more flexible than <a href="/wiki/Application-specific_integrated_circuit" title="Application-specific integrated circuit">application-specific integrated circuits</a> (ASICs).<sup class="reference" id="cite_ref-nm_prototyping_21-0"><a href="#cite_note-nm_prototyping-21">[16]</a></sup><sup class="reference" id="cite_ref-Reason_to_debug_in_FPGA_22-0"><a href="#cite_note-Reason_to_debug_in_FPGA-22">[17]</a></sup> \n</p>, <p>With high capacity and fast compilation time, simulation acceleration and emulation are powerful technologies that provide wide visibility into systems.  Both technologies, however, operate slowly, on the order of MHz, which may be significantly slower \xe2\x80\x93 up to 100 times slower \xe2\x80\x93 than the SoC\'s operating frequency.  Acceleration and emulation boxes are also very large and expensive at over US$1 million.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (May 2018)">citation needed</span></a></i>]</sup> \n</p>, <p>FPGA prototypes, in contrast, use FPGAs directly to enable engineers to validate and test at, or close to, a system\xe2\x80\x99s full operating frequency with real-world stimuli.  Tools such as Certus<sup class="reference" id="cite_ref-23"><a href="#cite_note-23">[18]</a></sup> are used to insert probes in the FPGA RTL that make signals available for observation.  This is used to debug hardware, firmware and software interactions across multiple FPGAs with capabilities similar to a logic analyzer.\n</p>, <p>In parallel, the hardware elements are grouped and passed through a process of <a href="/wiki/Logic_synthesis" title="Logic synthesis">logic synthesis</a>, during which performance constraints, such as operational frequency and expected signal delays, are applied.  This generates an output known as a <a href="/wiki/Netlist" title="Netlist">netlist</a> describing the design as a physical circuit and its interconnections.  These netlists are combined with the <a href="/wiki/Glue_logic" title="Glue logic">glue logic</a> connecting the components to produce the schematic description of the SoC as a circuit which can be <a href="/wiki/Printed_circuit_board" title="Printed circuit board">printed</a> onto a chip.  This process is known as <a href="/wiki/Place_and_route" title="Place and route">place and route</a> and precedes <a href="/wiki/Tape-out" title="Tape-out">tape-out</a> in the event that the SoCs are produced as <a href="/wiki/Application-specific_integrated_circuit" title="Application-specific integrated circuit">application-specific integrated circuits</a> (ASIC).\n</p>, <p>Systems-on-chip must optimize <a class="mw-redirect" href="/wiki/Power_consumption" title="Power consumption">power use</a>, area on <a href="/wiki/Die_(integrated_circuit)" title="Die (integrated circuit)">die</a>, communication, positioning for <a href="/wiki/Locality_of_reference" title="Locality of reference">locality</a> between modular units and other factors.  Optimization is necessarily a design goal of systems-on-chip.  If optimization was not necessary, the engineers would use a <a href="/wiki/Multi-chip_module" title="Multi-chip module">multi-chip module</a> architecture without accounting for the area utilization, power consumption or performance of the system to the same extent.  \n</p>, <p>Common optimization targets for system-on-chip designs follow, with explanations of each.  In general, optimizing any of these quantities may be a hard <a href="/wiki/Combinatorial_optimization" title="Combinatorial optimization">combinatorial optimization</a> problem, and can indeed be <a href="/wiki/NP-hardness" title="NP-hardness">NP-hard</a> fairly easily.  Therefore, sophisticated <a class="mw-redirect" href="/wiki/Optimization_algorithm" title="Optimization algorithm">optimization algorithms</a> are often required and it may be practical to use <a href="/wiki/Approximation_algorithm" title="Approximation algorithm">approximation algorithms</a> or <a href="/wiki/Heuristic_(computer_science)" title="Heuristic (computer science)">heuristics</a> in some cases.  Additionally, most SoC designs contain <a class="mw-redirect" href="/wiki/Multivariate_optimization" title="Multivariate optimization">multiple variables to optimize simultaneously</a>, so <a href="/wiki/Pareto_efficiency" title="Pareto efficiency">Pareto efficient</a> solutions are sought after in SoC design.  Oftentimes the goals of optimizing some of these quantities are directly at odds, further adding complexity to design optimization of systems-on-chip and introducing <a href="/wiki/Trade-off#Engineering" title="Trade-off">trade-offs</a> in system design.\n</p>, <p>For broader coverage of trade-offs and <a href="/wiki/Requirements_analysis" title="Requirements analysis">requirements analysis</a>, see <a href="/wiki/Requirements_engineering" title="Requirements engineering">requirements engineering</a>.\n</p>, <p>Systems-on-chip are optimized to minimize the <a href="/wiki/Electric_power#Definition" title="Electric power">electrical power</a> used to perform the SoC\'s functions.  Most SoCs must use low power.  SoC systems often require long <a class="mw-redirect" href="/wiki/Battery_life" title="Battery life">battery life</a> (such as <a href="/wiki/Smartphone" title="Smartphone">smartphones</a>), can potentially spending months or years without a power source needing to maintain autonomous function, and often are limited in power use by a high number of <a href="/wiki/Embedded_system" title="Embedded system">embedded</a> SoCs being <a href="/wiki/Distributed_computing" title="Distributed computing">networked together</a> in an area.  Additionally, energy costs can be high and conserving energy will reduce the <a href="/wiki/Total_cost_of_ownership" title="Total cost of ownership">total cost of ownership</a> of the SoC.  Finally, <a href="/wiki/Waste_heat" title="Waste heat">waste heat</a> from high energy consumption can damage other circuit components if too much heat is dissipated, giving another pragmatic reason to conserve energy.  The amount of <a href="/wiki/Energy" title="Energy">energy</a> used in a circuit is the <a href="/wiki/Integral" title="Integral">integral</a> of <a href="/wiki/Power_(physics)" title="Power (physics)">power</a> consumed with respect to time, and the <a href="/wiki/Mean_value_theorem" title="Mean value theorem">average rate</a> of power consumption is the product of <a href="/wiki/Electric_current" title="Electric current">current</a> by <a href="/wiki/Voltage" title="Voltage">voltage</a>.  Equivalently, by <a href="/wiki/Ohm%27s_law" title="Ohm's law">Ohm\'s law</a>, power is current squared times resistance or voltage squared divided by <a class="mw-redirect" href="/wiki/Resistance_(physics)" title="Resistance (physics)">resistance</a>: \n</p>, <p><div class="mwe-math-element"><div class="mwe-math-mathml-display mwe-math-mathml-a11y" style="display: none;"><math alttext="{\\displaystyle P=IV={\\frac {V^{2}}{R}}={I^{2}}{R}}" display="block" xmlns="http://www.w3.org/1998/Math/MathML">\n  <semantics>\n    <mrow class="MJX-TeXAtom-ORD">\n      <mstyle displaystyle="true" scriptlevel="0">\n        <mi>P</mi>\n        <mo>=</mo>\n        <mi>I</mi>\n        <mi>V</mi>\n        <mo>=</mo>\n        <mrow class="MJX-TeXAtom-ORD">\n          <mfrac>\n            <msup>\n              <mi>V</mi>\n              <mrow class="MJX-TeXAtom-ORD">\n                <mn>2</mn>\n              </mrow>\n            </msup>\n            <mi>R</mi>\n          </mfrac>\n        </mrow>\n        <mo>=</mo>\n        <mrow class="MJX-TeXAtom-ORD">\n          <msup>\n            <mi>I</mi>\n            <mrow class="MJX-TeXAtom-ORD">\n              <mn>2</mn>\n            </mrow>\n          </msup>\n        </mrow>\n        <mrow class="MJX-TeXAtom-ORD">\n          <mi>R</mi>\n        </mrow>\n      </mstyle>\n    </mrow>\n    <annotation encoding="application/x-tex">{\\displaystyle P=IV={\\frac {V^{2}}{R}}={I^{2}}{R}}</annotation>\n  </semantics>\n</math></div><img alt="{\\displaystyle P=IV={\\frac {V^{2}}{R}}={I^{2}}{R}}" aria-hidden="true" class="mwe-math-fallback-image-display" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b7ea74b4b52b63f4bf75bcf2eaeecd3c8333bb32" style="vertical-align: -2.005ex; width:21.842ex; height:5.843ex;"/></div>Systems-on-chip are frequently embedded in <a href="/wiki/Mobile_device" title="Mobile device">portable devices</a> such as <a class="mw-redirect" href="/wiki/Smartphones" title="Smartphones">smartphones</a>, <a href="/wiki/GPS_navigation_device" title="GPS navigation device">GPS navigation devices</a>, digital <a class="mw-redirect" href="/wiki/Digital_watch" title="Digital watch">watches</a> (including <a href="/wiki/Smartwatch" title="Smartwatch">smartwatches</a>) and <a href="/wiki/Netbook" title="Netbook">netbooks</a>.  Customers want long battery lives for <a href="/wiki/Mobile_computing" title="Mobile computing">mobile computing</a> devices, another reason that power consumption must be minimized in systems-on-chip.  <a class="mw-redirect" href="/wiki/Multimedia_application" title="Multimedia application">Multimedia applications</a> are often executed on these devices, including <a href="/wiki/Video_game" title="Video game">video games</a>, <a class="mw-redirect" href="/wiki/Video_streaming" title="Video streaming">video streaming</a>, <a class="mw-redirect" href="/wiki/Image_processing" title="Image processing">image processing</a>; all of which have grown in <a href="/wiki/Computational_complexity" title="Computational complexity">computational complexity</a> in recent years with user demands and expectations for higher-<a href="/wiki/Video_quality" title="Video quality">quality</a> multimedia.  Computation is more demanding as expectations move towards <a class="mw-redirect" href="/wiki/3D_video" title="3D video">3D video</a> at <a class="mw-redirect" href="/wiki/High_resolution" title="High resolution">high resolution</a> with <a class="mw-redirect" href="/wiki/List_of_video_compression_formats" title="List of video compression formats">multiple standards</a>, so SoCs performing multimedia tasks must be computationally capable platform while being low power to run off a standard mobile battery.<sup class="reference" id="cite_ref-:1_14-3"><a href="#cite_note-:1-14">[10]</a></sup><sup class="reference" style="white-space:nowrap;">:<span>3</span></sup>\n</p>, <p>SoCs are optimized to maximize <a class="mw-redirect" href="/wiki/Power_efficiency" title="Power efficiency">power efficiency</a> in performance per watt: maximize the performance of the SoC given a budget of power usage.  Many applications such as <a href="/wiki/Edge_computing" title="Edge computing">edge computing</a>, <a class="mw-redirect" href="/wiki/Distributed_processing" title="Distributed processing">distributed processing</a> and <a href="/wiki/Ambient_intelligence" title="Ambient intelligence">ambient intelligence</a> require a certain level of <a href="/wiki/Computer_performance" title="Computer performance">computational performance</a>, but power is limited in most SoC environments.  The <a href="/wiki/ARM_architecture" title="ARM architecture">ARM architecture</a> has greater performance per watt than <a href="/wiki/X86" title="X86">x86</a> in embedded systems, so it is preferred over x86 for most SoC applications requiring an <a href="/wiki/Soft_microprocessor" title="Soft microprocessor">embedded processor</a>.\n</p>, <p>SoC designs are optimized to minimize <a href="/wiki/Waste_heat" title="Waste heat">waste heat</a> <a href="/wiki/Dissipation" title="Dissipation">output</a> on the chip.  As with other <a href="/wiki/Integrated_circuit" title="Integrated circuit">integrated circuits</a>, heat generated due to high <a href="/wiki/Power_density" title="Power density">power density</a> are the <a href="/wiki/Bottleneck_(engineering)" title="Bottleneck (engineering)">bottleneck</a> to further <a href="/wiki/Miniaturization" title="Miniaturization">miniaturization</a> of components.<sup class="reference" id="cite_ref-:2_24-0"><a href="#cite_note-:2-24">[19]</a></sup><sup class="reference" style="white-space:nowrap;">:<span>1</span></sup>  The power densities of high speed integrated circuits, particularly microprocessors and including SoCs, have become highly uneven.  Too much waste heat can damage circuits and erode <a href="/wiki/Reliability_(semiconductor)" title="Reliability (semiconductor)">reliability</a> of the circuit over time.  High temperatures and thermal stress negatively impact <a class="extiw" href="https://en.wiktionary.org/wiki/reliability" title="wikt:reliability">reliability</a>, <a href="/wiki/Stress_migration" title="Stress migration">stress migration</a>, decreased <a href="/wiki/Mean_time_between_failures" title="Mean time between failures">mean time between failures</a>, <a href="/wiki/Electromigration" title="Electromigration">electromigration</a>, <a href="/wiki/Wire_bonding" title="Wire bonding">wire bonding</a>, <a href="/wiki/Metastability_(electronics)" title="Metastability (electronics)">metastability</a> and other performance degradation of the SoC over time.<sup class="reference" id="cite_ref-:2_24-1"><a href="#cite_note-:2-24">[19]</a></sup><sup class="reference" style="white-space:nowrap;">:<span>2-9</span></sup>\n</p>, <p>In particular, most SoCs are in a small physical area or volume and therefore the effects of waste heat are compounded because there is little room for it to diffuse out of the system.  Because of high <a href="/wiki/Transistor_count" title="Transistor count">transistor counts</a> on modern devices due to <a href="/wiki/Moore%27s_law" title="Moore's law">Moore\'s law</a>, oftentimes a layout of sufficient throughput and high <a class="mw-redirect" href="/wiki/Transistors_density" title="Transistors density">transistor density</a> is physically realizable from <a href="/wiki/Semiconductor_device_fabrication" title="Semiconductor device fabrication">fabrication processes</a> but would result in unacceptably high amounts of heat in the circuit\'s volume.<sup class="reference" id="cite_ref-:2_24-2"><a href="#cite_note-:2-24">[19]</a></sup><sup class="reference" style="white-space:nowrap;">:<span>1</span></sup> \n</p>, <p>These thermal effects force SoC and other chip designers to apply conservative <a class="mw-redirect" href="/wiki/Design_margin" title="Design margin">design margins</a>, creating less performant devices to mitigate the risk of <a href="/wiki/Catastrophic_failure" title="Catastrophic failure">catastrophic failure</a>.  Due to increased <a class="mw-redirect" href="/wiki/Transistors_density" title="Transistors density">transistor densities</a> as length scales get smaller, each <a class="mw-redirect" href="/wiki/Semiconductor_node" title="Semiconductor node">process generation</a> produces more heat output than the last.  Compounding this problem, system-on-chip architectures are usually heterogeneous, creating spatially inhomogeneous <a href="/wiki/Heat_flux" title="Heat flux">heat fluxes</a>, which are cannot be effectively mitigated by uniform <a href="/wiki/Passive_cooling" title="Passive cooling">passive cooling</a>.<sup class="reference" id="cite_ref-:2_24-3"><a href="#cite_note-:2-24">[19]</a></sup><sup class="reference" style="white-space:nowrap;">:<span>1</span></sup>\n</p>, <p>SoCs are optimized to maximize computational and communications <a href="/wiki/Throughput" title="Throughput">throughput</a>.\n</p>, <p>SoCs are optimized to minimize <a href="/wiki/Latency_(engineering)" title="Latency (engineering)">latency</a> for some or all of their functions.  This can be accomplished by <a href="/wiki/Integrated_circuit_layout" title="Integrated circuit layout">laying out</a> elements with proper proximity and <a href="/wiki/Locality_of_reference" title="Locality of reference">locality</a> to each-other to minimize the interconnection delays and maximize the speed at which data is communicated between modules, <a href="/wiki/Execution_unit" title="Execution unit">functional units</a> and memories.  In general, optimizing to minimize latency is an <a href="/wiki/NP-completeness" title="NP-completeness">NP-complete</a> problem equivalent to the <a href="/wiki/Boolean_satisfiability_problem" title="Boolean satisfiability problem">boolean satisfiability problem</a>.\n</p>, <p>For <a href="/wiki/Task_(computing)" title="Task (computing)">tasks</a> running on processor cores, latency and throughput can be improved with <a href="#Task_scheduling">\xc2\xa7 Task scheduling</a>.  Some tasks run in application-specific hardware units, however, and even task scheduling may not be sufficient to optimize all software-based tasks to meet timing and throughput constraints.\n</p>, <p>Systems on chip are modeled with standard hardware <a href="/wiki/Verification_and_validation" title="Verification and validation">verification and validation</a> techniques, but additional techniques are used to model and optimize SoC design alternatives to make the system optimal with respect to <a href="/wiki/Multiple-criteria_decision_analysis" title="Multiple-criteria decision analysis">multiple-criteria decision analysis</a> on the above optimization targets.\n</p>, <p><a href="/wiki/Scheduling_(computing)" title="Scheduling (computing)">Task scheduling</a> is an important activity in any computer system with multiple <a href="/wiki/Process_(computing)" title="Process (computing)">processes</a> or <a href="/wiki/Thread_(computing)" title="Thread (computing)">threads</a> sharing a single processor core.  It is important to reduce <a href="#Latency">\xc2\xa7 Latency</a> and increase <a href="#Throughput">\xc2\xa7 Throughput</a> for <a href="/wiki/Embedded_software" title="Embedded software">embedded software</a> running on an SoC\'s <a href="#Processor_cores">\xc2\xa7 Processor cores</a>.  Not every important computing activity in a system-on-chip is performed in software running on on-chip processors, but scheduling can drastically improve performance of software-based tasks and other tasks involving <a href="/wiki/Shared_resource" title="Shared resource">shared resources</a>.\n</p>, <p>SoCs often schedule tasks according to <a class="mw-redirect" href="/wiki/Network_scheduling" title="Network scheduling">network scheduling</a> and <a href="/wiki/Stochastic_scheduling" title="Stochastic scheduling">randomized scheduling</a> algorithms.\n</p>, <p>Hardware and software tasks are often pipelined in <a href="/wiki/Processor_design" title="Processor design">processor design</a>.  Pipelining is an important principle for <a href="/wiki/Speedup" title="Speedup">speedup</a> in <a href="/wiki/Computer_architecture" title="Computer architecture">computer architecture</a>.  They are frequently used in <a class="mw-redirect" href="/wiki/GPU" title="GPU">GPUs</a> (<a href="/wiki/Graphics_pipeline" title="Graphics pipeline">graphics pipeline</a>) and RISC processors (evolutions of the <a href="/wiki/Classic_RISC_pipeline" title="Classic RISC pipeline">classic RISC pipeline</a>), but are also applied to application-specific tasks such as <a href="/wiki/Digital_signal_processing" title="Digital signal processing">digital signal processing</a> and multimedia manipulations in the context of systems-on-chip.<sup class="reference" id="cite_ref-:1_14-4"><a href="#cite_note-:1-14">[10]</a></sup>\n</p>, <p>Systems-on-chip are often analyzed though <a class="mw-redirect" href="/wiki/Probabilistic_model" title="Probabilistic model">probabilistic models</a>, <a href="/wiki/Queueing_theory#Queueing_networks" title="Queueing theory">Queueing theory \xc2\xa7 Queueing networks</a> and <a href="/wiki/Markov_chain" title="Markov chain">Markov chains</a>.  For instance, <a href="/wiki/Little%27s_law" title="Little's law">Little\'s law</a> allows SoC states and NoC buffers to be modeled as arrival processes and analyzed through <a class="mw-redirect" href="/wiki/Poisson_random_variable" title="Poisson random variable">Poisson random variables</a> and <a class="mw-redirect" href="/wiki/Poisson_process" title="Poisson process">Poisson processes</a>.\n</p>, <p>SoCs are often modeled with <a href="/wiki/Markov_chain" title="Markov chain">Markov chains</a>, both <a href="/wiki/Markov_chain#Discrete-time_Markov_chain" title="Markov chain">discrete time</a> and <a href="/wiki/Markov_chain#Continuous-time_Markov_chain" title="Markov chain">continuous time</a> variants.  Markov chain modeling allows <a href="/wiki/Asymptotic_analysis" title="Asymptotic analysis">asymptotic analysis</a> of the system-on-chip\'s <a href="/wiki/Markov_chain#Steady-state_analysis_and_limiting_distributions" title="Markov chain">steady state distribution</a> of power, heat, latency and other factors to allow design decisions to be optimized for the common case.\n</p>, <p>The netlists described above are used as the basis for the physical design (<a href="/wiki/Place_and_route" title="Place and route">place and route</a>) flow to convert the designers\' intent into the design of the SoC.  Throughout this conversion process, the design is analyzed with static timing modeling, simulation and other tools to ensure that it meets the specified operational parameters such as frequency, power consumption and dissipation, functional integrity (as described in the register transfer level code) and electrical integrity.\n</p>, <p>When all known bugs have been rectified and these have been re-verified and all physical design checks are done, the physical design files describing each layer of the chip are sent to the foundry\'s mask shop where a full set of glass lithographic masks will be etched.  These are sent to a wafer fabrication plant to create the SoC dice before packaging and testing.\n</p>, <p>SoCs can be fabricated by several technologies, including:\n</p>, <p>ASICs consume less power and are faster than FPGAs but cannot be reprogrammed and are expensive to manufacture. FPGA designs are more suitable for lower volume designs, but after enough units of production ASICs reduce the total cost of ownership.<sup class="reference" id="cite_ref-25"><a href="#cite_note-25">[20]</a></sup> \n</p>, <p>SoC designs consume less power and have a lower cost and higher reliability than the multi-chip systems that they replace. With fewer packages in the system, assembly costs are reduced as well.\n</p>, <p>However, like most <a class="mw-redirect" href="/wiki/Very-large-scale_integration" title="Very-large-scale integration">very-large-scale integration</a> (VLSI) designs, the total cost<sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Please_clarify" title="Wikipedia:Please clarify"><span title="what kind of cost? (May 2018)">clarification needed</span></a></i>]</sup> is higher for one large chip than for the same functionality distributed over several smaller chips, because of <a href="/wiki/Semiconductor_device_fabrication#Device_test" title="Semiconductor device fabrication">lower yields</a><sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Please_clarify" title="Wikipedia:Please clarify"><span title="confusing to non-experts (May 2018)">clarification needed</span></a></i>]</sup> and higher <a href="/wiki/Non-recurring_engineering" title="Non-recurring engineering">non-recurring engineering</a> costs.\n</p>, <p>When it is not feasible to construct an SoC for a particular application, an alternative is a <a href="/wiki/System_in_package" title="System in package">system in package</a> (SiP) comprising a number of chips in a single <a href="/wiki/Chip_carrier" title="Chip carrier">package</a>.  When produced in large volumes, SoC is more cost-effective than SiP because its packaging is simpler.<sup class="reference" id="cite_ref-26"><a href="#cite_note-26">[21]</a></sup> Another reasons SiP may be preferred is <a href="/wiki/Waste_heat" title="Waste heat">waste heat</a> may be too high in a system-on-chip for a given purpose because functional components are too close together, and in an SiP heat will dissipate better from different functional modules being physically further apart.\n</p>, <p>SoC <a href="/wiki/Research_and_development" title="Research and development">research and development</a> often compares many options.  Benchmarks, such as COSMIC,<sup class="reference" id="cite_ref-27"><a href="#cite_note-27">[22]</a></sup> are developed to help such evaluations.\n</p>]