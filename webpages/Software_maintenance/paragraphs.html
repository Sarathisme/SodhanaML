[<p><b>Software maintenance</b> in <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a> is the modification of a software product after delivery to correct faults, to improve performance or other attributes.<sup class="reference" id="cite_ref-iso14764_1-0"><a href="#cite_note-iso14764-1">[1]</a></sup>\n</p>, <p>A common perception of maintenance is that it merely involves fixing <a href="/wiki/Software_bug" title="Software bug">defects</a>. However, one study indicated that over 80% of maintenance effort is used for non-corrective actions.<sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup> This perception is perpetuated by users submitting problem reports that in reality are functionality enhancements to the system.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (January 2015)">citation needed</span></a></i>]</sup> More recent studies put the bug-fixing proportion closer to 21%.<sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup>\n</p>, <p>Software maintenance and <a href="/wiki/Software_evolution" title="Software evolution">evolution</a> of systems was first addressed by <a class="mw-redirect" href="/wiki/Meir_M._Lehman" title="Meir M. Lehman">Meir M. Lehman</a> in 1969. Over a period of twenty years, his research led to the formulation of <a href="/wiki/Software_evolution#Lehman's_Laws_of_Software_Evolution" title="Software evolution">Lehman\'s Laws</a> (Lehman 1997). Key findings of his research include that maintenance is really evolutionary development and that maintenance decisions are aided by understanding what happens to systems (and software) over time. Lehman demonstrated that systems continue to evolve over time. As they evolve, they grow more complex unless some action such as <a href="/wiki/Code_refactoring" title="Code refactoring">code refactoring</a> is taken to reduce the complexity.\n</p>, <p>In the late 1970s, a famous and widely cited survey study by Lientz and Swanson, exposed the very high fraction of <a href="/wiki/Whole-life_cost" title="Whole-life cost">life-cycle costs</a> that were being expended on maintenance. They categorized maintenance activities into four classes:\n</p>, <p>The survey showed that around 75% of the maintenance effort was on the first two types, and error correction consumed about 21%. Many subsequent studies suggest a similar magnitude of the problem. Studies show that contribution of end user is crucial during the new requirement data gathering and analysis. And this is the main cause of any problem during software evolution and maintenance. So software maintenance is important because it consumes a large part of the overall lifecycle costs and also the inability to change software quickly and reliably means that business opportunities are lost.\n<sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup>\n<sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup>\n<sup class="reference" id="cite_ref-7"><a href="#cite_note-7">[7]</a></sup>\n</p>, <p>The key software maintenance issues are both managerial and technical. Key management issues are: alignment with customer priorities, staffing, which organization does maintenance, estimating costs. Key technical issues are: limited understanding, <a href="/wiki/Change_impact_analysis" title="Change impact analysis">impact analysis</a>, testing, maintainability measurement.\n</p>, <p>Software maintenance is a very broad activity that includes error correction, enhancements of capabilities, deletion of obsolete capabilities, and optimization. Because change is inevitable, mechanisms must be developed for evaluation, controlling and making modifications.\n</p>, <p>So any work done to change the software after it is in operation is considered to be maintenance work.\nThe purpose is to preserve the value of software over the time. The value can be enhanced by expanding the customer base, meeting additional requirements, becoming easier to  use, more efficient and employing newer technology. Maintenance may span for 20 years,<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (October 2018)">citation needed</span></a></i>]</sup> whereas development may be 1\xe2\x80\x932 years.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (October 2018)">citation needed</span></a></i>]</sup>\n</p>, <p>An integral part of software is the maintenance one, which requires an accurate maintenance plan to be prepared during the software development. It should specify how users will request modifications or report problems. The budget should include resource and cost estimates. A new decision should be addressed for the developing of every new system feature and its quality objectives. The software maintenance, which can last for 5\xe2\x80\x936 years (or even decades) after the development process, calls for an effective plan which can address the scope of software maintenance, the tailoring of the post delivery/deployment process, the designation of who will provide maintenance, and an estimate of the life-cycle costs. The selection of proper enforcement of standards is the challenging task right from early stage of software engineering which has not got definite importance by the concerned stakeholders.\n</p>, <p>This section describes the six software maintenance processes as:\n</p>, <p>There are a number of processes, activities and practices that are unique to maintainers, for example:\n</p>, <p>E.B. Swanson initially identified three categories of maintenance: corrective, adaptive, and perfective.<sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup> The <b>IEEE 1219</b> standard was superseded in June 2010 by <b>P14764</b>.<sup class="reference" id="cite_ref-9"><a href="#cite_note-9">[9]</a></sup>\nThese have since been updated and ISO/IEC 14764 presents:\n</p>, <p>There is also a notion of pre-delivery/pre-release maintenance which is all the good things you do to lower the total cost of ownership of the software.  Things like compliance with coding standards that includes software maintainability goals. The management of coupling and cohesion of the software.  The attainment of software supportability goals (SAE JA1004, JA1005 and JA1006 for example).  Note also that some academic institutions<sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Manual_of_Style/Words_to_watch#Unsupported_attributions" title="Wikipedia:Manual of Style/Words to watch"><span title="The material near this tag possibly uses too-vague attribution or weasel words. (January 2015)">who?</span></a></i>]</sup> are carrying out research to quantify the cost to ongoing software maintenance due to the lack of resources such as design documents and system/software comprehension training and resources (multiply costs by approx. 1.5-2.0 where there is no design data available).\n</p>, <p>Impact of key adjustment factors on maintenance (sorted in order of maximum positive impact)\n</p>, <p>Not only are error-prone modules troublesome, but many other factors can degrade performance too. For example, very complex \xe2\x80\x9cspaghetti code\xe2\x80\x9d is quite difficult to maintain safely.\nA very common situation which often degrades performance is lack of suitable maintenance tools, such as defect tracking software, change management software, and test library software. Below describe some of the factors and the range of impact on software maintenance.\n</p>, <p>Impact of key adjustment factors on maintenance (sorted in order of maximum negative impact)\n</p>, <p><sup class="reference" id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup>\n</p>, <p><sup class="reference" id="cite_ref-11"><a href="#cite_note-11">[11]</a></sup> \n</p>]