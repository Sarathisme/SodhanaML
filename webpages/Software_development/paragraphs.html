[<p><b>Software development</b> is the process of conceiving, specifying, designing, <a class="mw-redirect" href="/wiki/Computer_programmer" title="Computer programmer">programming</a>, <a href="/wiki/Software_documentation" title="Software documentation">documenting</a>, <a href="/wiki/Software_testing" title="Software testing">testing</a>, and <a class="mw-redirect" href="/wiki/Software_bugs" title="Software bugs">bug fixing</a> involved in creating and maintaining <a href="/wiki/Application_software" title="Application software">applications</a>, <a href="/wiki/Software_framework" title="Software framework">frameworks</a>, or other software components. Software development is a process of writing and <a href="/wiki/Software_maintenance" title="Software maintenance">maintaining</a> the <a href="/wiki/Source_code" title="Source code">source code</a>, but in a broader sense, it includes all that is involved between the conception of the desired software through to the final manifestation of the software, sometimes in a planned and <a href="/wiki/Software_development_process" title="Software development process">structured</a> process.<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup> Therefore, software development may include research, new development, prototyping, modification, reuse, re-engineering, maintenance, or any other activities that result in software products.<sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup>\n</p>, <p>Software can be developed for a variety of purposes, the three most common being to meet specific needs of a specific client/business (the case with <a href="/wiki/Custom_software" title="Custom software">custom software</a>), to meet a perceived need of some set of potential <a href="/wiki/User_(computing)" title="User (computing)">users</a> (the case with <a href="/wiki/Commercial_software" title="Commercial software">commercial</a> and <a class="mw-redirect" href="/wiki/Open_source_software" title="Open source software">open source software</a>), or for personal use (e.g. a scientist may write software to automate a mundane task). <b>Embedded software development</b>, that is, the development of <a href="/wiki/Embedded_software" title="Embedded software">embedded software</a>, such as used for controlling consumer products, requires the development process to be <a href="/wiki/System_integration" title="System integration">integrated</a> with the development of the controlled physical product.  <a href="/wiki/System_software" title="System software">System software</a> underlies applications and the programming process itself, and is often developed separately.\n</p>, <p>The need for better <a href="/wiki/Quality_control" title="Quality control">quality control</a> of the software development process has given rise to the discipline of <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a>, which aims to apply the systematic approach exemplified in the <a href="/wiki/Engineering" title="Engineering">engineering</a> paradigm to the process of software development.\n</p>, <p>There are many approaches to software project management, known as software development life cycle models, methodologies, processes, or models. The <a href="/wiki/Waterfall_model" title="Waterfall model">waterfall model</a> is a traditional version, contrasted with the more recent innovation of <a href="/wiki/Agile_software_development" title="Agile software development">agile software development</a>.\n</p>, <p>A <a href="/wiki/Software_development_process" title="Software development process">software development process</a> (also known as a software development methodology, model, or life cycle) is a framework that is used to <a href="/wiki/Structure" title="Structure">structure</a>, <a href="/wiki/Plan" title="Plan">plan</a>, and control the process of developing <a href="/wiki/Information_system" title="Information system">information systems</a>. A wide variety of such frameworks has evolved over the years, each with its own recognized strengths and weaknesses. There are several different approaches to software development: some take a more structured, engineering-based approach to developing business solutions, whereas others may take a more incremental approach, where software evolves as it is developed piece-by-piece. One system development methodology is not necessarily suitable for use by all projects. Each of the available methodologies is best suited to specific kinds of projects, based on various technical, organizational, project and team considerations.\n</p>, <p>Most methodologies share some combination of the following stages of software development:\n</p>, <p>These stages are often referred to collectively as the software development life-cycle, or SDLC. Different approaches to software development may carry out these stages in different orders, or devote more or less time to different stages. The level of detail of the documentation produced at each stage of software development may also vary. These stages may also be carried out in turn (a \xe2\x80\x9cwaterfall\xe2\x80\x9d based approach), or they may be repeated over various cycles or iterations (a more "extreme" approach). The more extreme approach usually involves less time spent on planning and documentation, and more time spent on coding and development of automated tests. More \xe2\x80\x9cextreme\xe2\x80\x9d approaches also promote continuous testing throughout the development life-cycle, as well as having a working (or bug-free) product at all times. More structured or \xe2\x80\x9c<a href="/wiki/Waterfall_model" title="Waterfall model">waterfall</a>\xe2\x80\x9d based approaches attempt to assess the majority of risks and develop a detailed plan for the software before  <a href="/wiki/Implementation" title="Implementation">implementation</a> (coding) begins, and avoid significant design changes and re-coding in later stages of the software development life-cycle planning.\n</p>, <p>There are significant advantages and disadvantages to the various methodologies, and the best approach to solving a problem using software will often depend on the type of problem. If the problem is well understood and a solution can be effectively planned out ahead of time, the more "waterfall" based approach may work the best. If, on the other hand, the problem is unique (at least to the development team) and the structure of the software solution cannot be easily envisioned, then a more "extreme" incremental approach may work best.\n</p>, <p>The sources of ideas for software products are plentiful. These ideas can come from <a href="/wiki/Market_research" title="Market research">market research</a> including the <a class="mw-redirect" href="/wiki/Demographics" title="Demographics">demographics</a> of potential new customers, existing customers, sales prospects who rejected the product, other internal software development staff, or a creative third party. Ideas for software products are usually first evaluated by <a href="/wiki/Marketing" title="Marketing">marketing</a> personnel for economic feasibility, for fit with existing channels distribution, for possible effects on existing product lines, required <a href="/wiki/Software_feature" title="Software feature">features</a>, and for fit with the company\'s marketing objectives. In a marketing evaluation phase, the cost and time assumptions become evaluated. A decision is reached early in the first phase as to whether, based on the more detailed information generated by the marketing and development staff, the project should be pursued further.<sup class="reference" id="cite_ref-Mor01_3-0"><a href="#cite_note-Mor01-3">[3]</a></sup>\n</p>, <p>In the book <i>"Great Software Debates"</i>, <a href="/wiki/Alan_M._Davis" title="Alan M. Davis">Alan M. Davis</a> states in the chapter <i>"Requirements"</i>, sub-chapter <i>"The Missing Piece of Software Development"</i>\n</p>, <p>Students of engineering learn engineering and are rarely exposed to finance or marketing. Students of marketing learn marketing and are rarely exposed to finance or engineering. Most of us become specialists in just one area. To complicate matters, few of us meet interdisciplinary people in the workforce, so there are few roles to mimic. Yet, software product planning is critical to the development success and absolutely requires knowledge of multiple disciplines.<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup></p>, <p>Because software development may involve compromising or going beyond what is required by the client, a software development project may stray into less technical concerns such as <a href="/wiki/Human_resources" title="Human resources">human resources</a>, <a href="/wiki/Risk_management" title="Risk management">risk management</a>, <a href="/wiki/Intellectual_property" title="Intellectual property">intellectual property</a>, <a class="mw-redirect" href="/wiki/Budgeting" title="Budgeting">budgeting</a>, <a href="/wiki/Crisis_management" title="Crisis management">crisis management</a>, etc. These processes may also cause the role of <a href="/wiki/Business_development" title="Business development">business development</a> to overlap with software development.\n</p>, <p>Planning is an objective of each and every activity, where we want to discover things that belong to the project.\nAn important task in creating a software program is extracting the <a href="/wiki/Requirement" title="Requirement">requirements</a> or <a href="/wiki/Requirements_analysis" title="Requirements analysis">requirements analysis</a>.<sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup> Customers typically have an abstract idea of what they want as an end result but do not know what <i>software</i> should do. Skilled and experienced software engineers recognize incomplete, ambiguous, or even contradictory requirements at this point.  Frequently demonstrating live code may help reduce the risk that the requirements are incorrect.\n</p>, <p>"Although much effort is put in the requirements phase to ensure that requirements are complete and consistent, rarely that is the case; leaving the software design phase as the most influential one when it comes to minimizing the effects of new or changing requirements. Requirements volatility is challenging because they impact future or already going development efforts."<sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup>\n</p>, <p>Once the general requirements are gathered from the client, an analysis of the scope of the development should be determined and clearly stated.  This is often called a scope document.\n</p>, <p>Once the requirements are established, the design of the software can be established in a <a class="mw-redirect" href="/wiki/Software_design_document" title="Software design document">software design document</a>.  This involves a preliminary or <a href="/wiki/High-level_design" title="High-level design">high-level design</a> of the main modules with an overall picture (such as a <a href="/wiki/Block_diagram" title="Block diagram">block diagram</a>) of how the parts fit together.  The language, operating system, and hardware components should all be known at this time.  Then a detailed or low-level design is created, perhaps with <a href="/wiki/Software_prototyping" title="Software prototyping">prototyping</a> as proof-of-concept or to firm up requirements.\n</p>, <p><a href="/wiki/Implementation" title="Implementation">Implementation</a> is the part of the process where <a href="/wiki/Software_engineering" title="Software engineering">software engineers</a> actually <a href="/wiki/Computer_programming" title="Computer programming">program</a> the code for the project.\n</p>, <p><a href="/wiki/Software_testing" title="Software testing">Software testing</a> is an integral and important phase of the software development process. This part of the process ensures that <a href="/wiki/Software_bug" title="Software bug">defects</a> are recognized as soon as possible. In some processes, generally known as <a href="/wiki/Test-driven_development" title="Test-driven development">test-driven development</a>, tests may be developed just before implementation and serve as a guide for the implementation\'s correctness.\n</p>, <p><a href="/wiki/Software_documentation" title="Software documentation">Documenting</a> the internal design of software for the purpose of future maintenance and enhancement is done throughout development. This may also include the writing of an <a class="mw-redirect" href="/wiki/API" title="API">API</a>, be it external or internal. The software engineering process chosen by the developing team will determine how much internal documentation (if any) is necessary. Plan-driven models (e.g., <a href="/wiki/Waterfall_model" title="Waterfall model">Waterfall</a>) generally produce more documentation than <a href="/wiki/Agile_software_development" title="Agile software development">Agile</a> models.\n</p>, <p><a href="/wiki/Software_deployment" title="Software deployment">Deployment</a> starts directly after the code is appropriately tested, approved for <a class="mw-redirect" href="/wiki/Software_release" title="Software release">release</a>, and sold or otherwise distributed into a production environment. This may involve installation, customization (such as by setting parameters to the customer\'s values), testing, and possibly an extended period of evaluation.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (December 2011)">citation needed</span></a></i>]</sup>\n</p>, <p>Software training and <a href="/wiki/Technical_support" title="Technical support">support</a> is important, as software is only effective if it is used correctly.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (June 2018)">citation needed</span></a></i>]</sup>\n</p>, <p><a href="/wiki/Software_maintenance" title="Software maintenance">Maintaining</a> and enhancing software to cope with newly discovered <a href="/wiki/Software_bug" title="Software bug">faults</a> or requirements can take substantial time and effort, as missed requirements may force redesign of the software.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (December 2011)">citation needed</span></a></i>]</sup>\n</p>, <p>A <a href="/wiki/View_model" title="View model">view model</a> is a framework that provides the <a href="/wiki/View_model" title="View model">viewpoints</a> on the <a href="/wiki/System" title="System">system</a> and its <a href="/wiki/Environment_(systems)" title="Environment (systems)">environment</a>, to be used in the <a href="/wiki/Software_development_process" title="Software development process">software development process</a>. It is a graphical representation of the underlying semantics of a view.\n</p>, <p>The purpose of viewpoints and views is to enable human engineers to comprehend very <a href="/wiki/Complex_system" title="Complex system">complex systems</a> and to organize the elements of the problem and the solution around domains of <a class="mw-redirect" href="/wiki/Expertise" title="Expertise">expertise</a>. In the <a href="/wiki/Engineering" title="Engineering">engineering</a> of physically intensive systems, viewpoints often correspond to capabilities and responsibilities within the engineering organization.<sup class="reference" id="cite_ref-NIST2003_7-0"><a href="#cite_note-NIST2003-7">[7]</a></sup>\n</p>, <p>Most complex system specifications are so extensive that no one individual can fully comprehend all aspects of the specifications. Furthermore, we all have different interests in a given system and different reasons for examining the <a href="/wiki/System" title="System">system</a>\'s <a class="mw-redirect" href="/wiki/Specification" title="Specification">specifications</a>. A <a href="/wiki/Business" title="Business">business</a> executive will ask different questions of a system make-up than would a system implementer. The concept of viewpoints framework, therefore, is to provide separate viewpoints into the specification of a given complex system. These viewpoints each satisfy an audience with interest in some set of aspects of the system. Associated with each viewpoint is a viewpoint language\nthat optimizes the vocabulary and presentation for the audience of that viewpoint.\n</p>, <p><a class="mw-redirect" href="/wiki/Information_visualisation" title="Information visualisation">Graphical representation</a> of the current state of information provides a very effective means for presenting information to both users and system <a href="/wiki/Software_developer" title="Software developer">developers</a>.\n</p>, <p>Usually, a model is created after conducting an interview, referred to as <a href="/wiki/Business_analysis" title="Business analysis">business analysis</a>. The interview consists of a facilitator asking a series of questions designed to extract required information that describes a process. The interviewer is called a facilitator to emphasize that it is the participants who provide the information. The facilitator should have some knowledge of the process of interest, but this is not as important as having a structured methodology by which the questions are asked of the process expert. The methodology is\nimportant because usually a team of facilitators is collecting information across the facility and the results of the information from all the interviewers must fit together once completed.<sup class="reference" id="cite_ref-SS93_8-2"><a href="#cite_note-SS93-8">[8]</a></sup>\n</p>, <p>The models are developed as defining either the current state of the process, in which case the final product is called the "as-is" snapshot model, or a collection of ideas of what the process should contain, resulting in a "what-can-be" model. Generation of process and data models can be used to determine if the existing processes and information systems are sound and only need minor modifications or enhancements, or if re-engineering is required as a corrective action. The creation of business models is more than a way to view or automate your information process. Analysis can be used to fundamentally reshape the way your business or organization conducts its operations.<sup class="reference" id="cite_ref-SS93_8-3"><a href="#cite_note-SS93-8">[8]</a></sup>\n</p>, <p><a href="/wiki/Computer-aided_software_engineering" title="Computer-aided software engineering">Computer-aided software engineering</a> (CASE), in the field <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a>, is the scientific application of a set of software tools and methods to the development of <a href="/wiki/Software" title="Software">software</a> which results in high-quality, defect-free, and maintainable software products.<sup class="reference" id="cite_ref-9"><a href="#cite_note-9">[9]</a></sup> It also refers to methods for the development of <a href="/wiki/Information_system" title="Information system">information systems</a> together with automated tools that can be used in the software development process.<sup class="reference" id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup> The term "computer-aided software engineering" (CASE) can refer to the <a href="/wiki/Software" title="Software">software</a> used for the automated development of <a class="mw-redirect" href="/wiki/Systems_software" title="Systems software">systems software</a>, i.e., computer code. The CASE functions include analysis, design, and programming. CASE tools automate methods for designing, documenting, and producing structured computer code in the desired <a href="/wiki/Programming_language" title="Programming language">programming language</a>.<sup class="reference" id="cite_ref-11"><a href="#cite_note-11">[11]</a></sup>\n</p>, <p>Two key ideas of Computer-aided Software System Engineering (CASE) are:<sup class="reference" id="cite_ref-12"><a href="#cite_note-12">[12]</a></sup>\n</p>, <p>Typical CASE tools exist for <a href="/wiki/Configuration_management" title="Configuration management">configuration management</a>, <a href="/wiki/Data_modeling" title="Data modeling">data modeling</a>, <a href="/wiki/Model_transformation" title="Model transformation">model transformation</a>, <a class="mw-redirect" href="/wiki/Refactoring" title="Refactoring">refactoring</a>, <a class="mw-redirect" href="/wiki/Source_code_generation" title="Source code generation">source code generation</a>.\n</p>, <p>An <a href="/wiki/Integrated_development_environment" title="Integrated development environment">integrated development environment</a> (IDE) also known as <i>integrated design environment</i> or <i>integrated debugging environment</i> is a <a class="mw-redirect" href="/wiki/Software_application" title="Software application">software application</a> that provides comprehensive facilities to <a class="mw-redirect" href="/wiki/Computer_programmer" title="Computer programmer">computer programmers</a> for software development. An IDE normally consists of a:\n</p>, <p>IDEs are designed to maximize programmer productivity by providing tight-knit components with similar <a href="/wiki/User_interface" title="User interface">user interfaces</a>. Typically an IDE is dedicated to a specific <a href="/wiki/Programming_language" title="Programming language">programming language</a>, so as to provide a feature set which most closely matches the <a href="/wiki/Programming_paradigm" title="Programming paradigm">programming paradigms</a> of the language.\n</p>, <p>A <a href="/wiki/Modeling_language" title="Modeling language">modeling language</a> is any <a href="/wiki/Artificial_language" title="Artificial language">artificial language</a> that can be used to express <a href="/wiki/Information" title="Information">information</a> or <a href="/wiki/Knowledge" title="Knowledge">knowledge</a> or <a href="/wiki/System" title="System">systems</a> in a <a href="/wiki/Structure" title="Structure">structure</a> that is defined by a consistent set of rules. The rules are used for interpretation of the meaning of components in the structure. A modeling language can be graphical or textual.<sup class="reference" id="cite_ref-13"><a href="#cite_note-13">[13]</a></sup> Graphical modeling languages use a <a class="mw-redirect" href="/wiki/Diagramming_technique" title="Diagramming technique">diagram techniques</a> with named symbols that represent concepts and lines that connect the symbols and that represent relationships and various other graphical annotation to represent constraints. Textual modeling languages typically use standardised keywords accompanied by parameters to make computer-interpretable expressions.\n</p>, <p>Examples of graphical modelling languages in the field of software engineering are:\n</p>, <p>Not all modeling languages are executable, and for those that are, using them doesn\'t necessarily mean that programmers are no longer needed. On the contrary, executable modeling languages are intended to amplify the productivity of skilled programmers, so that they can address more difficult problems, such as <a href="/wiki/Parallel_computing" title="Parallel computing">parallel computing</a> and <a class="mw-redirect" href="/wiki/Distributed_system" title="Distributed system">distributed systems</a>.\n</p>, <p>A <a href="/wiki/Programming_paradigm" title="Programming paradigm">programming paradi</a><a href="/wiki/Programming_paradigm" title="Programming paradigm">gm</a> is a fundamental style of <a href="/wiki/Computer_programming" title="Computer programming">computer programming</a>, which is not generally dictated by the project management methodology (such as waterfall or agile). Paradigms differ in the concepts and abstractions used to represent the elements of a program (such as objects, functions, variables, constraints) and the steps that comprise a computation (such as assignations, evaluation, continuations, data flows).  Sometimes the concepts asserted by the paradigm are utilized cooperatively in high-level system architecture design; in other cases, the programming paradigm\'s scope is limited to the internal structure of a particular program or module.\n</p>, <p>A <a href="/wiki/Programming_language" title="Programming language">programming language</a> can support <a class="mw-redirect" href="/wiki/Multi-paradigm_programming_language" title="Multi-paradigm programming language">multiple paradigms</a>. For example, programs written in <a href="/wiki/C%2B%2B" title="C++">C++</a> or <a href="/wiki/Object_Pascal" title="Object Pascal">Object Pascal</a> can be purely <a href="/wiki/Procedural_programming" title="Procedural programming">procedural</a>, or purely <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented</a>, or contain elements of both paradigms. Software designers and programmers decide how to use those paradigm elements. In <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>, programmers can think of a program as a collection of interacting objects, while in <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a> a program can be thought of as a sequence of stateless function evaluations. When programming computers or systems with many processors, <a href="/wiki/Process-oriented_programming" title="Process-oriented programming">process-oriented programming</a> allows programmers to think about applications as sets of concurrent processes acting upon logically shared <a class="mw-redirect" href="/wiki/Data_structures" title="Data structures">data structures</a>.\n</p>, <p>Just as different groups in <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a> advocate different <i>methodologies</i>, different <a href="/wiki/Programming_language" title="Programming language">programming languages</a> advocate different <i>programming paradigms</i>. Some languages are designed to support one paradigm (<a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a> supports object-oriented programming, <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a> supports functional programming), while other programming languages support multiple paradigms (such as <a href="/wiki/Object_Pascal" title="Object Pascal">Object Pascal</a>, <a href="/wiki/C%2B%2B" title="C++">C++</a>, <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>, <a href="/wiki/Visual_Basic" title="Visual Basic">Visual Basic</a>, <a href="/wiki/Common_Lisp" title="Common Lisp">Common Lisp</a>, <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme</a>, <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a>, <a href="/wiki/Ruby_(programming_language)" title="Ruby (programming language)">Ruby</a>, and <a href="/wiki/Oz_(programming_language)" title="Oz (programming language)">Oz</a>).\n</p>, <p>Many programming paradigms are as well known for what methods they <i>forbid</i> as for what they enable. For instance, pure functional programming forbids using <a class="mw-redirect" href="/wiki/Side-effect_(computer_science)" title="Side-effect (computer science)">side-effects</a>; <a href="/wiki/Structured_programming" title="Structured programming">structured programming</a> forbids using <a href="/wiki/Goto" title="Goto">goto</a> statements. Partly for this reason, new paradigms are often regarded as doctrinaire or overly rigid by those accustomed to earlier styles.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (January 2008)">citation needed</span></a></i>]</sup> Avoiding certain methods can make it easier to prove theorems about a program\'s correctness, or simply to understand its behavior.\n</p>, <p>Examples of high-level paradigms include:\n</p>]