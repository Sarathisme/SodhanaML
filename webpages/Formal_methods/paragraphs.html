[<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, specifically <a href="/wiki/Software_engineering" title="Software engineering">software engineering</a> and <a class="mw-redirect" href="/wiki/Hardware_engineering" title="Hardware engineering">hardware engineering</a>, <b>formal methods</b> are a particular kind of <a class="mw-redirect" href="/wiki/Mathematically" title="Mathematically">mathematically</a> based technique for the <a href="/wiki/Formal_specification" title="Formal specification">specification</a>, development and <a href="/wiki/Formal_verification" title="Formal verification">verification</a> of <a href="/wiki/Software" title="Software">software</a> and <a href="/wiki/Computer_hardware" title="Computer hardware">hardware</a> systems.<sup class="reference" id="cite_ref-butler_1-0"><a href="#cite_note-butler-1">[1]</a></sup> The use of formal methods for software and hardware design is motivated by the expectation that, as in other engineering disciplines, performing appropriate mathematical analysis can contribute to the reliability and robustness of a design.<sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup>\n</p>, <p>Formal methods are best described as the application of a fairly broad variety of <a href="/wiki/Theoretical_computer_science" title="Theoretical computer science">theoretical computer science</a> fundamentals, in particular <a href="/wiki/Logic_in_computer_science" title="Logic in computer science">logic</a> calculi, <a href="/wiki/Formal_language" title="Formal language">formal languages</a>, <a href="/wiki/Automata_theory" title="Automata theory">automata theory</a>, <a href="/wiki/Discrete_event_dynamic_system" title="Discrete event dynamic system">discrete event dynamic system</a> and <a class="mw-redirect" href="/wiki/Program_semantics" title="Program semantics">program semantics</a>, but also <a class="mw-redirect" href="/wiki/Type_systems" title="Type systems">type systems</a> and <a class="mw-redirect" href="/wiki/Algebraic_data_types" title="Algebraic data types">algebraic data types</a> to problems in software and hardware specification and verification.<sup class="reference" id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup>\n</p>, <p>Formal methods can be used at a number of levels:\n</p>, <p><b>Level 0:</b> <a href="/wiki/Formal_specification" title="Formal specification">Formal specification</a> may be undertaken and then a program developed from this informally. This has been dubbed <i>formal methods lite</i>. This may be the most cost-effective option in many cases.\n</p>, <p><b>Level 1:</b> <a class="mw-redirect" href="/wiki/Formal_development" title="Formal development">Formal development</a> and <a href="/wiki/Formal_verification" title="Formal verification">formal verification</a> may be used to produce a program in a more formal manner. For example, proofs of properties or <a class="mw-redirect" href="/wiki/Program_refinement" title="Program refinement">refinement</a> from the <a href="/wiki/Formal_specification" title="Formal specification">specification</a> to a program may be undertaken. This may be most appropriate in high-integrity systems involving <a href="/wiki/Safety" title="Safety">safety</a> or <a href="/wiki/Security" title="Security">security</a>.\n</p>, <p><b>Level 2:</b> <a class="mw-redirect" href="/wiki/Automated_theorem_prover" title="Automated theorem prover">Theorem provers</a> may be used to undertake fully formal machine-checked proofs. This can be very expensive and is only practically worthwhile if the cost of mistakes is extremely high (e.g., in critical parts of microprocessor design).\n</p>, <p>Further information on this is expanded <a href="#Uses">below</a>.\n</p>, <p>As with <a class="mw-redirect" href="/wiki/Formal_semantics_of_programming_languages" title="Formal semantics of programming languages">programming language semantics</a>, styles of formal methods may be roughly classified as follows:\n</p>, <p>Some practitioners believe that the formal methods community has overemphasized full formalization of a specification or design.<sup class="reference" id="cite_ref-4"><a href="#cite_note-4">[4]</a></sup><sup class="reference" id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup> They contend that the expressiveness of the languages involved, as well as the complexity of the systems being modelled, make full formalization a difficult and expensive task. As an alternative, various <i>lightweight</i> formal methods, which emphasize partial specification and focused application, have been proposed. Examples of this lightweight approach to formal methods include the <a class="mw-redirect" href="/wiki/Alloy_language" title="Alloy language">Alloy</a> object modelling notation,<sup class="reference" id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup> Denney\'s synthesis of some aspects of the <a href="/wiki/Z_notation" title="Z notation">Z notation</a> with <a href="/wiki/Use_case" title="Use case">use case</a> driven development,<sup class="reference" id="cite_ref-7"><a href="#cite_note-7">[7]</a></sup> and the CSK <a href="/wiki/Vienna_Development_Method" title="Vienna Development Method">VDM</a> Tools.<sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup>\n</p>, <p>Formal methods can be applied at various points through the <a href="/wiki/Software_development_process" title="Software development process">development process</a>.\n</p>, <p>Formal methods may be used to give a description of the system to be developed, at whatever level(s) of detail desired.  This formal description can be used to guide further development activities (see following sections); additionally, it can be used to verify that the requirements for the system being developed have been completely and accurately specified.\n</p>, <p>The need for formal specification systems has been noted for years.  In the <a href="/wiki/ALGOL_58" title="ALGOL 58">ALGOL 58</a> report,<sup class="reference" id="cite_ref-9"><a href="#cite_note-9">[9]</a></sup> <a href="/wiki/John_Backus" title="John Backus">John Backus</a> presented a formal notation for describing programming language syntax, later named <a class="mw-redirect" href="/wiki/Backus_normal_form" title="Backus normal form">Backus normal form</a> then renamed <a href="/wiki/Backus%E2%80%93Naur_form" title="Backus\xe2\x80\x93Naur form">Backus\xe2\x80\x93Naur form</a> (BNF).<sup class="reference" id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup> Backus also wrote that a formal description of the meaning of syntactically valid ALGOL programs wasn\'t completed in time for inclusion in the report. "Therefore the formal treatment of the semantics of legal programs will be included in a subsequent paper." It never appeared.\n</p>, <p>Once a formal specification has been produced, the specification may be used as a guide while the concrete system is <a href="/wiki/Software_development" title="Software development">developed</a> during the <a href="/wiki/Software_design" title="Software design">design</a> process (i.e., realized typically in software, but also potentially in hardware). For example:\n</p>, <p>Once a formal specification has been developed, the specification may be used as the basis for <a href="/wiki/Mathematical_proof" title="Mathematical proof">proving</a> properties of the specification (and hopefully by inference the developed system).\n</p>, <p>Sometimes, the motivation for proving the <a href="/wiki/Correctness_(computer_science)" title="Correctness (computer science)">correctness</a> of a system is not the obvious need for reassurance of the correctness of the system, but a desire to understand the system better.  Consequently, some proofs of correctness are produced in the style of <a href="/wiki/Mathematical_proof" title="Mathematical proof">mathematical proof</a>: handwritten (or typeset) using <a href="/wiki/Natural_language" title="Natural language">natural language</a>, using a level of informality common to such proofs.  A "good" proof is one which is readable and understandable by other human readers.\n</p>, <p>Critics of such approaches point out that the <a href="/wiki/Ambiguity" title="Ambiguity">ambiguity</a> inherent in natural language allows errors to be undetected in such proofs; often, subtle errors can be present in the low-level details typically overlooked by such proofs.  Additionally, the work involved in producing such a good proof requires a high level of mathematical sophistication and expertise.\n</p>, <p>In contrast, there is increasing interest in producing proofs of correctness of such systems by automated means.  Automated techniques fall into three general categories:\n</p>, <p>Some automated theorem provers require guidance as to which properties are "interesting" enough to pursue, while others work without human intervention. Model checkers can quickly get bogged down in checking millions of uninteresting states if not given a sufficiently abstract model.\n</p>, <p>Proponents of such systems argue that the results have greater mathematical certainty than human-produced proofs, since all the tedious details have been algorithmically verified.  The training required to use such systems is also less than that required to produce good mathematical proofs by hand, making the techniques accessible to a wider variety of practitioners.\n</p>, <p>Critics note that some of those systems are like <a href="/wiki/Oracle_machine" title="Oracle machine">oracles</a>: they make a pronouncement of truth, yet give no explanation of that truth.  There is also the problem of "<a href="/wiki/Quis_custodiet_ipsos_custodes%3F" title="Quis custodiet ipsos custodes?">verifying the verifier</a>"; if the program which aids in the verification is itself unproven, there may be reason to doubt the soundness of the produced results. Some modern model checking tools produce a "proof log" detailing each step in their proof, making it possible to perform, given suitable tools, independent verification.\n</p>, <p>The main feature of the abstract interpretation approach is that it provides a sound analysis, i.e. no false negatives are returned. Moreover, it is efficiently scalable, by tuning the abstract domain representing the property to be analyzed, and by  applying widening operators<sup class="reference" id="cite_ref-11"><a href="#cite_note-11">[11]</a></sup> to get fast convergence.\n</p>, <p>Formal methods are applied in different areas of hardware and software, including routers, Ethernet switches, routing protocols, and security applications. There are several examples in which they have been used to verify the functionality of the hardware and software used in DCs<sup class="noprint Inline-Template" style="margin-left:0.1em; white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Please_clarify" title="Wikipedia:Please clarify"><span title="The text near this tag may need clarification or removal of jargon. (September 2015)">clarification needed</span></a></i>]</sup>. IBM used <a href="/wiki/ACL2" title="ACL2">ACL2</a>, a theorem prover, in AMD x86 processor development process<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (September 2015)">citation needed</span></a></i>]</sup>. Intel uses such methods to verify its hardware and firmware (permanent software programmed into a read-only memory)<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (September 2015)">citation needed</span></a></i>]</sup>. <a href="/wiki/Dansk_Datamatik_Center" title="Dansk Datamatik Center">Dansk Datamatik Center</a> used formal methods in the 1980s to develop a compiler system for the <a class="mw-redirect" href="/wiki/Ada_programming_language" title="Ada programming language">Ada programming language</a> that went on to become a long-lived commercial product.<sup class="reference" id="cite_ref-12"><a href="#cite_note-12">[12]</a></sup><sup class="reference" id="cite_ref-13"><a href="#cite_note-13">[13]</a></sup>\n</p>, <p>There are several other projects of NASA in which formal methods are applied, such as <a href="/wiki/Next_Generation_Air_Transportation_System" title="Next Generation Air Transportation System">Next Generation Air Transportation System</a><sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (September 2015)">citation needed</span></a></i>]</sup>, Unmanned Aircraft System integration in National Airspace System,<sup class="reference" id="cite_ref-14"><a href="#cite_note-14">[14]</a></sup> and Airborne Coordinated Conflict Resolution and Detection (ACCoRD).<sup class="reference" id="cite_ref-15"><a href="#cite_note-15">[15]</a></sup>\n<a href="/wiki/B-Method" title="B-Method">B-Method</a> with <a class="new" href="/w/index.php?title=AtelierB&amp;action=edit&amp;redlink=1" title="AtelierB (page does not exist)">AtelierB</a>,<sup class="reference" id="cite_ref-16"><a href="#cite_note-16">[16]</a></sup> is used to develop safety automatisms for the various subways installed throughout the world by <a href="/wiki/Alstom" title="Alstom">Alstom</a> and <a href="/wiki/Siemens" title="Siemens">Siemens</a>, and also for Common Criteria certification and the development of system models by <a class="mw-redirect" href="/wiki/ATMEL" title="ATMEL">ATMEL</a> and <a href="/wiki/STMicroelectronics" title="STMicroelectronics">STMicroelectronics</a>.\n</p>, <p>Formal verification has been frequently used in hardware by most of the well-known hardware vendors, such as IBM, Intel, and AMD. There are many areas of hardware, where Intel have used FMs to verify the working of the products, such as parameterized verification of cache coherent protocol,<sup class="reference" id="cite_ref-17"><a href="#cite_note-17">[17]</a></sup> Intel Core i7 processor execution engine validation <sup class="reference" id="cite_ref-18"><a href="#cite_note-18">[18]</a></sup> (using theorem proving, <a href="/wiki/Binary_decision_diagram" title="Binary decision diagram">BDDs</a>, and symbolic evaluation), optimization for Intel IA-64 architecture using HOL light theorem prover,<sup class="reference" id="cite_ref-19"><a href="#cite_note-19">[19]</a></sup> and verification of high performance dual-port gigabit Ethernet controller with a support for PCI express protocol and Intel advance management technology using Cadence.<sup class="reference" id="cite_ref-20"><a href="#cite_note-20">[20]</a></sup> Similarly, IBM has used formal methods in the verification of power gates,<sup class="reference" id="cite_ref-21"><a href="#cite_note-21">[21]</a></sup> registers,<sup class="reference" id="cite_ref-22"><a href="#cite_note-22">[22]</a></sup> and functional verification of the IBM Power7 microprocessor.<sup class="reference" id="cite_ref-23"><a href="#cite_note-23">[23]</a></sup>\n</p>, <p>In <a href="/wiki/Software_development" title="Software development">software development</a>, formal methods are mathematical approaches to solving software (and hardware) problems at the requirements, specification, and design levels. Formal methods are most likely to be applied to safety-critical or security-critical software and systems, such as <a href="/wiki/Avionics_software" title="Avionics software">avionics software</a>.  Software safety assurance standards, such as <a href="/wiki/DO-178B" title="DO-178B">DO-178B</a>, <a href="/wiki/DO-178C" title="DO-178C">DO-178C</a>, and <a href="/wiki/Common_Criteria" title="Common Criteria">Common Criteria</a> demand formal methods at the highest levels of categorization.\n</p>, <p>For sequential software, examples of formal methods include the <a href="/wiki/B-Method" title="B-Method">B-Method</a>, the specification languages used in <a href="/wiki/Automated_theorem_proving" title="Automated theorem proving">automated theorem proving</a>, <a href="/wiki/Rigorous_Approach_to_Industrial_Software_Engineering" title="Rigorous Approach to Industrial Software Engineering">RAISE</a>, and the <a href="/wiki/Z_notation" title="Z notation">Z notation</a>.\n</p>, <p>In <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a>, <a href="/wiki/QuickCheck" title="QuickCheck">property-based testing</a> has allowed the mathematical specification and testing (if not exhaustive testing) of the expected behaviour of individual functions.\n</p>, <p>The <a href="/wiki/Object_Constraint_Language" title="Object Constraint Language">Object Constraint Language</a> (and specializations such as <a href="/wiki/Java_Modeling_Language" title="Java Modeling Language">Java Modeling Language</a>) has allowed object-oriented systems to be formally specified, if not necessarily formally verified.\n</p>, <p>For concurrent software and systems, <a href="/wiki/Petri_net" title="Petri net">Petri nets</a>, <a class="mw-redirect" href="/wiki/Process_algebra" title="Process algebra">process algebra</a>, and <a class="mw-redirect" href="/wiki/Finite_state_machine" title="Finite state machine">finite state machines</a> (which are based on <a href="/wiki/Automata_theory" title="Automata theory">automata theory</a> - see also <a class="mw-redirect" href="/wiki/Virtual_finite_state_machine" title="Virtual finite state machine">virtual finite state machine</a> or <a class="mw-redirect" href="/wiki/Event_driven_finite_state_machine" title="Event driven finite state machine">event driven finite state machine</a>) allow executable software specification and can be used to build up and validate application behavior.\n</p>, <p>Another approach to formal methods in software development is to write a specification in some form of logic—usually a variation of <a href="/wiki/First-order_logic" title="First-order logic">first-order logic</a> (FOL)—and then to directly execute the logic as though it were a program.  The <a href="/wiki/Web_Ontology_Language" title="Web Ontology Language">OWL</a> language, based on <a class="mw-redirect" href="/wiki/Description_Logic" title="Description Logic">Description Logic</a> (DL), is an example.  There is also work on mapping some version of English (or another natural language) automatically to and from logic, and executing the logic directly.  Examples are <a href="/wiki/Attempto_Controlled_English" title="Attempto Controlled English">Attempto Controlled English</a>, and Internet Business Logic, which do not seek to control the vocabulary or syntax.  A feature of systems that support bidirectional English-logic mapping and direct execution of the logic is that they can be made to explain their results, in English, at the business or scientific level.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (June 2016)">citation needed</span></a></i>]</sup>\n</p>, <p>There are a variety of formal methods and notations available.\n</p>, <p><span class="citation foldoc"><small>This article is based on material taken from  the <i><a href="/wiki/Free_On-line_Dictionary_of_Computing" title="Free On-line Dictionary of Computing">Free On-line Dictionary of Computing</a></i>  prior to 1 November 2008 and incorporated under the "relicensing" terms of the <a href="/wiki/GNU_Free_Documentation_License" title="GNU Free Documentation License">GFDL</a>, version 1.3 or later.</small></span>\n</p>]