[<p>In <a href="/wiki/Telecommunication" title="Telecommunication">telecommunication</a>, a <b>communication protocol</b> is a system of rules that allow two or more entities of a <a href="/wiki/Communications_system" title="Communications system">communications system</a> to transmit <a href="/wiki/Information" title="Information">information</a> via any kind of variation of a <a href="/wiki/Physical_quantity" title="Physical quantity">physical quantity</a>. The protocol defines the rules, <a href="/wiki/Syntax" title="Syntax">syntax</a>, <a class="mw-redirect" href="/wiki/Semantic" title="Semantic">semantics</a> and <a href="/wiki/Synchronization" title="Synchronization">synchronization</a> of <a href="/wiki/Communication" title="Communication">communication</a> and possible <a href="/wiki/Error_detection_and_correction" title="Error detection and correction">error recovery methods</a>. Protocols may be implemented by <a href="/wiki/Computer_hardware" title="Computer hardware">hardware</a>, <a href="/wiki/Software" title="Software">software</a>, or a combination of both.<sup class="reference" id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup><sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Verifiability" title="Wikipedia:Verifiability"><span title="the citation quality was not enough for such a claim (July 2018)">not in citation given</span></a></i>]</sup>\n</p>, <p>Communicating systems use well-defined formats for exchanging various messages. Each message has an exact meaning intended to elicit a response from a range of possible responses pre-determined for that particular situation. The specified behavior is typically independent of how it is to be <a href="/wiki/Implementation" title="Implementation">implemented</a>. Communication protocols have to be agreed upon by the parties involved.<sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup> To reach agreement, a protocol may be developed into a <a href="/wiki/Technical_standard" title="Technical standard">technical standard</a>. A <a href="/wiki/Programming_language" title="Programming language">programming language</a> describes the same for computations, so there is a close analogy between protocols and programming languages: <i>protocols are to communication what programming languages are to computations</i>.<sup class="reference" id="cite_ref-AnalogyII_3-0"><a href="#cite_note-AnalogyII-3">[3]</a></sup>\n</p>, <p>Multiple protocols often describe different aspects of a single communication.  A group of protocols designed to work together are known as a protocol suite; when implemented in software they are a <a href="/wiki/Protocol_stack" title="Protocol stack">protocol stack</a>.\n</p>, <p>Internet communication protocols are published by the <a href="/wiki/Internet_Engineering_Task_Force" title="Internet Engineering Task Force">Internet Engineering Task Force</a> (IETF). The <a class="mw-redirect" href="/wiki/IEEE" title="IEEE">IEEE</a> handles wired and wireless networking, and the <a href="/wiki/International_Organization_for_Standardization" title="International Organization for Standardization">International Organization for Standardization</a> (ISO) handles other types. The <a href="/wiki/ITU-T" title="ITU-T">ITU-T</a> handles telecommunication protocols and formats for the <a href="/wiki/Public_switched_telephone_network" title="Public switched telephone network">public switched telephone network</a> (PSTN). As the PSTN and Internet <a href="/wiki/Technological_convergence" title="Technological convergence">converge</a>, the standards are also being driven towards convergence.\n</p>, <p>The information exchanged between devices through a network or other media is governed by rules and conventions that can be set out in communication protocol specifications. The nature of a communication, the actual data exchanged and any <a href="/wiki/State_(computer_science)" title="State (computer science)">state</a>-dependent behaviors, is defined by these specifications. In digital computing systems, the rules can be expressed by <a href="/wiki/Algorithm" title="Algorithm">algorithms</a> and <a href="/wiki/Data_structure" title="Data structure">data structures</a>. Protocols are to communication what algorithms or programming languages are to computations.<sup class="reference" id="cite_ref-AnalogyII_3-1"><a href="#cite_note-AnalogyII-3">[3]</a></sup><sup class="reference" id="cite_ref-AnalogyI_4-0"><a href="#cite_note-AnalogyI-4">[4]</a></sup>\n</p>, <p>Operating systems usually contain a set of cooperating processes that manipulate shared data to communicate with each other. This communication is governed by well-understood protocols, which can be embedded in the process code itself.<sup class="reference" id="cite_ref-Ben-Ari_p.18_5-0"><a href="#cite_note-Ben-Ari_p.18-5">[5]</a></sup><sup class="reference" id="cite_ref-Ben-Ari_p.27_6-0"><a href="#cite_note-Ben-Ari_p.27-6">[6]</a></sup> In contrast, because there is no <a href="/wiki/Shared_memory" title="Shared memory">shared memory</a>, communicating systems have to communicate with each other using a shared <a href="/wiki/Transmission_medium" title="Transmission medium">transmission medium</a>. Transmission is not necessarily reliable, and individual systems may use different hardware or operating systems.\n</p>, <p>To implement a networking protocol, the protocol software modules are interfaced with a framework implemented on the machine\'s operating system. This framework implements the networking functionality of the operating system.<sup class="reference" id="cite_ref-Marsden_p.64_7-0"><a href="#cite_note-Marsden_p.64-7">[7]</a></sup> When protocol algorithms are expressed in a portable programming language the protocol software may be made <a href="/wiki/Operating_system" title="Operating system">operating system </a> independent. The best known frameworks are the <a class="mw-redirect" href="/wiki/TCP/IP_model" title="TCP/IP model">TCP/IP model</a> and the <a href="/wiki/OSI_model" title="OSI model">OSI model</a>.\n</p>, <p>At the time the Internet was developed, <a href="/wiki/Abstraction_layer" title="Abstraction layer">abstraction layering</a> had proven to be a successful design approach for both compiler and operating system design and, given the similarities between programming languages and communication protocols, the originally monolithic networking programs were decomposed into cooperating protocols.<sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup> This gave rise to the concept of layered protocols which nowadays forms the basis of protocol design.<sup class="reference" id="cite_ref-Sect_p._192_9-0"><a href="#cite_note-Sect_p._192-9">[9]</a></sup>\n</p>, <p>Systems typically do not use a single protocol to handle a transmission. Instead they use a set of cooperating protocols, sometimes called a <a class="mw-redirect" href="/wiki/Protocol_suite" title="Protocol suite">protocol suite</a>.<sup class="reference" id="cite_ref-Sect_p._177_10-0"><a href="#cite_note-Sect_p._177-10">[10]</a></sup> Some of the best known protocol suites are <a class="mw-redirect" href="/wiki/TCP/IP" title="TCP/IP">TCP/IP</a>, <a href="/wiki/IPX/SPX" title="IPX/SPX">IPX/SPX</a>, <a href="/wiki/X.25" title="X.25">X.25</a>, <a href="/wiki/AX.25" title="AX.25">AX.25</a> and <a href="/wiki/AppleTalk" title="AppleTalk">AppleTalk</a>.\n</p>, <p>The protocols can be arranged based on functionality in groups, for instance there is a group of <a class="mw-redirect" href="/wiki/Transport_protocol" title="Transport protocol">transport protocols</a>. The functionalities are mapped onto the layers, each layer solving a distinct class of problems relating to, for instance: application-, transport-, internet- and network interface-functions.<sup class="reference" id="cite_ref-Sect_p._178_11-0"><a href="#cite_note-Sect_p._178-11">[11]</a></sup> To transmit a message, a protocol has to be selected from each layer. The selection of the next protocol is accomplished by extending the message with a protocol selector for each layer.<sup class="reference" id="cite_ref-12"><a href="#cite_note-12">[12]</a></sup>\n</p>, <p>Getting the data across a network is only part of the problem for a protocol. The data received has to be evaluated in the context of the progress of the conversation, a protocol therefore must include rules describing the context. These kind of rules are said to express the <i>syntax</i> of the communication. Other rules determine whether the data is meaningful for the context in which the exchange takes place. These kind of rules are said to express the <i>semantics</i> of the communication.\n</p>, <p>Messages are sent and received on communicating systems to establish communication. Protocols should therefore specify rules governing the transmission. In general, much of the following should be addressed:<sup class="reference" id="cite_ref-13"><a href="#cite_note-13">[13]</a></sup>\n</p>, <p><a href="/wiki/Systems_engineering" title="Systems engineering">Systems engineering</a> principles have been applied to create a set of common network protocol design principles. Design of complex protocols often involves decomposition into simpler, cooperating protocols. Such a set of cooperating protocols is sometimes called a protocol family or a protocol suite,<sup class="reference" id="cite_ref-Sect_p._177_10-1"><a href="#cite_note-Sect_p._177-10">[10]</a></sup> within \na conceptual framework.\n</p>, <p>Communicating systems operate concurrently. An important aspect of <a class="mw-redirect" href="/wiki/Concurrent_programming" title="Concurrent programming">concurrent programming</a> is the synchronization of software for receiving and transmitting messages of communication in proper sequencing. Concurrent programming has traditionally been a topic in operating systems theory texts.<sup class="reference" id="cite_ref-24"><a href="#cite_note-24">[23]</a></sup> Formal verification seems indispensable, because concurrent programs are notorious for the hidden and sophisticated bugs they contain.<sup class="reference" id="cite_ref-25"><a href="#cite_note-25">[24]</a></sup> A mathematical approach to the study of concurrency and communication is referred to as <i><a href="/wiki/Communicating_sequential_processes" title="Communicating sequential processes">communicating sequential processes</a></i> (CSP).<sup class="reference" id="cite_ref-26"><a href="#cite_note-26">[25]</a></sup> Concurrency can also be modeled using <a class="mw-redirect" href="/wiki/Finite_state_machine" title="Finite state machine">finite state machines</a>, such as <a href="/wiki/Mealy_machine" title="Mealy machine">Mealy</a> and <a href="/wiki/Moore_machine" title="Moore machine">Moore machines</a>. Mealy and Moore machines are in use as design tools in digital electronics systems encountered in the form of hardware used in telecommunication or electronic devices in general.<sup class="reference" id="cite_ref-27"><a href="#cite_note-27">[26]</a></sup><sup class="noprint Inline-Template noprint noexcerpt Template-Fact" style="white-space:nowrap;">[<i><a class="mw-redirect" href="/wiki/Wikipedia:NOTRS" title="Wikipedia:NOTRS"><span title="This claim needs references to better sources. (September 2018)">better source needed</span></a></i>]</sup>\n</p>, <p>The literature presents numerous analogies between computer communication and programming. In analogy, a transfer mechanism of a protocol is comparable to a central processing unit (CPU). The framework introduces rules  that allow the programmer to design cooperating protocols independently of one another. <i>Protocols are to computer communication what programming languages are to computation</i>.<sup class="reference" id="cite_ref-28"><a href="#cite_note-28">[27]</a></sup><sup class="reference" id="cite_ref-Sect_p._187_29-0"><a href="#cite_note-Sect_p._187-29">[28]</a></sup>\n</p>, <p>In modern protocol design, protocols are layered to form a <i>protocol stack</i>. Layering is a design principle which divides the protocol design task into smaller steps, each of which accomplishes a specific part, interacting with the other parts of the protocol only in a small number of well-defined ways. Layering allows the parts of a protocol to be designed and tested without a <a href="/wiki/Combinatorial_explosion" title="Combinatorial explosion">combinatorial explosion</a> of cases, keeping each design relatively simple.  Layering also permits familiar protocols to be adapted to unusual circumstances. For example, the mail protocol can be adapted to send messages to aircraft by changing the <a class="mw-redirect" href="/wiki/V.42" title="V.42">V.42</a> modem protocol to the INMARS LAPD data protocol used by the international marine radio satellites.\n</p>, <p>The communication protocols in use in the <a href="/wiki/Internet" title="Internet">Internet</a> are designed to function in diverse and complex settings. Internet protocols are designed for simplicity and modularity in interoperating, and fit into a coarse hierarchy of functional layers, traditionally called the <a class="mw-redirect" href="/wiki/TCP/IP" title="TCP/IP">TCP/IP</a> model, or <a class="mw-redirect" href="/wiki/Internet_Protocol_Suite" title="Internet Protocol Suite">Internet Protocol Suite</a>.<sup class="reference" id="cite_ref-Comer_decomposition_30-0"><a href="#cite_note-Comer_decomposition-30">[29]</a></sup> The name TCP/IP arose from the first two cooperating protocols, the <a href="/wiki/Transmission_Control_Protocol" title="Transmission Control Protocol">Transmission Control Protocol</a> (TCP) and the <a href="/wiki/Internet_Protocol" title="Internet Protocol">Internet Protocol</a> (IP), that resulted from the decomposition of the original Transmission Control Program, a monolithic communication protocol, into the first two layers of the communication suite. This model was expanded to four layers by additional protocols. However, the Internet protocol development has not focussed on the principle of layering as mandatory recipe for communication, rather it evolved as a convenient description of modularity and protocol cooperation.\n</p>, <p>A different model is the <a class="mw-redirect" href="/wiki/OSI_seven_layer_model" title="OSI seven layer model">OSI seven layer model</a>, which was developed internationally as a rigorous reference model for general communication, with much stricter rules of protocol interaction and a rigorous layering concept of functionality.\n</p>, <p>Typically, application software is built upon a robust data transport layer. Underlying this transport layer is a datagram delivery and routing mechanism that is typically <a class="mw-redirect" href="/wiki/Connectionless" title="Connectionless">connectionless</a> in the Internet. Packet relaying across networks happens over another layer that involves only network link technologies, which are often specific to certain physical layer technologies, such as <a href="/wiki/Ethernet" title="Ethernet">Ethernet</a>. Layering provides opportunities to exchange technologies when needed, for example, protocols are often stacked in a <i>tunneling</i> arrangement to accommodate connection of dissimilar networks. For example, IP may be tunneled across an <a class="mw-redirect" href="/wiki/Asynchronous_Transfer_Mode" title="Asynchronous Transfer Mode">Asynchronous Transfer Mode</a> (ATM) network.\n</p>, <p>Protocol layering now forms the basis of protocol design.<sup class="reference" id="cite_ref-Sect_p._192_9-1"><a href="#cite_note-Sect_p._192-9">[9]</a></sup> It allows the decomposition of single, complex protocols into simpler, cooperating protocols, but it is also a functional decomposition, because each protocol belongs to a functional class, called a <i>protocol layer</i>.<sup class="reference" id="cite_ref-Comer_decomposition_30-1"><a href="#cite_note-Comer_decomposition-30">[29]</a></sup> The protocol layers each solve a distinct class of communication problems. The Internet protocol suite consists of the following layers: application-, transport-, internet- and network interface-functions.<sup class="reference" id="cite_ref-Sect_p._178_11-1"><a href="#cite_note-Sect_p._178-11">[11]</a></sup> Together, the layers make up a <i>layering scheme</i> or <i>model</i>.\n</p>, <p>Computations deal with algorithms and data and communication involves protocols and messages, so the analog of a <a href="/wiki/Data_flow_diagram" title="Data flow diagram">data flow diagram</a> is some kind of message flow diagram.<sup class="reference" id="cite_ref-AnalogyI_4-1"><a href="#cite_note-AnalogyI-4">[4]</a></sup>\nTo visualize protocol layering and protocol suites, a diagram of the message flows in and between two systems, A and B, is shown in figure 3.\n</p>, <p>The systems both make use of the same protocol suite. The vertical flows (and protocols) are <i>in system</i> and the horizontal message flows (and protocols) are <i>between</i> systems. The message flows are governed by rules, and data formats specified by protocols. The blue lines therefore mark the boundaries of the (horizontal) protocol layers.\n</p>, <p>The vertical protocols are not layered because they don\'t obey the <i>protocol layering principle</i> which states that <i>a layered protocol is designed so that layer</i> n <i>at the destination receives exactly the same object sent by layer</i> n <i>at the source</i>.\nThe horizontal protocols are <i>layered protocols</i> and all belong to the protocol suite. Layered protocols allow the protocol designer to concentrate on one layer at a time, without worrying about how other layers perform.<sup class="reference" id="cite_ref-Sect_p._187_29-1"><a href="#cite_note-Sect_p._187-29">[28]</a></sup>\n</p>, <p>The vertical protocols need not be the same protocols on both systems, but they have to satisfy some minimal assumptions to ensure the protocol layering principle holds for the layered protocols. This can be achieved using a technique called <i>Encapsulation</i>.<sup class="reference" id="cite_ref-ReferenceA_31-0"><a href="#cite_note-ReferenceA-31">[30]</a></sup>\n</p>, <p>Usually, a message or a stream of data is divided into small pieces, called <i>messages</i> or <i>streams</i>, <i>packets</i>, <i>IP datagrams</i> or <i>network frames</i> depending on the layer in which the pieces are to be transmitted. The pieces contain a <i>header area</i> and a <i>data area</i>. The data in the header area identifies the source and the destination on the network of the packet, the protocol, and other data meaningful to the protocol like CRC\'s of the data to be sent, data length, and a timestamp.<sup class="reference" id="cite_ref-32"><a href="#cite_note-32">[31]</a></sup><sup class="reference" id="cite_ref-33"><a href="#cite_note-33">[32]</a></sup>\n</p>, <p>The rule enforced by the vertical protocols is that the pieces for transmission are to be <i>encapsulated</i> in the data area of all lower protocols on the sending side and the reverse is to happen on the receiving side. The result is that at the lowest level the piece looks like this: \'Header1,Header2,Header3,data\' and in the layer directly above it: \'Header2,Header3,data\' and in the top layer: \'Header3,data\', both on the sending and receiving side.\nThis rule therefore ensures that the protocol layering principle holds and effectively virtualizes all but the lowest transmission lines, so for this reason some message flows are coloured red in figure 3.\n</p>, <p>To ensure both sides use the same protocol, the pieces also carry data identifying the protocol in their header.\n</p>, <p>The design of the protocol layering and the network (or Internet) architecture are interrelated, so one cannot be designed without the other.<sup class="reference" id="cite_ref-34"><a href="#cite_note-34">[33]</a></sup>\nSome of the more important features in this respect of the Internet architecture and the network services it provides are described next.\n</p>, <p>Having established the protocol layering and the protocols, the protocol designer can now resume with the software design. The software has a layered organization and its relationship with protocol layering is visualized in figure 5.\n</p>, <p>The software modules implementing the protocols are represented by cubes. The information flow between the modules is represented by arrows. The (top two horizontal) red arrows are virtual. The blue lines mark the layer boundaries.\n</p>, <p>To send a message on system A, the top module interacts with the module directly below it and hands over the message to be encapsulated. This module reacts by encapsulating the message in its own data area and filling in its header data in accordance with the protocol it implements and interacts with the module below it by handing over this newly formed message whenever appropriate. The bottom module directly interacts with the bottom module of system B, so the message is sent across. On the receiving system B the reverse happens, so ultimately (and assuming there were no transmission errors or protocol violations etc.) the message gets delivered in its original form to the topmodule of system B.<sup class="reference" id="cite_ref-49"><a href="#cite_note-49">[48]</a></sup>\n<br/>\nOn protocol errors, a receiving module discards the piece it has received and reports back the error condition to the original source of the piece on the same layer by handing the error message down or in case of the bottom module sending it across.<sup class="reference" id="cite_ref-50"><a href="#cite_note-50">[49]</a></sup>\n<br/>\nThe division of the message or stream of data into pieces and the subsequent reassembly are handled in the layer that introduced the division/reassembly. The reassembly is done at the destination (i.e. not on any intermediate routers).<sup class="reference" id="cite_ref-51"><a href="#cite_note-51">[50]</a></sup>\n</p>, <p>TCP/IP software is organized in four layers.<sup class="reference" id="cite_ref-52"><a href="#cite_note-52">[51]</a></sup>\n</p>, <p>Program translation is divided into four subproblems: <a href="/wiki/Compiler" title="Compiler">compiler</a>, <a href="/wiki/Assembly_language#Assembler" title="Assembly language">assembler</a>, <a href="/wiki/Linker_(computing)" title="Linker (computing)">link editor</a>, and <a href="/wiki/Loader_(computing)" title="Loader (computing)">loader</a>. As a result, the translation software is layered as well, allowing the software layers to be designed independently. Noting that the ways to conquer the complexity of program translation could readily be applied to protocols because of the analogy between programming languages and protocols, the designers of the TCP/IP protocol suite were keen on imposing the same layering on the software framework. This can be seen in the TCP/IP layering by considering the translation of a <i>pascal program</i> (message) that is compiled (function of the application layer) into an <i>assembler program</i> that is assembled (function of the transport layer) to <i>object code</i> (pieces) that is linked (function of the Internet layer) together with <i>library object code</i> (routing table) by the link editor, producing <i>relocatable machine code</i> (datagram) that is passed to the loader which fills in the memory locations (ethernet addresses) to produce <i>executable code</i> (network frame) to be loaded (function of the network interface layer) into physical memory (transmission medium). To show just how closely the analogy fits, the terms between parentheses in the previous sentence denote the relevant analogs and the terms written <i>cursively</i> denote data representations. Program translation forms a linear sequence, because each layer\'s output is passed as input to the next layer. Furthermore, the translation process involves multiple data representations. We<sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Manual_of_Style/Words_to_watch#Unsupported_attributions" title="Wikipedia:Manual of Style/Words to watch"><span title="The material near this tag possibly uses too-vague attribution or weasel words. (March 2018)">who?</span></a></i>]</sup> see the same thing happening in protocol software where multiple protocols define the data representations of the data passed between the software modules.<sup class="reference" id="cite_ref-Comer_p._178_53-0"><a href="#cite_note-Comer_p._178-53">[52]</a></sup>\n</p>, <p>The modules below the application layer are generally considered part of the operating system. Passing data between these modules is much less expensive than passing data between an application program and the transport layer. The boundary between application layer and transport layer is called the <i>operating system boundary</i>.<sup class="reference" id="cite_ref-54"><a href="#cite_note-54">[53]</a></sup>\n</p>, <p>Strictly adhering to a layered model, a practice known as strict layering, is not always the best approach to networking.<sup class="reference" id="cite_ref-55"><a href="#cite_note-55">[54]</a></sup> Strict layering, can have a serious impact on the performance of the implementation, so there is at least a trade-off between simplicity and performance.<sup class="reference" id="cite_ref-56"><a href="#cite_note-56">[55]</a></sup> Another, perhaps more important point can be shown by considering the fact that some of the protocols in the Internet Protocol Suite cannot be expressed using the TCP/IP model, in other words some of the protocols behave in ways not described by the model.<sup class="reference" id="cite_ref-57"><a href="#cite_note-57">[56]</a></sup> To improve on the model, an offending protocol could, perhaps be split up into two protocols, at the cost of one or two extra layers, but there is a hidden caveat, because the model is also used to provide a conceptual view on the suite for the intended users. There is a trade-off to be made here between preciseness for the designer and clarity for the intended user.<sup class="reference" id="cite_ref-58"><a href="#cite_note-58">[57]</a></sup>\n</p>, <p>While the use of protocol layering is today ubiquitous across the field of computer networking, it has been historically criticized by many researchers<sup class="reference" id="cite_ref-59"><a href="#cite_note-59">[58]</a></sup> for two principal reasons. Firstly, abstracting the protocol stack in this way may cause a higher layer to duplicate functionality of a lower layer, a prime example being error recovery on both a per-link basis and an end-to-end basis.<sup class="reference" id="cite_ref-60"><a href="#cite_note-60">[59]</a></sup> Secondly, it is common that a protocol implementation at one layer may require data, state or addressing information that is only present at another layer, thus defeating the point of separating the layers in the first place. For example, <a class="mw-redirect" href="/wiki/Transmission_control_protocol" title="Transmission control protocol">TCP</a> uses the ECN field in the <a class="mw-redirect" href="/wiki/IPv4_header" title="IPv4 header">IPv4 header</a> as an indication of congestion; IP is a <a href="/wiki/Network_layer" title="Network layer">network layer</a> protocol whereas TCP is a <a href="/wiki/Transport_layer" title="Transport layer">transport layer</a> protocol.\n</p>, <p>There are commonly reoccurring problems that occur in the design and implementation of communication protocols and can be addressed by patterns from several different pattern languages: <i>Pattern Language for Application-level Communication Protocols (<a class="external text" href="http://commdp.serv.usu.edu/" rel="nofollow">CommDP</a>)</i>,<sup class="reference" id="cite_ref-61"><a href="#cite_note-61">[60]</a></sup><sup class="reference" id="cite_ref-62"><a href="#cite_note-62">[61]</a></sup> <i>Service Design Patterns</i>,<sup class="reference" id="cite_ref-63"><a href="#cite_note-63">[62]</a></sup> <i>Patterns of Enterprise Application Architecture</i>,<sup class="reference" id="cite_ref-64"><a href="#cite_note-64">[63]</a></sup> <i>Pattern-Oriented Software Architecture: A Pattern Language for Distributed Computing</i>.<sup class="reference" id="cite_ref-65"><a href="#cite_note-65">[64]</a></sup> The first of these pattern languages focuses on the design of protocols and not their implementations. The others address issues in either both areas or just the latter.\n</p>, <p>Formal methods of describing communication syntax are <a href="/wiki/Abstract_Syntax_Notation_One" title="Abstract Syntax Notation One">Abstract Syntax Notation One</a> (an <a href="/wiki/International_Organization_for_Standardization" title="International Organization for Standardization">ISO</a> standard) and <a class="mw-redirect" href="/wiki/Augmented_Backus-Naur_form" title="Augmented Backus-Naur form">Augmented Backus-Naur form</a> (an <a class="mw-redirect" href="/wiki/IETF" title="IETF">IETF</a> standard).\n</p>, <p><a class="mw-redirect" href="/wiki/Finite_state_machine" title="Finite state machine">Finite state machine models</a><sup class="reference" id="cite_ref-66"><a href="#cite_note-66">[65]</a></sup><sup class="reference" id="cite_ref-67"><a href="#cite_note-67">[66]</a></sup> and communicating finite-state machines<sup class="reference" id="cite_ref-68"><a href="#cite_note-68">[67]</a></sup> are used to formally describe the possible interactions of the protocol.\n</p>, <p>For communication to take place, protocols have to be agreed upon. Recall that in digital computing systems, the rules can be expressed by algorithms and datastructures, raising the opportunity for hardware independence. Expressing the algorithms in a portable programming language, makes the protocol software operating system independent. The source code could be considered a protocol specification. This form of specification, however is not suitable for the parties involved.\n</p>, <p>For one thing, this would enforce a source on all parties and for another, proprietary software producers would not accept this. By describing the software interfaces of the modules on paper and agreeing on the interfaces, implementers are free to do it their way. This is referred to as source independence. By specifying the algorithms on paper and detailing hardware dependencies in an unambiguous way, a <i>paper draft</i> is created, that when adhered to and published, ensures interoperability between software and hardware.\n</p>, <p>Such a paper draft can be developed into a <i>protocol standard</i> by getting the approval of a <i>standards organization</i>. To get the approval the paper draft needs to enter and successfully complete the <i>standardization process</i>. This activity is referred to as <i>protocol development</i>. The members of the standards organization agree to adhere to the standard on a voluntary basis. Often the members are in control of large market-shares relevant to the protocol and in many cases, standards are enforced by law or the government, because they are thought to serve an important public interest, so getting approval can be very important for the protocol.\n</p>, <p>It should be noted though that in some cases protocol standards are not sufficient to gain widespread acceptance i.e. sometimes the source code needs to be disclosed and enforced by law or the government in the interest of the public.\n</p>, <p>The need for protocol standards can be shown by looking at what happened to the bi-sync protocol (BSC) invented by <a href="/wiki/IBM" title="IBM">IBM</a>. BSC is an early link-level protocol used to connect two separate nodes. It was originally not intended to be used in a multinode network, but doing so revealed several deficiencies of the protocol. In the absence of standardization, manufacturers and organizations felt free to \'enhance\' the protocol, creating incompatible versions on their networks. In some cases, this was deliberately done to discourage users from using equipment from other manufacturers. There are more than 50 variants of the original bi-sync protocol. One can assume, that a standard would have prevented at least some of this from happening.<sup class="reference" id="cite_ref-Marsden_p.64_7-1"><a href="#cite_note-Marsden_p.64-7">[7]</a></sup>\n</p>, <p>In some cases, protocols gain market dominance without going through a standardization process. Such protocols are referred to as <i><a href="/wiki/De_facto_standard" title="De facto standard">de facto standards</a></i>. De facto standards are common in emerging markets, niche markets, or markets that are monopolized (or oligopolized). They can hold a market in a very negative grip, especially when used to scare away competition. From a historical perspective, standardization should be seen as a measure to counteract the ill-effects of de facto standards. Positive exceptions exist; a \'de facto standard\' operating system like GNU/Linux does not have this negative grip on its market, because the sources are published and maintained in an open way, thus inviting competition. Standardization is therefore not the only solution for <i>open systems interconnection</i>.\n</p>, <p>Some of the <a href="/wiki/Standards_organization" title="Standards organization">standards organizations</a> of relevance for communication protocols are the <a href="/wiki/International_Organization_for_Standardization" title="International Organization for Standardization">International Organization for Standardization</a> (ISO), the <a href="/wiki/International_Telecommunication_Union" title="International Telecommunication Union">International Telecommunication Union</a> (ITU), the <a href="/wiki/Institute_of_Electrical_and_Electronics_Engineers" title="Institute of Electrical and Electronics Engineers">Institute of Electrical and Electronics Engineers</a> (IEEE), and the <a href="/wiki/Internet_Engineering_Task_Force" title="Internet Engineering Task Force">Internet Engineering Task Force</a> (IETF). The IETF maintains the protocols in use on the Internet. The IEEE controls many software and hardware protocols in the electronics industry for commercial and consumer devices. The ITU is an umbrella organization of telecommunication engineers designing the <a href="/wiki/Public_switched_telephone_network" title="Public switched telephone network">public switched telephone network</a> (PSTN), as well as many <a href="/wiki/Radio" title="Radio">radio</a> communication systems. For <a href="/wiki/Marine_electronics" title="Marine electronics">marine electronics</a> the <a href="/wiki/National_Marine_Electronics_Association" title="National Marine Electronics Association">NMEA</a> standards are used. The <a href="/wiki/World_Wide_Web_Consortium" title="World Wide Web Consortium">World Wide Web Consortium</a> (W3C) produces protocols and standards for Web technologies.\n</p>, <p>International standards organizations are supposed to be more impartial than local organizations with a national or commercial self-interest to consider. Standards organizations also do research and development for standards of the future. In practice, the standards organizations mentioned, cooperate closely with each other.<sup class="reference" id="cite_ref-69"><a href="#cite_note-69">[68]</a></sup>\n</p>, <p>The standardization process starts off with ISO commissioning a sub-committee workgroup. The workgroup issues working drafts and discussion documents to interested parties (including other standards bodies) in order to provoke discussion and comments. This will generate a lot of questions, much discussion and usually some disagreement on what the standard should provide and if it can satisfy all needs (usually not). All conflicting views should be taken into account, often by way of compromise, to progress to a <i>draft proposal</i> of the working group.\n</p>, <p>The draft proposal is discussed by the member countries\' standard bodies and other organizations within each country. Comments and suggestions are collated and national views will be formulated, before the members of ISO vote on the proposal. If rejected, the draft proposal has to consider the objections and counter-proposals to create a new draft proposal for another vote. After a lot of feedback, modification, and compromise the proposal reaches the status of a <i>draft international standard</i>, and ultimately an <i>international standard</i>.\n</p>, <p>The process normally takes several years to complete. The original paper draft created by the designer will differ substantially from the standard, and will contain some of the following \'features\':\n</p>, <p>International standards are reissued periodically to handle the deficiencies and reflect changing views on the subject.<sup class="reference" id="cite_ref-70"><a href="#cite_note-70">[69]</a></sup>\n</p>, <p>A lesson learned from <a href="/wiki/ARPANET" title="ARPANET">ARPANET</a>, the predecessor of the Internet, was that standardization of protocols is not enough,<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (March 2018)">citation needed</span></a></i>]</sup> because protocols also need a framework to operate. It is therefore important to develop a general-purpose, future-proof framework suitable for <i>structured protocols</i> (such as layered protocols) and their standardization. This would prevent protocol standards with overlapping functionality and would allow clear definition of the responsibilities of a protocol at the different levels (layers).<sup class="reference" id="cite_ref-71"><a href="#cite_note-71">[70]</a></sup>\nThis gave rise to the OSI <i>Open Systems Interconnection reference model</i> (RM/OSI), which is used as a framework for the design of standard protocols and services conforming to the various layer specifications.<sup class="reference" id="cite_ref-72"><a href="#cite_note-72">[71]</a></sup>\n</p>, <p>In the <a href="/wiki/OSI_model" title="OSI model">OSI model</a>, communicating systems are assumed to be connected by an underlying physical medium providing a basic (and unspecified) transmission mechanism. The layers above it are numbered (from one to seven); the n<sup>th</sup> layer is referred to as (n)-layer. Each layer provides service to the layer above it (or at the top to the application process) using the services of the layer immediately below it. The layers communicate with each other by means of an interface, called a <i>service access point</i>. Corresponding layers at each system are called <i>peer entities</i>. To communicate, two peer entities at a given layer use an (n)-protocol, which is implemented by using services of the (n-1)-layer. When systems are not directly connected, intermediate peer entities (called <i>relays</i>) are used. An <i>address</i> uniquely identifies a service access point. The address naming domains need not be restricted to one layer, so it is possible to use just one naming domain for all layers.<sup class="reference" id="cite_ref-73"><a href="#cite_note-73">[72]</a></sup>\nFor each layer there are two types of standards: protocol standards defining how peer entities at a given layer communicate, and service standards defining how a given layer communicates with the layer above it.\n</p>, <p>In the original version of RM/OSI, the layers and their functionality are (from highest to lowest layer):\n</p>, <p>In contrast to the <a href="#Software_layering">TCP/IP layering scheme</a>, which assumes a connectionless network, RM/OSI assumed a connection-oriented network. Connection-oriented networks are more suitable for wide area networks and connectionless networks are more suitable for local area networks. Using connections to communicate implies some form of session and (virtual) circuits, hence the (in the TCP/IP model lacking) session layer. The constituent members of ISO were mostly concerned with wide area networks, so development of RM/OSI concentrated on connection oriented networks and connectionless networks were only mentioned in an addendum to RM/OSI.<sup class="reference" id="cite_ref-81"><a href="#cite_note-81">[80]</a></sup>\nAt the time, the IETF had to cope with this and the fact that the Internet needed protocols which simply were not there. As a result, the IETF developed its own standardization process based on "rough consensus and running code".<sup class="reference" id="cite_ref-82"><a href="#cite_note-82">[81]</a></sup>\n</p>, <p>The standardization process is described by <a class="external text" href="http://tools.ietf.org/html/rfc2026" rel="nofollow">RFC2026</a>.\n</p>, <p>Nowadays, the IETF has become a standards organization for the protocols in use on the Internet. RM/OSI has extended its model to include connectionless services and because of this, both TCP and IP could be developed into international standards.\n</p>, <p>Classification schemes for protocols usually focus on domain of use and function. As an example of domain of use, <a class="mw-redirect" href="/wiki/Connection-oriented_protocol" title="Connection-oriented protocol">connection-oriented protocols</a> and <a class="mw-redirect" href="/wiki/Connectionless_protocol" title="Connectionless protocol">connectionless protocols</a> are used on connection-oriented networks and connectionless networks respectively. For an example of function consider a <a href="/wiki/Tunneling_protocol" title="Tunneling protocol">tunneling protocol</a>, which is used to encapsulate packets in a high-level protocol, so the packets can be passed across a transport system using the high-level protocol.\n</p>, <p>A <a href="#Protocol_layering"><i>layering scheme</i></a> combines both function and domain of use. The dominant layering schemes are the ones proposed by the IETF and by ISO. Despite the fact that the underlying assumptions of the layering schemes are different enough to warrant distinguishing the two, it is a common practice to compare the two by relating common protocols to the layers of the two schemes.<sup class="reference" id="cite_ref-83"><a href="#cite_note-83">[82]</a></sup> For an example of this practice see: <a href="/wiki/Lists_of_network_protocols" title="Lists of network protocols">Lists of network protocols</a>.\n</p>, <p>The layering scheme from the IETF is called <i>Internet layering</i> or <i>TCP/IP layering</i>. The functionality of the layers has been described in the section on <a href="#Software_layering">software layering</a> and an overview of protocols using this scheme is given in the article on <a class="mw-redirect" href="/wiki/Internet_protocols" title="Internet protocols">Internet protocols</a>.\n</p>, <p>The layering scheme from ISO is called <i>the OSI model</i> or <i>ISO layering</i>. The functionality of the layers has been described in the section on <a href="#Future_of_standardization_(OSI)">the future of standardization</a> and an overview of protocols using this scheme is given in the article on <a href="/wiki/OSI_protocols" title="OSI protocols">OSI protocols</a>.\n</p>, <p>In networking equipment configuration, a term-of-art distinction is often drawn: The term "protocol" strictly refers to the transport layer, and the term "service" refers to protocols utilizing a "protocol" for transport.  In the common case of the TCP and UDP "protocols", "services" are distinguished by their port numbers.  Conformance to these port numbers is voluntary, so in content inspection systems the term "service" strictly refers to port numbers, and the term "application" is often used to refer to protocols identified through inspection signatures.  Protocols upon which transport layer relies, like IPv4, are distinguished by their "address family."\n</p>, <p class="mw-empty-elt">\n</p>]