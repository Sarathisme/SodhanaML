[<p>In <a href="/wiki/Computer_programming" title="Computer programming">computer programming</a>, a <b>software framework</b> is an <a href="/wiki/Abstraction_(computer_science)" title="Abstraction (computer science)">abstraction</a> in which <a href="/wiki/Software" title="Software">software</a> providing generic functionality can be selectively changed by additional user-written code, thus providing application-specific software. A software framework provides a standard way to build and deploy applications. \nA software framework is a universal, reusable <a class="mw-redirect mw-disambig" href="/wiki/Software_environment_(disambiguation)" title="Software environment (disambiguation)"> software environment</a> that provides particular functionality as part of a larger <a class="mw-redirect" href="/wiki/Software_platform" title="Software platform">software platform</a> to facilitate development of <a class="mw-redirect" href="/wiki/Software_application" title="Software application">software applications</a>, products and solutions. Software frameworks may include support programs, compilers, code libraries, tool sets, and <a href="/wiki/Application_programming_interface" title="Application programming interface">application programming interfaces (APIs)</a> that bring together all the different <a class="mw-redirect" href="/wiki/Software_component" title="Software component">components</a> to enable development of a <a class="mw-redirect" href="/wiki/Software_project" title="Software project">project</a> or <a href="/wiki/Software_system" title="Software system">system</a>.\n</p>, <p>Frameworks have key distinguishing features that separate them from normal <a href="/wiki/Library_(computing)" title="Library (computing)">libraries</a>:\n</p>, <p>The designers of software frameworks aim to facilitate software developments by allowing designers and programmers to devote their time to meeting software requirements rather than  dealing with the more standard low-level details of providing a working system, thereby reducing overall development time.<sup class="reference" id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup>  For example, a team using a <a href="/wiki/Web_framework" title="Web framework">web framework</a> to develop a banking website can focus on writing code particular to banking rather than the mechanics of request handling and <a href="/wiki/State_management" title="State management">state management</a>.\n</p>, <p>Frameworks often add to the size of programs, a phenomenon termed "<a href="/wiki/Code_bloat" title="Code bloat">code bloat</a>". Due to customer-demand driven applications needs, both competing and complementary frameworks sometimes end up in a product.  Further, due to the complexity of their APIs, the intended reduction in overall development time may not be achieved due to the need to spend additional time learning to use the framework; this criticism is clearly valid when a special or new framework is first encountered by development staff.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (April 2011)">citation needed</span></a></i>]</sup> If such a framework is not used in subsequent job taskings, the time invested in learning the framework can cost more than purpose-written code familiar to the project\'s staff; many programmers keep copies of useful boilerplate for common needs.\n</p>, <p>However, once a framework is learned, future projects can be faster and easier to complete; the concept of a framework is to make a one-size-fits-all solution set, and with familiarity, code production should logically rise. There are no such claims made about the size of the code eventually bundled with the output product, nor its relative efficiency and conciseness. Using any library solution necessarily pulls in extras and unused extraneous assets unless the software is a compiler-object linker making a tight (small, wholly controlled, and specified) executable module.\n</p>, <p>The issue continues, but a decade-plus of industry experience<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (April 2011)">citation needed</span></a></i>]</sup> has shown that the most effective frameworks turn out to be those that evolve from re-factoring the common code of the enterprise, instead of using a generic "one-size-fits-all" framework developed by third parties for general purposes. An example of that would be how the user interface in such an application package as an office suite grows to have common look, feel, and data-sharing attributes and methods, as the once disparate bundled applications grow unified into a suite which is tighter and smaller; the newer/evolved suite can be a product that shares integral utility libraries and user interfaces.\n</p>, <p>This trend in the controversy brings up an important issue about frameworks. Creating a framework that is elegant, versus one that merely solves a problem, is still an art rather than a science. "Software <a href="/wiki/Elegance" title="Elegance">elegance</a>" implies clarity, conciseness, and little waste (extra or extraneous functionality, much of which is user defined). For those frameworks that generate code, for example, "elegance" would imply the creation of code that is clean and comprehensible to a reasonably knowledgeable programmer (and which is therefore readily modifiable), versus one that merely generates correct code. The elegance issue is why relatively few software frameworks have stood the test of time: the best frameworks have been able to evolve gracefully as the underlying technology on which they were built advanced. Even there, having evolved, many such packages will retain legacy capabilities bloating the final software as otherwise replaced methods have been retained in parallel with the newer methods.\n</p>, <p>Software frameworks typically contain considerable housekeeping and utility code in order to help bootstrap user applications, but generally focus on specific problem domains, such as:\n</p>, <p>According to Pree,<sup class="reference" id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup> software frameworks consist of <i>frozen spots</i> and <i>hot spots</i>. <i>Frozen spots</i> define the overall architecture of a software system, that is to say its basic components and the relationships between them. These remain unchanged (frozen) in any instantiation of the application framework. <i>Hot spots</i> represent those parts where the programmers using the framework add their own code to add the functionality specific to their own project.\n</p>, <p>In an <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented</a> environment, a framework consists of <a class="mw-redirect" href="/wiki/Abstract_class" title="Abstract class">abstract</a> and <a class="mw-redirect" href="/wiki/Class_(computer_science)#Concrete_classes" title="Class (computer science)">concrete</a> <a class="mw-redirect" href="/wiki/Class_(computer_science)" title="Class (computer science)">classes</a>. <a href="/wiki/Instance_(computer_science)" title="Instance (computer science)">Instantiation</a> of such a framework consists of <a href="/wiki/Object_composition" title="Object composition">composing</a> and <a class="mw-redirect" href="/wiki/Subclass_(computer_science)" title="Subclass (computer science)">subclassing</a> the existing classes.<sup class="reference" id="cite_ref-9"><a href="#cite_note-9">[9]</a></sup>\n</p>, <p>When developing a concrete software system with a software framework, developers utilize the hot spots according to the specific needs and requirements of the system. Software frameworks rely on the <a class="mw-redirect" href="/wiki/Hollywood_Principle" title="Hollywood Principle">Hollywood Principle</a>: "Don\'t call us, we\'ll call you."<sup class="reference" id="cite_ref-10"><a href="#cite_note-10">[10]</a></sup> This means that the user-defined classes (for example, new subclasses) receive messages from the predefined framework classes. Developers usually handle this by implementing <a class="mw-redirect" href="/wiki/Superclass_(computer_science)" title="Superclass (computer science)">superclass</a> <a class="mw-redirect" href="/wiki/Abstract_method" title="Abstract method">abstract methods</a>.\n</p>, <p class="mw-empty-elt">\n</p>]